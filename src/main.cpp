// Copyright (c) 2009-2010 Satoshi Nakamoto
// Copyright (c) 2009-2012 The Bitcoin developers
// Distributed under the MIT/X11 software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include "alert.h"
#include "checkpoints.h"
#include "db.h"
#include "txdb.h"
#include "net.h"
#include "init.h"
#include "ui_interface.h"
#include "kernel.h"
#include <math.h>       /* pow */
#include "scrypt.h"
#include <boost/algorithm/string/replace.hpp>
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>
#include <ctime>
#include <openssl/md5.h>
#include <boost/lexical_cast.hpp>
#include "global_objects_noui.hpp"
#include "bitcoinrpc.h"
#include "util.h"
#include <boost/algorithm/string/case_conv.hpp> // for to_lower()
#include <boost/algorithm/string/predicate.hpp> // for startswith() and endswith()
#include <boost/algorithm/string/join.hpp>
#include "cpid.h"
#include <boost/asio.hpp>

int GetDayOfYear();
extern std::string NodeAddress(CNode* pfrom);
extern std::string ConvertBinToHex(std::string a);
extern std::string ConvertHexToBin(std::string a);
extern bool WalletOutOfSync();
extern bool WriteKey(std::string sKey, std::string sValue);
std::string GetBeaconPublicKey(std::string cpid);
std::string GetBeaconPrivateKey(std::string cpid);
bool AdvertiseBeacon(bool bFromService, std::string &sOutPrivKey, std::string &sOutPubKey, std::string &sError, std::string &sMessage);
std::string SignBlockWithCPID(std::string sCPID, std::string sBlockHash);
extern void CleanInboundConnections(bool bClearAll);
extern bool PushGridcoinDiagnostics();
double qtPushGridcoinDiagnosticData(std::string data);
int RestartClient();
bool RequestSupermajorityNeuralData();
extern void ReloadBlockIndexHot();
extern bool AskForOutstandingBlocks(uint256 hashStart);
extern int64_t CoinFromValue(double dAmount);
extern bool CleanChain();
extern void ResetTimerMain(std::string timer_name);
extern std::string UnpackBinarySuperblock(std::string sBlock);
extern std::string PackBinarySuperblock(std::string sBlock);
extern std::vector<unsigned char> StringToVector(std::string sData);
extern bool TallyResearchAverages(bool Forcefully);
extern void SyncChain();
extern double GetStandardDeviation(std::string sPriceHistory);
extern double GetVolatility(std::string sPriceHistory);
extern double BlackScholes(std::string CallPutFlag, double S, double X, double T, double r, double v);
extern double GetDelta(std::string sType, double UL, double Strike, double dTime, double RiskFreeRate, double Volatility);
extern void IncrementCurrentNeuralNetworkSupermajority(std::string NeuralHash, std::string GRCAddress, double distance);
int DownloadBlocks();
int DetermineCPIDType(std::string cpid);
extern MiningCPID GetInitializedMiningCPID(std::string name,std::map<std::string, MiningCPID> vRef);
extern std::string getHardDriveSerial();
extern bool IsSuperBlock(CBlockIndex* pIndex);
extern bool VerifySuperblock(std::string superblock, int nHeight);
extern double ExtractMagnitudeFromExplainMagnitude();
extern void AddPeek(std::string data);
extern void GridcoinServices();
int64_t BeaconTimeStamp(std::string cpid, bool bZeroOutAfterPOR);
bool AskNeuralNetworkNodeForBlocks(int iNodeLimit);
extern bool NeedASuperblock();
extern double SnapToGrid(double d);
extern bool NeuralNodeParticipates();
extern bool StrLessThanReferenceHash(std::string rh);
void BusyWaitForTally();
extern bool TallyNetworkAverages(bool Forcefully);
extern void SetUpExtendedBlockIndexFieldsOnce();
extern bool IsContract(CBlockIndex* pIndex);
std::string ExtractValue(std::string data, std::string delimiter, int pos);
extern bool IsSuperBlock(CBlockIndex* pIndex);
extern MiningCPID GetBoincBlockByIndex(CBlockIndex* pblockindex);
json_spirit::Array MagnitudeReport(std::string cpid);
extern void AddCPIDBlockHash(std::string cpid, std::string blockhash, bool fInsert);
extern void ZeroOutResearcherTotals(std::string cpid);
extern StructCPID GetLifetimeCPID(std::string cpid,std::string sFrom);
extern std::string getCpuHash();
std::string getMacAddress();
std::string TimestampToHRDate(double dtm);
std::string AddContract(std::string sType, std::string sName, std::string sContract);
bool CPIDAcidTest(std::string boincruntimepublickey);
bool CPIDAcidTest2(std::string bpk, std::string externalcpid);

std::string MyBeaconExists(std::string cpid);
extern bool BlockNeedsChecked(int64_t BlockTime);
extern void FixInvalidResearchTotals(std::vector<CBlockIndex*> vDisconnect, std::vector<CBlockIndex*> vConnect);
int64_t GetEarliestWalletTransaction();
extern void IncrementVersionCount(std::string Version);
double GetSuperblockAvgMag(std::string data,double& out_beacon_count,double& out_participant_count,double& out_avg,bool bIgnoreBeacons);
extern bool LoadAdminMessages(bool bFullTableScan,std::string& out_errors);
extern std::string VectorToString(std::vector<unsigned char> v);
extern bool UnusualActivityReport();

extern std::string GetCurrentNeuralNetworkSupermajorityHash(double& out_popularity);
extern std::string GetNeuralNetworkSupermajorityHash(double& out_popularity);
       
extern double CalculatedMagnitude2(std::string cpid, int64_t locktime,bool bUseLederstrumpf);
extern CBlockIndex* GetHistoricalMagnitude_ScanChain(std::string cpid);
extern bool IsLockTimeWithin14days(double locktime);
extern int64_t ComputeResearchAccrual(int64_t nTime, std::string cpid, std::string operation, CBlockIndex* pindexLast, bool bVerifyingBlock, int VerificationPhase, double& dAccrualAge, double& dMagnitudeUnit, double& AvgMagnitude);



extern bool UpdateNeuralNetworkQuorumData();
bool AsyncNeuralRequest(std::string command_name,std::string cpid,int NodeLimit);
double qtExecuteGenericFunction(std::string function,std::string data);
extern std::string GetQuorumHash(std::string data);
extern bool FullSyncWithDPORNodes();
extern  void TestScan();
extern void TestScan2();



std::string qtExecuteDotNetStringFunction(std::string function, std::string data);


bool CheckMessageSignature(std::string sMessageAction, std::string sMessageType, std::string sMsg, std::string sSig,std::string opt_pubkey);
bool TallyMagnitudesByContract();
bool SynchronizeRacForDPOR(bool SyncEntireCoin);
extern std::string ReadCache(std::string section, std::string key);
extern std::string strReplace(std::string& str, const std::string& oldStr, const std::string& newStr);
extern bool GetEarliestStakeTime(std::string grcaddress, std::string cpid);
extern double GetTotalBalance();
extern std::string PubKeyToAddress(const CScript& scriptPubKey);
extern void IncrementNeuralNetworkSupermajority(std::string NeuralHash, std::string GRCAddress,double distance);
extern bool LoadSuperblock(std::string data, int64_t nTime, double height);


extern CBlockIndex* GetHistoricalMagnitude(std::string cpid);

extern double GetOutstandingAmountOwed(StructCPID &mag, std::string cpid, int64_t locktime, double& total_owed, double block_magnitude);
extern StructCPID GetInitializedStructCPID2(std::string name,std::map<std::string, StructCPID> vRef);


extern double GetOwedAmount(std::string cpid);
extern double Round(double d, int place);
extern bool ComputeNeuralNetworkSupermajorityHashes();

extern void DeleteCache(std::string section, std::string keyname);
extern void ClearCache(std::string section);
bool TallyMagnitudesInSuperblock();
extern void WriteCache(std::string section, std::string key, std::string value, int64_t locktime);

std::string qtGetNeuralContract(std::string data);

extern  std::string GetNetsoftProjects(std::string cpid);
extern std::string GetNeuralNetworkReport();
void qtSyncWithDPORNodes(std::string data);
std::string qtGetNeuralHash(std::string data);
std::string GetListOf(std::string datatype);

std::string CryptoLottery(int64_t locktime);
std::string GetCommandNonce(std::string command);
std::string DefaultBlockKey(int key_length);
void InitializeBoincProjects();

extern double Cap(double dAmt, double Ceiling);
std::string CPIDByAddress(std::string address);
extern std::string ToOfficialNameNew(std::string proj);
double OwedByAddress(std::string address);

extern double GRCMagnitudeUnit(int64_t locktime);

using namespace std;
using namespace boost;
std::string DefaultBoincHashArgs();

//
// Global state
//

CCriticalSection cs_setpwalletRegistered;
set<CWallet*> setpwalletRegistered;

CCriticalSection cs_main;

extern std::string NodeAddress(CNode* pfrom);
extern std::string ExtractHTML(std::string HTMLdata, std::string tagstartprefix,  std::string tagstart_suffix, std::string tag_end);

CTxMemPool mempool;
unsigned int nTransactionsUpdated = 0;
unsigned int REORGANIZE_FAILED = 0;
extern void RemoveNetworkMagnitude(double LockTime, std::string cpid, MiningCPID bb, double mint, bool IsStake);

unsigned int WHITELISTED_PROJECTS = 0;
unsigned int CHECKPOINT_VIOLATIONS = 0;
int64_t nLastTallied = 0;
int64_t nLastResync = 0;
int64_t nLastPing = 0;
int64_t nLastPeek = 0;
int64_t nLastAskedForBlocks = 0;
int64_t nLastCalculatedMedianTimePast = 0;
double nLastBlockAge = 0;
int64_t nLastCalculatedMedianPeerCount = 0;
int nLastMedianPeerCount = 0;
int64_t nLastTallyBusyWait = 0;

double nVolatility = .90;
double nRiskFreeRate = .015;
int64_t nLastTalliedNeural = 0;
int64_t nLastLoadAdminMessages = 0;
int64_t nCPIDsLoaded = 0;
int64_t nLastGRCtallied = 0;
int64_t nLastCleaned = 0;


extern bool IsCPIDValidv3(std::string cpidv2, bool allow_investor);

std::string DefaultOrg();
std::string DefaultOrgKey(int key_length);

extern std::string boinc_hash(const std::string str);
double MintLimiter(double PORDiff,int64_t RSA_WEIGHT,std::string cpid,int64_t locktime);
extern std::string ComputeCPIDv2(std::string email, std::string bpk, uint256 blockhash);
extern double GetBlockDifficulty(unsigned int nBits);
double GetLastPaymentTimeByCPID(std::string cpid);
extern bool Contains(std::string data, std::string instring);

extern uint256 GetBlockHash256(const CBlockIndex* pindex_hash);
extern bool LockTimeRecent(double locktime);
extern double CoinToDouble(double surrogate);
extern double coalesce(double mag1, double mag2);
extern int64_t Floor(int64_t iAmt1, int64_t iAmt2);
extern double PreviousBlockAge();
void CheckForUpgrade();
int AddressUser();
int64_t GetRSAWeightByCPID(std::string cpid);
extern MiningCPID GetMiningCPID();
extern StructCPID GetStructCPID();
extern std::string GetArgument(std::string arg, std::string defaultvalue);

extern void SetAdvisory();
extern bool InAdvisory();
json_spirit::Array MagnitudeReportCSV(bool detail);

bool bNewUserWizardNotified = false;
int64_t nLastBlockSolved = 0;  //Future timestamp
int64_t nLastBlockSubmitted = 0;


double mPI = 3.141592653589793238462643;




uint256 muGlobalCheckpointHash = 0;
uint256 muGlobalCheckpointHashRelayed = 0;
int muGlobalCheckpointHashCounter = 0;
///////////////////////MINOR VERSION////////////////////////////////
std::string msMasterProjectPublicKey  = "049ac003b3318d9fe28b2830f6a95a2624ce2a69fb0c0c7ac0b513efcc1e93a6a6e8eba84481155dd82f2f1104e0ff62c69d662b0094639b7106abc5d84f948c0a";
// The Private Key is revealed by design, for public messages only:
std::string msMasterMessagePrivateKey = "308201130201010420fbd45ffb02ff05a3322c0d77e1e7aea264866c24e81e5ab6a8e150666b4dc6d8a081a53081a2020101302c06072a8648ce3d0101022100fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f300604010004010704410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8022100fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141020101a144034200044b2938fbc38071f24bede21e838a0758a52a0085f2e034e7f971df445436a252467f692ec9c5ba7e5eaa898ab99cbd9949496f7e3cafbf56304b1cc2e5bdf06e";
std::string msMasterMessagePublicKey  = "044b2938fbc38071f24bede21e838a0758a52a0085f2e034e7f971df445436a252467f692ec9c5ba7e5eaa898ab99cbd9949496f7e3cafbf56304b1cc2e5bdf06e";
std::string msTestNetSeedSuperblocks  = "b48fa231048ffc4c943d20403fb72c605d27d5a9bba38a45db50cab0373d250a,8767757f926146636cf26c39d5b907e7180c7d4c296ea9e6235ab8c3d800b46c,1a5bae80cb5375fdb6346752b5c6040f56fc8c33ba06b2c28dce6f378073fe9a,f4322c7a37a91fbfeb6b8f02beb03e6e38f6487dce1ac6287fa786525933688a,b11c846b84c58b9450b1306924fa60f331ff301723ec2add3181900a031b0a1e,064441c12f85904b9a436b3f5576c0ca94d93ff48ccdbf135c506f7e3d840fd6,4b77f5c12b378c205fba0985d099ac33428b2fd9fa4604c0382381beab11dbcf,45a91721099e640a4a91191744b4b7475dbaf3f80762428bdf319a9a2ab3306e,1a96dc8806ad370142f63177cbc2872b4b5d31a8d275a1b2d099b979945fca66,c33223b5aa8fac4110ebf1df62dcd93a3af4b767d8b14c39f389deba2b4797b0,9d2415a21cac33e28b885a12828977fca53ddc0c0833368fad60ef88675a9e34,8f1438d8eb3ebc94c5dcdaa71e53b260f2ed51d9de7386e701fac8f76c2a6593,ee952cb61d0a14be2e958012ac587fcfcb9f0922ff76431836dacf0f7c2b575d,7d7999249a164d87869d7fed4970ed0e31a9b12f54ec409690c9651dc376bff9,09fa404c25842e1953480a2d2db6b889892342557e4ca596f74284dbc10e30d8,318b8a2b3aa34203ee0290a686b4ac8ee835e6da100fce6b0e6c29dd96b5af08,f2caf9ac3a68798affd5c2ab8570b802a57a392140a77a0ef3eee50693b13e2a,9d63e2199a076b71909a62816ff540170210bcb27948bddfbc1886ef384a2a28,86ad156e2dfffd7f182af445758491ef2a9cdd53209b4105dbbe24d4145e4fe6,db8fcdf1a1807dfe886972a77f882e3bfd333b6eaf5ff80730d1acec9bb493e3,76113e49b4ce36d325d1c563803098889e55ed6181111234a64455187c04af24,9fb34cc11f8acfe0b0b8d2c2cb69be5a5cea19e48110836fac61b980f7c31733,88b73c787c683b04f4ca92f30ecce524b38ebcccd35c9f1f9c15dd6db6631409,b839d176926969fe11115264e5bd85541ad98a4116d783488bf41f6218fd7687,31fff4434b76540f499cf6b6ec3c11c587f1cd0a04094ac1f4afdaf886b3bf06,0f32d3499530f837893d4c97f3062eafbb2e0bb24868b748703c3f3404306b3e,e84ee563c7424f8698831d3f17ea7035a31c75735c9b7bf6e04b12c43d2a4993,cbfd5098ed5c242a5550e39f4f9a11f70b438341131d013abb5c2638ea7b2ad5,78d5d7c4c4f88404120bbdc10deef9e4cb09fee4e1c3574e2b95c3dafbc7c8ce,7bf81931273479056a73afa11bc998cdc43590d3537bdb42d1f2f7575c8cd880,a44296277fca72f68e0b3385a39ae4df3eb04a5580fb71b1d5c2c61d7905579f,55769a9a668cc9cc02e4fb282465e4914a53a3e3fa53a2c77208667ad3bbfc58,27f2fdfc9318ec931ef61c89ccc9d3d64d411316d262b4647a8f80ece31ec147,f6fd1c61dc844cbdaf353fef24682715a6b2248a578759f3d92381487c1d7f3d,0fd87636c83e70c7dadc54d164df147ad5e3455a9c2e0834de756e72afd8bf2b,9cf5164ffd9adb70902afd7d44247e92df701abf5de35bd47f5241376aaf7d7a,eded435eff878f0afdf8a7b6150ca7dfa4d44bf81acb90eee33f9c1280e4710c,e1f8ec972f19f0d6723e6ec89eaa0933e3559c1c7834a023a0a61a70a620ede9,9da35d2c898ca6a1d11c197a3cbc02fba22ce01a3c2ecd3cca320dbd195f5b6a,87aed4b63134be1f47f077618e927e3962c4934167ddf270ae675610ad265b69,d4546382f0a77f995d1ba8e104a3f2053ea5f8a0a8298fd59eda6454489fcf0f,2a8de852158af17c2ff876eacc37d17d5b36b10d69d3e8ac8c8027551661b9b9,4133bd740744ea95f0c489c1f782afa4a3e6537aae2e4f3b93b1a938206e0b05,fc887addba7fd3a877e1868e2bcf4a887e5f08feaf36f3b5890954d56524b6ff,1f4ebf3b3945a0c9f834c5c3f9f8efea1dc08cedf2a590b2ba9b54e233821137,07ec70545447125a7d6d79036acb1e6fa80ba99c7d49deb768c5ead83378834c,21784d11cdc4383c898f852a5ae1dbf6b659bcd849b4ec3e445261e01c571f05,f0e09e56de97adf7043fde352d380c9c9a9beb891969881018435803803cd030,210ad306a6e51de72180a0aecc84e3010644e3154a6dde30dad794b243e3ab1c,af7d1dbd172bc99ae31694349c3109978baf41dd64489f81d41204d5210404e1,fa1f57550160355d716d9e432eef1a0a6ec4134cb41b5f8293879ca9945f91aa,7d51d192bab392001e895d1d75b65f307f9f9f1734306bb83580e7900e57481d,65483258f29c622db84f67c12508de096b158643591ff5a357244139eda67ca0,01742ab66c9910c6d96ce68b1bc1a1c999e51a4cb7837655e9d2912cefa9e023,b20170daf6cad358d2b2c141f4492de192c29d4f6b0b96ff16d16f76f4f8b43a,9ca0fabe6a9f127f193cbd28740e8a94795dc4ac9f95d780dd5ec9096992eeb5,9423e69bbd48a704523dc0a664db72fd6e36b1d7e174bcacebd8684c7a7a3e97,aae828184bf8fe8a469befa2ecfe6870cfcf9ca17532e72b0db55cce6cda007f,5d47c1dc7acd867dadaa29e172fddebac24a1cce903fae12985f2ca454d2cd19,0bcab904f1c230942fcf12eb0451b8a1bfb8e0110f4fc524a955a1397e17446d,0c05668a49fcc4bfdb3fb58d33c7bbdb0bd6daf9453e2f5f0cecfe65ad8770d7,c065b5175c6b32961754328ef33c7fa782e4ce4bbd567d39eaf38c4386878fd1,26ecfb8b7bc11cfb56a89bccb810ff9e20e9735ba6ed7632652181aefe687854,3c9f1795bd2178ec6ba6c376efe2c8569962c44a77667982eb88b8dc8a2df938,4759a7c123d367340fe88c5d5c254ea44e99cb3af7638bce100262dd07c8bed0,ec6a900720d36e49f40b2e504c7854acb1bb6d7e6bb800411787c7145691051c,1c5bf409eccda669959c249420be33bb1f48f98d978c43a2926893d6865950fd,a3ab14bfc11e492c1107b0067e2e186d6188216d47776eec6302767f7345bac5,4700967341b6b299010938af1e29e0bf5e8587a24b02d5456a865039b45b1f72,aaa68891e998868c99ca275db6a07d840e00237f8425b9dafaaee839b86615c2,d66ce6bc22ec2c8ee0078b4b4d82e29ca40ead2f7c26223094bdde62b04b82b3,cfe96174beb235b76b1e8e5bc09e79cab2f594ce219722699f91c528e378af85,4a9c1aaf175e35182e2a64b4a079cf8db0649677df62ef9731e859f68eb19cb8,16081df0d29eaf828c901da11b0e9ebf999d31402c5cd89224f957bbc027aa1d,cc21935dde9db91507e85e4f325b90523342cfe880710703bf1f1362c23a7b0e,7886de21797b251ce5dfe1faaec5e11437ad016c24e900c58cb90361bd34470f,09decbc25bef3bd1aaf5b3c420a7a461082d75002765e27c2fcdc3a5b1360168,a89199a9e3e69a857a3dd5dff562df492b63b619933d92950680f56f0145af95,08f2ab761a3a589d6ca16cf8a68d6e83d4b5cbe466d3cbeb471997ee33b6bcdf,d489b738b7d217148254491c831b5e55f1c2e4d7387ac25c400aa1589d4e005f,1a83c8659d3c6b0b2dff535072441ceb2528a026c3bb95d012cbfe2c7310e140,dc93039a6e682aec62ec40a1a3511fdf434f4f7bc1eb91c894419b63c0344721,260edaa42d534d15f2a8a9218a26d7368c47e055d11fc8598b98099cb8025404,d11aebc8963f755f978bfba86cc9d52123e31a1889f150e0c773cd00a6793480,3d3a7cb652a6e49e0f19a6559cdd38095921d3b63f5407ba2c3bd716ac89e7ba,70e3b40bed362feda312a471c3f13e8a184277062a164b0020f86562b2336b0a,ba226a26c382e21f1551270389853cfb1542b8ff66cbfa9b2fd92a027acf295d,276b7dfb30d321d7edb8a315ba000862902b2cf5e3c8fcbe9194ffbabcc94e80,7c37f80fb92600decdac4e6407dc699d08d11810ac05e9a90dfa7fb1fa30132b,11935c084c4f4a069cda975c0e9e2c4c19b979ba7102ebb0fe67a0c64dbe7ffc,d0b625c15543f9d889b2ba5695ef767ddba71c92e08acb91be96088717c95ef0,70683a6290afbcbab7e9b9262ec286d9190e04110c7c0ac017c493ecb8c8ac0a,e760235b08558a96046c8f7c6a840d7636e8a99b9cbd77455bfa82ae8cdae728,2911f5473965d790f014447b44e95452edb9177651d06fa8197ca68416dfd1d4,8476a50f5a77ae2a42895c9c8c545542f6dd93b382db05a44fc4124c71242dc5,7ba2842ce5e9d5d6898302a155e9593e92a7cc9994f32a41203c9659d3c6d507,6a863f9eb037fc6dc3c8bfafbd6bbd565272a6aa938e99096adf68e642cb9787,b4bc315d9bc4b54cb25427d97ee2d2a51a43ea0c8f28bd5342ddf7ae0e1d8922,c8e788989034632452c3f4e1471c4b0194355f68b4ab9a19941c7a77684d6938,03565c6f28244ca80b2473299357aea389b8a1abbc2e8c664bdf1ed43a8189a5,cb573d0f98450cce1e4a963ff5fb03ecb82a0e5fb61230b619e0ad67e519de6e,bf1db8b8e3c404b9a009647a59bccf85d861471ecbd31e83fe3da31adcd7a234,10b413fdcbf0bda2a22eca43a278b852c211e44b65de765567b4d4e9a787d2fb,84f05779674aab9d530588351074f47e7cd0de666dbf4775f29dbd6f79904708,5a5367df085479a58c8bcb39f442d3a226af3b6a3eff9e4c03da0288b00aebfa,446c0ac3c1013f264ee18f75cea8da044c7c8d4cae67353d205b87f36bccb355,fe8dce9ca783c22539f4a805ec3812603b10cb2b816b53cce0a24717d759197d,21b71c47ab3fd5e223db6e21a95a0e67a68d5b07f2bd9d8a53d80429a992540e,82cdd657d2e0037dc31a5d5fa1cbcf4dbd2c72bf395d1b6f23b263995d03628f,9aa6d056e5b96922acbc1c1917a135889fe87778348c28b74cb97b571d11d439,f1fad65216e248dffc8061d3605bae71b6b671930cde83fe7c02834e70a14af2,59f47acf7d1fb20d2592c7c3d00f64b4825cd4c176a810db01d4bff8c7adab95,df06b2fc376ee91d7c108ae2dfe831a58fd87d9a827f599cba57caa89ecf8ea8,9ff151700114ef3c46602bc9208ef3f0cfc270ff8bd0b1af29dc125026f0d591,d88978adad4758b15bd87262cf1ae7a2481514707f508e8c4ff836100bda0d83,132b4842ec70f852c5724262e947f60ecdabb3aebf0ed779eb991314ae7e928c,17b934da6361c74def1e34c97575e8c6227f6e4c960b6db9b43ed65e557855f9,990460d66de73f91738a80fcc63c7b93c5056ecb6ee536432113a2c199f5bab4,e90dc181c0ac580eb6dfb7b7427059b93144aa3c418cbbaec183351027f937a3,8911d59e3ec58f0ca37b35d97598a67f45ca7f2f29181065d047c7d280cac277,624be8f660479088b438b61d593d2a7cf35c39466f50f1b2d1855361ebba41d9,49d960abb5f077930fa81f260e2ba99c572b44b2b4e7e3aac7328a1a49fb4d58,866e8529a8c8adfc8ae1224e9f3566a1ee6340fe33c8ca91f5fb1ad89fbd8fed,0b068e958c4ee4be777f155756a484f3a57739e8239de58f236a4bccec6965ff,7b03be4259cb6e6db2264f8ab44309bcb7b40025ed1ef167360ac3d058561303,288c4b01dafd73a6e84ad618f99a88e748bdfecf64a79d8274fc2b2c313fc072,cd1b62ae5d6ae27980c7a11d430c5267731973b8b194292e1a29b76e2085fca4,506f8fd9c36b265d690ee0e1e35761f2b4e32dd29f315806346ef2fc264efd84,fe7186318b2391cb141665f2d7bb29d44468a0c90c95f29e35bf072b033a6f58,5f1a372f45ddf2246dcd3e7cf0fe8f6b09c0635dda250dcbb8ce8ec68116b26a,1fec04f6dc7d10a7f2a1f446fac42094b3fbb358ebfa4e5f2ca4569e7d81fbbb,cf1c0ea179722b29b888d2ad8af25db0306825e08e91f9d8d793744b450af18b,8819b9800bffc6ee79181bb5b879937bf5c55b8c1a07be96d4ea62816ed2ea2a,562108a3b8a79da9a14dd13077ce4303b236b1c7fc6c385122de47813180b517,048f5ab71b875ebcb9f8bc7d864ab40e12c7575ee78bbba76ae000fd3c936e93,e09060dfa30fb9b4badf62b2d290c897946851a5efc72a7e9f6d2be0c0b1bcbf,fe44236cac30171b0e5912b29048dd35bbe93a4bd19619eecfb4348fa3a856f7,c1920ed48bed9b22aad70e9676730c0d21e3aac398654b74378506297140fc6d,8573de197686282eed7944cfbfefc7f550a450681bcb445d802e54a51e32e709,3a22967f79081606eb4364ebe5af9ecf82079d8e2273e4da6f5bf8d8c39d647d,432484228fdf28d35781d15eeccdf0d0a7097c40fee1f34abe9fde48174b45bd,e7e8a396d920a18ef8ce0448773e97f920b06dddadf578ce850fc7c0290eafb4,7f0579e07cefe59ea176ddf466ff2d48ec0f6c6c6ea88b7772be22ebc6003ad4,177d924d13ce093d75c4d1a86cc7363d3eda44786588f61800e2fca1acb2fabf,adc08bc43e84cd9ba9cdc4d017e2deed833ed54227cf83d159d4a5531f81639e,94c447f71b1515f56e3b8e2602572211dd41edad95afcf3538cb5090ac823b13,7eb3c3662fb5f5dba678529d75e027ea2ded67910bc2b6e9dcea7130784d6178,7803a995edd970e28f8232803e4d9091742f2e2f885ba7ef4876e7d18c29da38,fdfdf40b67a233f122da8c6bed6b8c03735adc6f10e16635e7cf1dc4dc677c89,cdda3e399290a05e8ba1be6cd120e10f44837da37dc76e773140206b8c4a0a87,62265048b95202f4fce92018254b41328c91bd563dd11e22e1a8eacab0afaeb2,d6c78595259485da318af4047ea3094e59e9e7a48c2cda75cca34c22d5cb54b6,a83bd90e8f5038d9b6a50be157148f7cf04fbd006bdde311b1a0971c619b1007,00d595999c203189332c93e1d5a904ef95b6f2f2bef7d48d932a1ff1af1cd80c,7b51a3ccd3b4d2e64b59dfa5fd579cceb17eb8d887eafc13df3a8029bfc76e5b,b418da37145bdfa4bce4811a2398f7fb05686e5a2b75b6348ba468dfeefc118a,dbf0242e3d68b325efa2afdc597ce21425803a873d818c2915fd64cd847a68d7,3e7210b45f4dcf988860a0abebdbf88c100025ca5083ef06037059b079e861f2,04caf14ae0c3729719c69ad496188d3fafecbc912d5ea6cbc8b5aa68048a136c,d368b594b3d7c895ca9ffe3f3d7458645ecddc75f650138295303ec8cebd8652,da1c842d480ff63057a208156baac4a2c4ebfaa9e97236d5df2aecf2200c139f,592e92df93f73ec2e20e83c5abe427ae78a017c5691b2f951e06526429e2b162,3da443696a63d55f3f43a85b386d039cfc4e424a9efa5af83aa01aaff70199ab,a3d11bc148727af7314e8f39772b3d12fac68638f4a1a0b1c90fc79ddbc1847d,f657ac726e2e4e016b8352cc6b52560f09d19492dce931837969c83d0abb3fdf,15c1f5d2bf65241660902abdd4358ec9aaa51097cf15aa7b7a7a0b4a8054862c,c7af303fcd957f604e01ff7a1bca669a26f5baa505488f45bd8f203a91604a9e,c431bee133302dac0a58b0b0e1a520d8de87ce50925401ff2ae75b594991c98b,84ea53d9342ab5e4307031e9a9ed6f3c548131797004e9cb92022445b8ea7ef8,f4709d774fad8ef10afbafe3100441c6fff61dcfaabf20ffb5799d37d2152291,376f310ad00bc07b3e9d766b067efb8c96066a627522392da3a3f5d93e9ee91b,063691ab65c556b5255ab004c4fb87a3da9fb8c3eeb8ff4aa2e62c044b5cef53,89615f9ece7c0939ed76256ef1e46b085b92e9f7334d8d3773d9037bfd82fff5,b672c1d79f0e2f3541e100451fd800708f14a3bedb60752e97919b99efb8bffb,27fc2b98fb3a8e13f3ee87834a9a527e152f947da3037ed9fa4582c252b24d89,1b2e3c7a4d0383f85ff7742312f7c73ddc8ce1f5eb79d0a8d8bd0bbef7383e20,3888859ad8888faf538131d32bdeb898c3b79ad98ad67dde6ed457558c4d3b51,587ea5e6debf7c08e904ed5b038666c21be7dfac07b38287ca7ea2a894a7a475,b0e4f9b11c7f791c18e7cc98cf6bd0a731ec076b15a0a48788dbe9642b82310f,a7cd7eda999c405537a8e70567afec4a60726124c5008508939ffcfcbd922d6e,47578d2fe0115950d116a1a013b5c1ec0def3bcf320dd374f9a279237f905de7,5dfa7d97186e2d7e475cf7c0f48366f83bc4bcc7c0286933296783197c73512e,f000f908c4ce95a6ded919c271ac7ef0372427416dae1605bede21629fd47dce,eabaedb92ea9126cb9c1457e6bb71ef40d0eef16938230633f93f736e725cb23,9575171662e771b6c674ec61d8c53ee761fa4a679a008a870811890edbaeb975,aba5b65b28a663a68df358db0a97c9caa4051cab99458dbdcd20b64f8c99b6d3,0a71b89a70ca410730534c8980927499e2c6aec07e06da096e32438719098c81,bf6c78237e2ad6e05673cadea97098b03983115b681d2ce86cab7deb1c4b5893,ef0fd51f7e177455c402a31961ecfec384e3dcfd361d3185b854d68788440607,786e90f08ca2c478d25f3101a5a3c50f8223fade06c68cc4468be39e7f6d2853,c9342490280dda179259c2b4d2c2ec265853081d501b39f3004136feded4aa02,e5f84f8e81ef1b4af67660cbbf90cfb586838a55502d8313cf3d61b2affaee82,b34a54a25225fa1c6d0264d98c74c72cacc955067f95a1592fdc674dca82db0f,db94278ec2cfaeaee7d9049418a0bc129b55abc0d5f10d44882a93289a25b229,956a9e497a8be4022470ee7ee261c41f1bfb35e661fc1a4d97025874d9cc8df9,b5adfd5170fe69ae7f0c2d1e43a404fd94735db1bd37fca79930a858888ea857,51eb7a17c5fb7805eb98abec71c253222f97e93e839ef5e3753aa36dc8703687,63e3f72d60ed1c6209bbfccf4e34e2e941a543bb90d6b485c8f5e98f73d8fbb5,b8b86d46ba16501518d728a1cf74b6818fd4aa2d829223746db38e14794ab1b1,91048d743f46dfbc161e9fb2e5227c121ce6b7c236d6604495c18f9eaace37cd,15b123f7d14b398a544244a09050ab067506f61f808c3a3e0039be7b6f8b6908,c9ff132a470707ebc05e5507f31a45b6c6367f38ec8b6b9169c7daf7236743b4,9ae55aa7e2e41f3e323019e7dde2785bc17f4af80b0c2bd45454d601bc201ace,074ecfa2eac1a89c0459de0fa4665356d6b7e5908d9996917902da308a2db82c,839de3bd639dbf2df59521c5bc7f492959e85cdcf67f72c099c59dd6134f864e,0f6efc8a5bcad5e0539980f673d5d581f0d461b1704965a045fac53e35c481f6,9cc4888c1f5ac70c4eb7afb20535b3e4b37567cf31091fd56a806e6857f6ca7b,3cc31ec8397b89ea7e37c5513d632922c5c0b6f9e2fc106571aefa12b3a5f576,1e7f5db31ee1e2267f0511adf847d40fca8c85fa260e5a94d4889314e455f090,d0ffa37079f88943e74a43ff97fed00a46ae1c62d1c568ce8381d45c323fa02a,ea4b0d8f63dde04cbdb390be01bd29d82e6ad457c7497bd2ccf214193d05344c,e447bff2877b43d8562367e0d6c84dc7ee91c0c6084317feb094cd64639f4779,695211c22c7d3f47da50b4c22bb4c5ed90916d4296065970e2370c73d2efd1bc,5c2c735c5a5a50bf847ac398de63819c55fc5094299c016c12b91bb2d2012d4c,998bfcc254b26b2bd3ea4dff8e50cb3cf42a20cd146ce25ccaf37eb0c9a3beef,0140bce025fa9fa49b7bf58db565203148f0bac141a1cb08f0aef46de7c2ccad,b62639f204f73d81741c3e6a756cae23c4cc017d0b5dca5c9f65b6ab5124d3a0,63eff3e471422adc48bab705f3bcd64dbcc9ca0896699385e5711e3553ff995e,81c205a18f940014ab89564d3ded1a2e79cedba74d8c3250d20e0cefa8ec820b,0562b3acb70c0388abb1858dd303f503a93794a3793e5335672d88658e6cd1ab,d4beba1d6b384ba747fe2a0cac81825415b28c78fa3e170d47ea5a2bc3a2002e,d807d1cb520f4a8aadb6680ffef14057ca0461307b318c8a87f44097b6ae3119,a656953fdc5d88916691875a6cef104db43d462471c54f569f3ec914f0c54431,b04244392d8ebfebddf5106e2c24297ae1998a15c47f91936cbcf7bece708d7b,bd0640a4308cb52b2c26f91b84558ca8b69f18636f269471d7f6267c4b426730,f4673083a615140c90eadf2202c3f4d32575e35dc726704f4b5442cab84c866a,4188a5342da86fa548b5626bc1578ab2cf7baeba466dc240822ccc65e6ea38dd,a2ec88a6492f99c1b81dfbd3fea07c62c03fc44e93350547dd72e731b05a81e0,7b4267cb48c82a5ba9feb4f92c10e39bd50c2b8eee57c71b2183e0655538a825,24ca76056be2ea99fc0dc13619c282473c78a430b269a52c291ec60671978e30,374e0756f881d37322271108703750c263c39628883af87eaeb6d18fd1640e1f,9fa949e04bb4d041375e7f407787dbf7d2b589eed3705c3d6a0ddf8f928d37ae,52acb53ea456f634b3a4cbdda23644e0dae8ad64aecf1076ed60bf20a54935f8,512d7903ac445a183dec41402a105658f548f05e2abd56e7a4553d2e0202a8c3,fb8368bb7dc06466c2671c49f8c983c6aedbe1158a2920ba4e9477e0e138cc4a,ffec3436d96d65775c1eb50c2f0257d128d587ef009ae9349a5c0e47576aad01,dcf17342da7c5b1fe45b7c4410793cb49eb59aa316b466aa3fe99b88490e1520,e8033be033958f5f95b01ee31f868559b697e692f41a00926d5707c00c63da9f,383130b7966aa836cbaf7f4d0caa620bd9c43a4a7cca849ff9dfdc12854ff7b6,4394e61d1fc70d985111c93872d48bc2e0cd676ef87f0760cffa270dd27689f1,1da453e9a136722276f04105bb647f13a9e7276cac298bdfcff5a6f6f498e849,31a17ac2f826625c09a8f3be4322c92d899c54c0e0e4bffc9997abf4fb4c0947,1a92fbda52f545ae50dd586597e90769044d2ca35383cf0546c0155b8544167f,403c1eb312331e204aa9e6fd5457a28c8c7d17b8fa28569cec49cdb08f59b507,6ac8f555c74a59a9828123f26a988737ac52b5e529614100f4132d3e6715bcd1,9731d3b9da78662c4838f5b8638d83fe0d3ebd188803d49ae65647361a189a32,e4fde396d965a719d81a5cad86577bae9f416c4c1e0eaca89d9425db292f0e2e,b3381b90ebacfafc461522caadd79927261db72045240eebd59636cc0c750128,416ffebb2aa059294dca17f91947341f2777c2f0c397d28b56ceb265b94c6a5c,23ecf04fb5d3fca3733028f8a876fc60be8ec4909dcac9efae828ad35b94b898,d12303a3de2b40852d229f694507c9df0e34be33bbcd2f652456a4f51aa5a1d4,b65b10b8245f46fded43c67f9f684da86fcef80516485f4078b1c5e222475da7,ad28b3d49d36ce084a1bf7388d1f379e9cfecd3108edb898d65caf77eea25df5,2d710290f308ddb6b48ecbe052ed35d74dccf1974bec57931f17c2d8abea4cc3,e2f9ffb3b7bfd4e14c765639ac06f32c3267712b85a094747cb39acb23161e09,4b0008b8cb4a2b1b840719b7f15f92aff91b2aef046766be59b7a3b3c1dc82eb,b95b79790f733632df367ff94efd46d15e1b7f7fd1755230ce2765c4a8ee6fd7,28d0134269759437a172d2df6b8f52b588ba95aee1db5c988ae1a2650b213727,fede4b400dc343f1775ed303c45a3c9babf651da08c88e1011480151513c8330,e649618477e35d0dfd2c9c159496e6c1061d13cad9b3d1d9f9b59bfa16b60b12,6562712859e4dd65a368d99aa3bb963195572849fc6aacdd1e8e2c7a7f3b31c2,23f185e59243fbb5f8cf83c40e9c0ca9a4c110da6825324df9f56416f3b38664,4e7efd9ca79806585859d1bb7994b031d78d2eaffa5e88a173808566701c54b8,b8f7ac8a0d5fa9f18f3737ca7cdb3282959b6651dd29bed05a16a21e9fc2db1e,8ff6d6995d68514e873ce75cad618285a3bf26668a89e7c23201adfba3c2ede3,86f89f7e669aa16b9f1070b7ae852d6d2b9aaa8eecc2f1785ad75cde6a77a212,b129af52251ec0fb66308456f1c74ea68b5d75d8af40addf718a033b2ae7eea2,4648a82d8c989aa470bb65e9dcfd407f879c0b0445892f55875697a4935a03f6,da729ceaef1d10dacbd7ba6cbee580b84677b1a7185e27f6a368d3163d2e1b28,89e14d97cda9dd2985aa4d3df815963064af1a707d9b16b5012d61948a89fe10,ecd52c47a9607d7df6351e779a7823ceb084f618f38b363faa07771c59bb6fe5,ade7825431a65e8480e77a56f08a5fb7ef0d6da85c5c6680ed68811fe4ed090f,7f4b066293b10d78f74f4804b35355c4bc1085b4b18aff379691a3404502336f,c8e3219d91fd9601c8f0a81f4191f972fb32132ac6d229d84e005065e2b1163b,afb8bcb37a01907d53c8a24778a9c645c3827727f528e2575433157d2f4f5a90,bde1b83983940b4a6a853b4b961cb26725f6469bc24f6bb5327570240a2dae3d,b89170e1f6fd772dd43ff7a278c782442a5da413bec4ed23773467a7cecd42af,2fc5c295716d4e629bbb6422f01b9657c5de12ff8c959c947bbc93806eba034d,04b844a000661db4e9653a9a4c91324a97cd409eefec6177af5f60ab51482c16,041b485107bc09d9a399a21dd03496651c2958ccb0d3a7d1c1c15e12b586be2f,41ff54cfd6a42301d555b006dbf35059a3b0be5ac20d7cf08cef92a4cf31833e,e92c4dabbfe8cd4dafab33e66eeeecd55103c9444ccb5c15e661a6a95cd61d70,e5109d911fc2efb5308e6f9ad9ff61bbe8a8000dedced38096dade2a2cdf057a,1413bb8cac254f807287fd9492e3dff8d98cc9bb5bb7888af570fdd50f1f82b5,34f6206cbb31ec0e21e0ace0df2d7979333ce4a7491867f143fb187a8c4806d1,36b4006bb86df94bfb378cf442fef3f9d437c3519fefc2163adfcce8770c437b,bb1ad288eb5c5e51d71000aa45083c199b68420ebfb8679f8118153ac3a78bc7,91848ae7a52547ce41369a5e5d0d1de9e010b1957454b223f1697fdca5968684,e4c5e3d2d2af6a66a0ca5588454804bc4d45c286f8a7b5277cbfb1c2257d1ff5,b618e927c5f22b322092790b59dee66749918e48d4a99cd6fc68ba57183b0e82,6e5805e8cdb2c497edb8cff3e482a2f0b442aee3113372cc4687b61fcf45c2d4,e516169caef0ae832ec957719a4c1d90244b8eda1a15ff2d8a8a1a6be55860bb,17bee36e0635c72ac0b7eca63c4437a33d2eb84e0fd1021ff427135c541c167b,e00b286803edbb97e157761e015c0caba0a31652328e7a77380f7810c9f2a9cd,919bd79e5c52a6b83d7de347b0c17b2016e4bfb99718f084b43ece9171800bfa,fbcdef9051d70f82481ff2f2252879715af32233709b89edc08df2752a84d3f3,0a84d678d5c5b48548a69ed17c8e7892e72f3d24030b6b3a3ae17a92dbb4db5c,8b44d70e095c3a06a8bd3499c41af62238f47dca1ebf5ec2aeeb0742dbf1fa1e,9e14debabcd3a8f3ab2688d7149ebc7d0f936f550b6bd78520176d58ceb7ca4f,794938f6a93ac078c9174b995648347718782531e13bc23a4e1305c226c1f5f6,1139d0b8277f2d14f1a2e9b9b0b037b3327f17e6bfa5993d9da480c68a18a48c,53ad1e66b0776de52010f26cbac4d9254c61db380089ca65c2c8ef03fbb4cd23,1a816b5ac00941753e8b923e704f4999210aa120507f9d4c080311389e075c84,eb98a46f9cdb7b490e245ac8e1ad320feced4f50389ade64e9ddec8bc80e0bb6,2d8e7eac2ce956a33d6e260f0a6134ca75850b46ab126a9d3faba7b3483c44ee,8d087c8dabd53541e3dcc277b9f3fcda9caedc265376c31b5c4034773afd3d1e,9c2b3261261645d717c0c05761e4c74eb8280ff350822de823a7edfec0e911d8,fc4d43ca40e282a9c8083c0e14b872016ff4401651b17afc722562aa7135c005,073d3732cdaf00b65f4392cfff6ae16f3e8605bf45a72dcb8ffd2a126e669bdd,1899ddf6c22bf3651d2db620d8dc41522d76ff9677a1626e8ac65f2f53de3417,8a96df06d9655eacb82f0ead7fe99af0298f9eb7f14e4c796f0bfe14d685ff0c,5dd50b4a706216e448f61de26475cb12b17ff075d7dbd6a03b3215d25a7fbd91,c821c6b2edf72b64dfd4bc8be591eac7887e5b92c061588473f9fd5b091b65a7,ec82c6a6abb3df873e9bc59cdd0c7eaa091438c5e4f4c1b34d15eee9e8202abc,a3ae5acd6d42c3ecea32281865154c148bad9dc342b4b71b32011a39716adc56,12d61feb8e96a5692dbc3c1bd4eac00a5b642e3f83ae00ab6b813cea395a3194,fc0d519de6bb045c941c9c3ace53851d10c80395edbf91ddebb5f8ebe74baa41,a44c43f23d193999043b55a834c593f8a5c011ceb976e134d5bdfab76b6bd86f,68faefd5947b7f1d98829540c7a4825625a84c2eae8aa44984c534d2a5d428e0,4cec72d2c5cbe954d922e072636c50302acc714ad37e5c82ecd7d1f0c8bc05a7,a2877c019bb22e155b89b6266fabc9dd13fa8a5d48479581eef945bcd188bc6c,ab723353a8f098dc19c225d24780cf2fe624ef29dfcecbbedc89fab600004c11,6f5519fd4ee54df79f60b88819e32595fe30a8b8d337b62054393f1ca6ce3604,9c1ffadbba6cee5fd6c9721bccfcb8c48358f6c531ead286363d343b379b3fac,d7544a49d883c6fa642a649a4c7c06d523f99e7d8bca7b246c8018b715272e2b,f70e818a58f15f9fe9d02e444bbaa5c40932e25767aee3da50370bb5705a1aa7,9728b8e904c12a2aaefbcfe98e27b608e8758d802c26e98b5e066fc25f521656,a13e3657df0c1be043e6bf64a88df26648c47b7d141c762e47e2293f31f84162,7c852c90d2cfac948582af76c0fe8bd56cada66336abc1f3c353d2aff66db350,2876c7a455a42bf5a7f4caf60b5f58a1c2695d5100b2204e86ecaea0dbab366e,62a5f3e3b407bb51f36e05d85f5fb303fb19ef95dde4d35fafa79c9eb78d8019,d8da8fdba3ba2be58032bce4658bc7b1e6bc1968503e3ab28f7f2ffd519ed08e,474f745ef16cf5d1bce7764e1098977beb1261815ffbe402bfc0ce8954c15657,af857507e487297cca79c5ed5df9cacb047e8f5b09c8f37571235da2aba6e615,0d1fa4c1fe64a9dfaab16b2f76e9845c1ef8c1aa1a48122d33443b265481e883,664cfecc7ef1fe409f70e60aa815ada1ec37df185735814b7da48d30cef30be4,4f23d8cd5d76bb6d813158171dff8e3120f02e6ada78b95596fa07e516b5960d,0fd1a110d1f922cc804bd40f7038a73299b8886f6b836ebd2adba1b4583a4ee8,96172b3b440b4a462713f43284ad03f4c86a28c8883071da9617c51be08dbf80,8a1e46b346f901094fc04ed8d127cd907b6cf0dde367662fe8afa37ea527cd75,af1debf7e24c3ab485c9e0a612c861e5c6b81cf27ae6b6c0041a9ba9a4cd39d3,4e5185875694f40b50469260b35850646d128f2d4bbf272252900fe1c561eb88,a58c6f41031395542a111c644a4d65c2d48e3a6be81a63d7c6512266549448bd,1e4c77a60b3ae450bb8f731350e6936519d8fc1a1de637d62a1fce5f262a8056,c5d93f0aa3de94e67c10b32ac35867fb44fa050100c2eb0fbdd7a03bfb29b067,526a3367701931a5a60f952ee86335d2921d4e0ddaa0e9241a27722eb9493e11,eea55abd00dfbd4385ca489fe6c680a6550900c6aa8f17166a9838800c48f501,de7165c2ce2b3d83976cbf150145518c1063d8cc4f36d52a0842ae311bb9d1bd,8f12136af7a45993d3f9270d6a13abb2552260d207900984d4f48003c54aae6d,9306fa8b950985d70e03acebc810fd0aee4e6e7351523e090014ee8277f4faa5,d7133da4fc54b37aef3e3fb49702616d0570bfe18d55a3643696eea5ac799557,d814075378b89d0c5391ffdb7fdc2e913325d6f49d558e9679ce747f97a96075,f80a461a6f5e5e38a3d5e3d465a05093c8f69af12be14875d56e6bb3524b5e74,350366f000ce0f8142202ee97f20b375fa829173afc2248e140b71b946924107,d218b466b616e32cd4536d00d819d56de28428efdcc9e87cf55e98f1c415e1aa,2ddc317c4721691e6fef4718ed2d28869426c290bbf44bee1c5e1db3d9fae778,35a58cfb7e242deea06acaa889997b251de03ff1bf56bce716cee245470e133a,3b2eb280480bc1d7ac64db046168734b0bdf98246d0de8624fc466c7594a5857,c5cd5062b9f6bd001a3bd736d129c12f3dd8d1bda35046992621bb04d2e5d666,596e9065d9b468b5687a5fcb41399d5ce04b7154b1986fa9c2122fdde3296ed9,d59957117cc75bbc1355ba840bc93e91cb9bc388e8e435e46b5288312e2da73c,a6c1cbaea392dcecd0994b496c7af42eea7c90238efc7bc7383d00acb85d0357,ce695487232c813e715fd60bc5014a246229dfade0fe65e2308023469a73b378,a8f57db8e1466e270bb8bca12c96415c28afbd726fe637ca7b27e04b9c0835c3,ad06ad24e1a61c207fd671242b4caeab4dc49d897bf59a4515f9c4fd7abc99d0,10df98c231170bc3d62d7b97692d74e654ecef44f37423ed51e8c5b843a4a317,1d7073568499d0736d24d1ad0869f2b00d045301464d20e0e342ca489f692952,";std::string msTestNetSeedContracts    = "0000003ff185a5b04126bb2ce0afff9cf7e139da5b51b03f033bf61fa75fd0d5,000000764820e5e9ef3ea728141a3a66ce29dd90034c4703b590e50c37978e34,00000006bd72bd17378328912b85f4e838d4e8eccb273936621f8a92e9bc1c70,000000c9d2d2019b20ca341e2cf685b886b7f238d55817ffb7441583e4f6d6b9,0000003a143d9baa34144aa6c788d2679a7096c9d1a5fade66d9fae028314b5c,000000c0e88495ced3fedc4a956774bcde66fc632c84547f5825cdc1dbd7cb64,000000056d024ab284be7b83c99be6da8c4b55b4cf317a0efde969e43b0da943,35ee8066a2733334f34dfea1feff072fe5d6d580814dfadac126106c7c2c64de,54437cbed6a03d50f057be33103ac86a9cf720e34bee3da2b66b2a0da12b24f0,937d838f8122b5492c7d016662574bca4a03e6544a9c09971504a1bb0ba59d75,3fa652cb61ac86e29adeb18741a94b2441251ab745f72cca31403f0a4fc69179,0e779c5fba68dcc1b558a7451cff543bd0b8049d7eaf6855f59ae069a81eb06c,5c7110c4e1e935ea102cb1c71c71edfddb82f2a90540f02662afba9fef374b65,1c3fa20f72dcb24f9144345a6b63416473ea01f382f5d84c0a6c83adc4097cc1,522316ade115c723a8b8afb419f6a914d28478e1af9f1602c25be5f88729ec3d,9870d344e5ef514284dd104bc0b7f8d60d0a89a679b03f9801c35605cff692ae,66ba2733a61cdea0ac81f3d85825f838ca71e99818aad4722ce9822165a48de6,064441c12f85904b9a436b3f5576c0ca94d93ff48ccdbf135c506f7e3d840fd6,438048df9bf5dbb2acbef99cb188954cb3034301af6ea14de6eecd12040510e5,354720a78f04cb37308f9280c666d9f91f3b7e1f1c35289c7ff76a8d95848487,05a4556faf08821de495cc62332860956215920d1f3dc9ba33d99ee3d24caeea,1d847c46488ee6762024bbc15836e3c4011e4bc513e7246d160ad6f384d657d4,6c3bd3a06687607db222b48aaa33303556b77922aa7047cf3508b8f1c6cc0b0b,f1795da5f032ca927e9c9d126a0e2992fdfb8f489a02dc74d04c0ae9f861971e,74a2e99d20012dd623570937fef09c43aefd78dbc1455e70a6c267e79c2701eb,2b4d23e022d4d8d959bd2b0adb9b5416e066745810f3a355e5e402a68dfcf5ef,a51bb866f9d822c34e7e411e407e9ca8e7ae259cc82fbcec18aab46e28c89646,f1a00bdd86bc65d9d58d7ad5e53fb9b167e275e2f5f5be82b87c94f972d9f7ab,e611a43ee773e6006e151a0a6714c9b34cdd10e248399f740481342230d083b8,c9751189f15e7b5a7c9a4ffcacede23c545aa657ec895aa0963f04e6b7991403,cac275a221a3c260d532ab3539598a61495b0337546c3926e40b2ac3ab602cae,85e30d985be200e3634219d33c3d1d4910d7ba6dbe68994fd2c1bd615d9356b6,289fdbce02daf3e5a409db96c1326f107ed8a7614e199f9ccbe7502464f22519,124e48e8d81f0a2a1dde3e4fd56bc82722e83b0be327522269d122d12f655644,c93d8514b0dfda83e7015cce8e01277f1a2d39661b54cfac48ad376e20b7b1d7,02d0a32b047aa9d91ea01b5908c0e77bacdc7812696a38df987149356991ed22,6c1dc6bdc6c683a909c7430d6e1a893bf2630a2be358565ed7cc6747e8fb59de,93ab6cb5f943996d577f97b562811bdf398dadee6d450321d69174dd2277d627,5b1a577cfcf311a9fd7344046b4ed15995f25f57846de28d79158e010a930a88,b95f1837ac3cf59edeb974fcc0b307c9ee3473c714fea23cbcdf949f17bf3126,6da38e963f072b17396bac626873db7eda61f30c2f567bc046f2ae6b29260c82,49821a3e748bb4f40e1ae7904676f6268456dc858b031fb1890e13569d5e2919,700909910fd558927e0826ba3ebbf6866d65d52c7124f3054ade63a9c6b937eb,8c431913db9ce49d5cb404793832c8159fbf114f1b2319f95ebb840814578ca1,c12bd2e48b62383e463c6d9cdbf27f34b817d9d6558de578c98dc8114934b792,723aa10dbf2564d899fef683dfd73750ef0a217dde4e4e2df982442647fd94f4,31a17ac2f826625c09a8f3be4322c92d899c54c0e0e4bffc9997abf4fb4c0947,4b1ff4cb6a48a53e870c3a01483097f55e6b131cae7de99072a273ca094849f1,05ff89088164f84ae138da821b7cd52d239b096a796b7feb0b3b477c04165452,8d5a24a1ce1717e81895152bc31007677f8f49a2d90ba454d6f716cd76c79bec,0a0eebb801608b90869c753caaadc9879d0bb236ea9a2137a9bcd23bf22cbfa0,7510402112850fd63b0a2f5c6647976cc7e3a916d4719b2761f07fc8f4a67cef,b144c2157d3f0e7d43daf8fdc98ae57af5da85334427d36b34bf5c78bccca559,0e3f1cedd2668a6f9646f2c799a1edbf556f449c20c3e0e442a868c4db023944,0d0b16fb60906deb52050cd807ffb540e5c630c7fd6fd4d4fe8d3f7ded54b843,36259977be26046fb16b177d13a3e1586ed9114e091106d13cdc4b2656c4df49,396b2545e0b7321f3235536f4cbb9820c24633b87816dabd85ad363c407e38ff,6fae61939db4472e7897bd608f94b361993434e6d9d70ecf1ce9341e52142fde,4a28a4a4ec9690cb30854c81c54a9fd20a27630d54896773a99e79ae250714cb,78f65ad838157ae328859a766ee9d9b9bc7143fa714776897ab3c18a9fca1b39,3797c80d2568b9683306f00c90692d58c12cb5736e98d1fd4ab1b8260a817772,680205219ce36aee42eb1de194a71a5cc3c02659716075097e86adc557e4fa31,d2347e62847c446412f5626ef77979f8ad1db7f742c986a1c7323ef3cfc46093,ef8f3c32863eb34927bc4abaa105b7d34ae20d73e371b33c7b2c28cf1e24574b,d06649486afa8f4410551c94de00c7f2c314af895e1ecc89c589b2759cd4ab93,844db6ed317792aebc7ef0635632414bdb26d929c5fad605f90e30ff9e305dc6,8338806f8b6c951102a137b0c0c76f7b16468a6b4cbca0434c0d1c2731a4c93a,52c2914b61e9b108ddde86523c9ee07d5322c7d0fa0d5cf47f12eec24a95bf2c,f6a6a3ee6ca1ad952469134b3735eb47ae264c2ed8f7af4d144230cdf9d740f1,6f39f42482522c865a305146444037dd53161631a858a71c662adb75f0788929,29e975f0e4b6ebf0dcd6deb6aa4940ad068384c7119567fad2c7a3fba135acec,08559d7156b48ce109111640cdb93dd84caa1941b2febd8532cdeadbbbe25b56,b787d67b5d73d33ff0d2607bb9ff990ea98f6e37d91c1ed37d5a7f5c5da9c742,5261bd4f494407bf8f76de5b1e209b78cdf7244b5f0a639660d1d70c72b90422,6c26d3ac997458729f6143fdc66020e13ba8b3aaeafd352edf5a345c1b896fa2,fa1a7f4075f4493cd7e8c9a260850595eecbdb1f51c87a11288a7977f64988fc,27639d3e61fab239c295b034ec2958b3689be23d7cfac11ad99b35d930b71d1e,b4713afb6b15eca73199e2bf06683fc38895f761b1ae24199ef89410cd6025a8,159d4ea35b8bd2597ebeece6f5deecfc0dc0600bdb440c70d6f24e496373d788,03646e3e6960436bc3cd52fc7a9cd6e6cc09ae841f16d1d3e524f8f4f45a7b08,3c484369523d0d098edf09edb0bf1fa213d8de5e013a02aee0b3b462aeef3a7a,b11ec8fec2aa1535ce2aa85b3e3ffeb0d630c7bfee56983e00c7f7e28139652a,57d008ca65613c531ddcffa7ee175843fc18fc114141794165493641da13b073,9fcfbe92fc80250de7c4937b602e691ca3734eaeb7edd31e7e8cd254110172fd,59f6716165aa7999de7f02cb4a8271fb25a36100f3f95f060f442cdead76422b,b53f82df1816e7740dcdbf4f7f07b89d39d44b09286996affee97aff4c4cb221,29bbc029412aff319d6939b25b10d345ef66561114339a77456d33b774650176,f1569288ed70a15dc43c771a76031d31a280145e5f9e678ce40b617d9dd2ca37,2cd9bbd0d1cf41bdb11992c2ca90e906c656197dd161b68c6b4e7bf98f5f23a4,746e19d22801abf356ed83d076fdb6a9e6f6a7784ec90e03a602fc543b134cb3,158bf6dff1e641619b9c4f1d459e4c03a2cfed86b83101d48dbf4125c071961a,f05dbb6b1a338829770555bf98d92902dc5fe3c4911223c47736be0265ccbf25,ed6e8bcd0f7700ab6c3da3a99216e4addf52c00b0de079489a2f6b7fb0023b41,e14672d9e5bd88bfd852d77beee609282a9d2618e8885903d0027a5a0b96238f,f996aab2673114ef53a232b5d340e947bc4044429bbf59a5c50e95e73eff720d,fc379781e9856b950442597588d2f3134ad58e3a90581823c165c0225fbfcc89,8a260841cd137a88e0cf2ef303841c627cace61c63a299446652e0cdc1384efb,76ffe46606963509ed6f7a3afedb1692b0d7b3a048636b824326c95461b1c67c,c9cb3916abe1f72ff553cd159dcd52aa992c868dd24added0df4c765e3837955,460a2359535eff29a7f856f94f2c497727c08eabd0d24065cb6f195b0f13327f,bdc1473dce68125bf05736f04cee1154e074f305c1b7bf63300c2dc7e20481e4,";//Seed contracts from block 1-342799
std::string msProdSeedSuperblocks = "9e8ebf6bd468093eb78c61d2548873f880daf1f1af51c0b0b85cb0020294a911,3eb900d3f78e0291313f15ce662aa15684e78cd1b72b2fd4a00bbee4156f4cc4,560c13e9517e3a85a658358840dc0f6e255132c3d2b766dc7abe689dcd412353,5f8dd381a6849e0633db72d78397ff8e967ab1710dc0f641a1ad27404cd4e445,ee5c7133649c7e765b747af21167db2e293226321c0ee0960f4e837d3acb9b5d,9d42bbd8aca2f250e274b22bedb4ad99be224b4b9433126d87fb0df6fa6d1d74,f219c943fb40d92a1d8ec1709e869c65e49e064c5875be8f984ebc22d10ab687,e3e74444ecc24ae15e5772303b081c2680fb6d2e920aabf8b30a6ef86bc12cfe,cdf2329c6c9763780b839f6188578689cef34b81ae8cc117d24f10723498e272,99a298ff72d54adb9088cab000025980f6b97c4b7ec3ec5c14e057170de91d97,e772c6e60e60a3d73f822a27693bbcbae1ec682f37fccfe622c47403f931c5b8,177374f507604582d81cbb9a699a679a5beee98feda79deb831c151ec5b73f8c,e79321dc7a0dfed00330ad99206e0b529691007659b4749fa8c984b2da9234d5,062ac21edbec458b646f73d5801525056e6391f2a939143a40524c818ad13a62,32d1c4b4e70bb8cc09dfb855160a0dbe93ab6790c58a1a4c93f3dc4a43c9d58f,bf524eb3f2b5742825d5dde2e9b4fb53f455552b691e8c30e5aa79ff4cf52752,054105d4df380b9b749f04c676a311ab9edf8f7aecb68a8005e3c0324835df39,5b35de8da7eb74d4c9331a4591aaf7b33c255cd5effb67bc1e9fd137d98c62df,daede5cf2bb3c913baa42222aa3cb70a5bd656e220fb58c4d35bb127c53ad756,d72e89108f9446fde3d8f17e7c871f74012d71c95a35b16bc0c16aa10de9a9f3,577a8dc58908be322689d0b1feb466445b1029bd9ab085c7c19d05e003212fef,60e144cd42e7d3397b22600c091977985ecb7234c93cbfe96266a08e968e0872,b809a349a330272590abe46c5f07ee47384ac158c8433c48c86e4f237fd242f8,d91a2740292e1bc8373e9f6c40d81918f2e3bbbffd5268b79bea4a0374238a95,d9e7f3756f390247f4c28de3b263386abf78afec2926d70fc396ac172eca54e7,7ccb82e2cfb13891f1a8f4308f5212682a7b61c5af8dd0bdb1bb79f10cad6ca5,4859cf592aa71fa144437966532ae69051b86f4d611b7e499c41a5bed4ee6a2a,4c84d0fdc3e523b2e0baf597965be9a6f8b18ece558a69a2ed96471aa4f4594c,56e43c72a96222ea6dc4821e95a4473a2a31f1ef2cd0ec86ef1f4dc1b2c3ad39,4d3de8b4065204c9e2a0b4c5ea34ff60fae6028e5983ff65e9c78b59d1156b5c,ae515097bd2218947c5f77e0b787b9e2497fbfd0a46bab1b8cfabc60fb196695,db0378f64b10b7d321c9e8eaa3f4754287272861ab5976048c1600c66934a8e3,579034a2bcf16a812aa4091067678c4b90344b0a301129fb656ac1150c436e06,e944eb93b16af82be286849c52d3d2bf5be03c51003049012886ac426acb4e51,ee3cf2761ede2f82157f37441d65e887a84167abed09879b5f354ba81871c947,db8dea7546ada70759934802f7b9144ab49447f695181377f957c86776c48755,db6ba63d436882e998917720334b61927c26e7065feb9bee980a8f6ce5ae7ace,103a60a95b34a92763451fc016e3a39b0496d5dc43eebdeaed660f46c37436bc,62ccc85df211879237b0e1986dc61f8ddc763ed85ba5abd1c7a0a134ca31d036,8758e388864089924f470099619d4f6259775df68905206144ed1943b948750a,07236afc06795d0bd0ab37a9adae49c0ce4c50d38f5dd57488dfb190db9696f0,17c5f3e6f1cc6632e1d2e3284086e107428ab319740f986f0877742a995584e2,49c24c9e2854c45e53a2e6994f642258e2292e0665672f2e159d52600a8107a3,643ed814745b31b2741dd21f8a0034163dbea7f6f8b34db3747d6c632b5c04a6,da131e2756a8115917f62cb526eb2be595c7cff0bd6fd281f7afec2f4bb540f7,26ff8a0dca0293cfddae62170e66a43472ac60bc915714e805d149df9f82518b,4040133f1a6212fa9024002c2540e3e5f3a8b22f33f40acbd351982fe2bb9073,f13425550862db72a34741ae43c0fb6cc485cf455b173b85f0d9a89b628736a1,66428f811211e9ffdaa89dd903eb4bdfa408c2943f17d7ebf8ea02b4010fd158,58976c6840f9b1f7a477a400b75574f017be6ee14168afa53ef328eec0c2f92d,c056f40b8cebd593e38372aa22bf943e1fc99dc96941163b5cb98ff47fdf16bd,995113cd2da40b13d98998cf446eb609a571e362d9f228884a329fedf0d33390,377d73176b5e0bd7fbc7f577b24e0f4e8bffbab8721f6e984befbe2eb48a4075,fa6141f1203d430613f0a4ae800ff222b57b425de102ff3fbd3cc3e53513ec88,46711e964fb200d7923151bf5e6931475d3c918a4888ac3e98746e7578c393fa,44bf63f514652596dca314aa1f99e2b5d3590319ec77d4732b02aa4b7fdeb415,e8da7ef98b2ac38290e12e0a4065ca8831c4030cb7059d0361fd46636e1458c3,bccb11976803c4d7fab4a108f087d142828d10a8c3da535311dde871ffbb2a8e,b49aee8eae15a837c20cec130572b3ab8682f01275fe04b60481695ebe821cbe,0aeabcb360139f7e42949e86e756bdd8b470676b8062cad2d418c93b8c14f74f,4198fa29b01661f26b75760d3ed4caaca9f8cb0c9f76f4a81351daa57dbfed63,059efef467599ad9d47abb849f1b8048c4ed8d32fb5dfa6eb98148e5020e3931,280dea2b3a72204464c3c34a9593e7d9783b4cb53f6eac71e688e0322feb5782,add9aad4f1e469afa8fba17123a8247a3b7212b63f7c2359424fdfc2b8c1d635,eb12dd4f25243b206a716b88198c6103ecc9b6c29b43759f99121e277712af6f,2f8d2ccba92d7ea233f8ad4833f9d201d053a7bdb363f03974004fc6b74999bf,1bde669c555d266d239bdcda921c7119ad07adec85d234a98e2dfeb8efffd929,4aaad6ab5b60e54390081e8ded5bc29013d57e47c0132a60f3c914077de86a24,621bde20181d401588e63afd0ea00e1d9f6d6f0650d1b25ed3d8057d6c72b419,9154661c059931b355830555ffc4e4b91c43c6f5e089954d541d0f1208db3be0,3c2a607f8abef58e846d076a35ce07dfbb62c538d385238820122f1a26db55a2,5a9f4ee5b3329744c95a1167f95ed34ecf4ed379461780ab5223b5822e0b942c,af2dae58310d77169faf134a5de06c6e73604e204511ff61a55fe3bb77706dea,6007ab767ba3bafe3e771db8c80ab4fa2e6afcea2fc2d0a3dd0c2cf21c8c44c8,3081a342b4741a99291c36c9e6244a7734f52c92125c846c129ae98845ab225a,1e2864f44772675b4a2994b1cbe505a885d166116da46da0b239c1c3b00d0a3f,50f835828064d0e1f56f3f5b6e79d94d54160ce4fb455040aed05e839464d324,999d3e46d849e131c1796499cb528eb0fa6536511e3113fab9d3a811ffeac2cb,9f5ca3353e18ac3d061f478c4805f2a02ac8b8258140ce45fe15171d4369244a,377778a6910fa281ea580515f0412cf763024676ed8f10f397e4d83ddfead0d7,6c077c477384e515fa8a7a2869a10da3ef3543af5a84b00e5b27598bb5f149a1,ef6d023ca030e88e014cb5acffc6d25b62447aa13704e3a16e4459a6d8fdb08a,78a95fdde685e8a5a725efc6984f40d9c09af74f0aa2bf70a41e683bf6e85ac5,073492a8433fc2422d51748beb078848086c7ba3f3c7367cfedb67baee19e62c,1e26037d4254f59711e8b64c324abd4ad5b1fb6dd369fbebf71dcf533ede237e,330c5ad43048f79cd5e50d496c16e6c08b01b3c10c88dc76e6aafb88cd7292ef,a4eae65312c31eb0fdf9ee92c01fc960b34f1b3fc6ed418342b89596af82467e,876d08d8c2a654d8135d4b583ddfc37dd0b2ad93e27be76103ca13b585e89b0b,04562cecbe2d6d5c0561a781524e87b980f9f09ecf4e75ece03593725b83d721,88071cc84d838fb9a82690494e2f8f455d9efb7d165dd3a824ea631ba867164b,2bb1d70a30f9b23ff1a774990a62a55cb430f5ce87ecf35835aa259c48a498a1,736bf7c5db8ae50edc815e088df56889045bd45fbeaf76588504757bf704c285,52aa79651a73810bdc983126334f322b9ea8b0ad7357763410c9c89b591e8063,c4f297a8097399294c3892f5a27b5a5b9bc1bd4bc30a1f90af2d5529a22dd9ec,83bf53efb0c0ab043e06ae508007506d9225a8c328ad5a38ece345274dfab61b,ef8ac47e8aa7075d06893d8662beed9f8ffb0453f0e530b6fbcc704e721f1ad0,b78ac6634d575eb194293e82e5155e7ed2a29ec8dfa5b75058277807b2b414ff,3bcbeb07c702237018e476a2a3687a85fb2581097fe5d7675637e103e04b1d38,f9b4845fa9254228e004398685e595bc912e2f7649464c415c53139da30dac02,2c5417a91020e01a1551cd483e461d9c7863c285837c9dfbec895e0affcb4ba7,53fc6dc2dfb2858103ad4c2858182ce7a7740860b9757253fc9b5631d7643ae8,52c90482b3a79e007b0e8453bae28eb4d6c827c3870e35b801b341de07a2bed4,c82ec031213c10b588cd12335f36805f7cc123208905acb67270e4e936917157,415c16ba409679cdd349aeb55f56bd5a3cb57b48b39b18833aca0da11ba82dc8,83c5f0ba8ea5b23ed61423c966e47b7ee7d28fcc84760ab7984a1bca8dc6debe,79e0ece01c916de5bfe73a62ba8f6c473f61cbf394cdfca7ac725c147ae5b08b,b0cf4dcba70b80547f4a7ced34896737351e94241e082c25b47ca45948ecaff4,af19454f4b5cb90f5596bbbfe41279cce44a09f01c389a8d9f8a314a6657c2cc,6f882ae563e541d84c8cbd24a680f29b82f98ccb1b13d1f01687d05cca6bcef6,5ddbd51e29d9b1f4252ae19ca5fa3fa8c70d5d47232c242db3655c1cc3e1e451,0bf03289fd15c298da70b56fa716a1c324c16eca0fba6474896bf88bc0fae36d,5bfc1f7fa9adc03c4b0062c7c7f11b925d1a32ef243d79d2711f15a42ca50f51,983996b293a8009938c33b45e5c372c2639aff8c43131aab3714b41816416677,c3ad1e1add5d731178c837f07c9c9642b2e3e886ae4345ff3de875d50da0fae5,488cd9d46f85051539144e5829e1df051e916ab8c85f5ec3513716f52af590b5,0751bf60e97d8c13467130e3017532d564835b792dbfdff907fb7d135a43bb2b,db4c52daf0bc1d1277c98ad91dbea64f1045d092c3ba9270fc096ddef77c1436,d1c00e22db7609d1ac2afb2a8e8d40735f8091bd6f974a216fcc1defe0addba8,ff35223c55456fe0c8e3103e2cbc82e1894402e0bd43e26e28425f4d235dafad,3705bf76518e94a126331adc5b4ff1eeaf10ea026aeb9f2a76bb7500bd9779d9,8e481b573d1e24f1a71b597471051d0b1d9bdefe8f5c4611f508c75cb305de3a,7667949d946b22a281300862772514603dab2ddfdfd89a4b414f2a555dc656ff,0eea1873f726a22056fceb9ec34a1d5794519a9ac2cc629e1d5e691c3bec67f9,76feaab15f22001c2518d389406046953915646e432f8638b8ced9d7a9175d62,0f5342ef13d6d5816f7e7dbbb7c7228638fc3377e1da819b67c2fc55edab9088,834bdd3e8ba88ebb06b05baedf5dceaadd931cecff5f4f6310b1635f9e3c8153,610131575158ad19bda46a09b6da253f9558ef9e0bf7146cb01faee10d1e859e,a5b4f3b0427831e4ac041aa290fee7799bc32a5abfabf332d1e77628146ae2ab,a8e50699b4c66d584239b1ef2292b7cdc33ea6f057e47993e1cd28e651587357,a30ab7af39b0e6f7f584c5fbce6391870cf658a2a1144c475b5c05d059695d68,1ee7b3ed54a3dd139c125f06ed38a80e38eaab7f509132b1a007255b1e99d5b4,76194342684d9d424710c11ac896a86afd5ff2487ef6ebcef2d0ee52663dc674,3614cf24e382212075fad859102c2dbf1cd9916d44e5323f76ec401fcf8cccbb,dc03bcb11a44151f4997ae7daf2ac2688fa918af36fa1f00fb9c7d1c4380be93,8ef2d28000d4944aea7077514a452a739dd09093e8caf743ce93a21efa9b2b75,1f8670b68378e298ab0ec4fdec94496cf34d36585c636daf078f82d73258c2a5,8f50da9702cd3842045640627955b4ed91904e8a4cb8c6d1c5d87ab524a90355,9c5e9188010b46a3e60592c03e401609d6f62e23964ca794d1383f4d5e0a3cd9,917b3a8867cc33e827dcdc378fc523749a17c9aa415de5725e11c23f02c814f4,6709a82107650ab5b31e747070a5b8ac902f4b752874e74ceaf1c757f1214058,7f1704c72b77cd0e0261e25dcc591f9f38785e35f97208e113a20cd2c86bac4a,eef5b998e915f1e73b27faee696b984547735a436deb70e9cbc1d65a615c2bfb,1fb1b65b191fec8a2d6b05d1341a6a0a66ba19af17d26ce7440770119e08dfa9,ac8eb45f3b8a97e5974ac57c8e18657eeb3d083a750f75ed49e372ac3f245f5c,a5ab94121558d2d263de47d0ae200cecdb613e8fbbe00113093079596a3722c1,84cdc2a61e1fdcb393bda621e2241dcefb03e5adad3a2fcf36afd2b8babb112b,b9999e328c5679517038a8d31c6675bcdcef4c69cda65ee87a4f9e1d5b965f83,4394ad76e4c33d144da32085932e7f1d04bd85d11bd1231a663f7034392adc1f,9ac8375b2c7b03bcc974d781ab0eb2d3c0de4f1954053e6687271a81082effa2,162093f7dbb3f15739e5a30c286be1825352086bc560b8f1c9d910a8ed028232,d5a13656c39b4d604deabca85bee256b5d020c73309335c086d1b2a6565f96c0,098240230eebed7153909d5855738b2e9728e9cd3a61c71c7607dacfff6a611f,a8d38b18e2a6e764e3a6c29af4669ca49055c5c89abe46e8a940eb2aa3d11149,96a8044f9117899e784e9dff2a57fd55a2b0972b24ceba89293648b6ad9c900e,01de03e254719eea9327eac301a780a35e681162657ace1522c6511fc069c6ae,f7b3b87f17878bbe92d22b4e407622e6d1dca6fffaf61d35d462cf1a274f5cf8,87ea8616ce513379ccde54aeebd10a8e2e49e9efec7949c95b1a26f24d22b61f,4d0621856bd069266fc0f3393b7078e935cd8667dce59746db581554ec0eeea4,d6496326ef0ab7cad09b2810dc8be424de2ae644eaf7bd7948a9c5fd5584b5c7,356083c07b935567751500a6cfae572c462c6234ad4a2cfe3e76d7cca1013f9a,0e756afec8da8d5f4fca23dd4efdfbe5250f532a5eae4d29365a8faf822b4aa1,8c8168991b328525c38d9626bd5814088767c58e9ff3ccf1e24e89af7e63f8ba,a46fc8c6b0be9bbb0652896d9891fb83b01592661dde5ea4a939227360f14298,0614c5da4ca89072c359687c1c951a9352845d205056f1e5f66b2e66941e817a,cd13b97638efa78ecdee9f4c7257810b81e0472c18b812dc9d54242e43468af2,c03f2d0ade30476adae9dc4d6c6ec9f2c5309605a30f2bf26b6190ddd773be52,b0c093627b5822b4780435dcf43293b313b9a985475026bacd6c8e6f150aa425,f5b2b2b6f8c44785746ef575260ffcf497bc8aa75e18f81bffc10e884417be1c,ca026ed740a4e068ce4274df52ede623b3267a47ddfe27f87bd557b5d6f24b85,d1ca83a23ad4356741b02ee4795d12c28fd8b165d9bc2efb650fd33d05264efa,3af050ed9c474fbdd3a42c9f53e24fb4420fcad3a1fedee72496792449a76998,ba6f2d75ae41c0cb2271642d5224a8fa86fc49bc614d063e349cfaa8c5efaaa9,685647f6b57c3e85d4c49d0f6c061d92ae3ae5cc132a3033b12f47b099eb0209,ca38617cc1b97854a24502717a3c5a2ad4f6940f9287d847235cbe41ec67062d,58c3cd2c1e9010dd8abed5d5635865f8d7de75ad7b3de642d6efb8fd92ff7ab8,4c256398194df457530e5afbb55e637ad2ac32d426f83c3049238ebd77cbdabc,b90cd737ea7794accb4220d883837f668d75501cdca9daa426d44c1fa2082fcc,0912f9320d57f115cf24bca270425b19cd9655ca68faf957d061f48c5431e382,4c0a8109e568a6ea43c39a7e3bd2545e8925a674ef0312ec46beea9576cdf186,2ba96c7a80c2084ebc8c467dd217c54a61dc3bb38cde457f26f96fa8e9ecce32,1a8faa20b2e38b4b0ea48830d141e2c28b8ed12890a45711e13b15d3784e9ee4,82c9a01e47fd98380a95d48fa3d05a99c98a0532d6459a4ea2b88ce3e00dd89a,7dfb1bf44c20f45f532be942f9e87c23e55d0ae31743734155383e8bb806bc8c,71a2ba2624bf8542ab19fc056a0297ba12e83f9cffd05b67f3551390783286bc,f72c21d20f0303e6531620f633299beb581efff60f63b9c037853f96bdf26657,2b63bca54072a7c5851f12acf861be8f5282d9ecc748955dc398e6fc4262f177,d909c808752dde3b0a7d14b25888f46b562b27512d2ee2c4fa5772723c8051ad,039d54dd7e3a35e477d162465791d28a20a144e6b0672eb2ca1816266c91646f,8f7891affe4d7942375a11445c6102d2e30e8462591aa7510da6c12775a81644,3eca99c7db0bb7a5f6477b8bcf00d1be15c16399f1e51a7fba782a281d46cf61,54fa6bf6423e843a765784a4b6397022fd63eeeeb58352ab11f7232bd09c6e47,da62a41ad1c29715f7122b75ed53ea335a4baeee3d6eea7b1bcfd2647cda5159,a7cd14baff4df02665efa20a7ed58641f2b083aeb2b7ebdd1eba7fd18dad424e,84b47150e780596f902756ece25e3f62a0b758ed50c3bafc666f223946219ba1,bc6a39e96614ca6f815ca93b19b78558344e699363da992de84c6253588eced7,44bf822649e75780acdb59a0909a6f500f689efc68e3076d14a973604ce01b7b,106f07b77e54dd7c969644630bb5c3754ec1fe6c9a8ccb2ea8227595ea97b54f,908d54bb53752e8ec506e2de96fe0e1f761c533041c80fa2a10889dc7bbbe053,e5f26fad1f06b8e880ccb179d8ff70cf3e37aa7169f5629bbc19c8c4707fa168,e0f66818dfb9e5303a001ef7897d339d9e8a65d13ad6c7ed5d642f782668b6c0,896f4ad8d0541ba87ddf80ddf51ba18f3c080c1a0b696c41a1c8c743ce87ec60,9b9ad9391dfd4d9c98a6f7f6ea2bd17fb6fba7201f4e835d3c9ca04c292616bb,302cc1c2bfaebe9ea56090dda16eaf97ebafd8f7ad14d3908072df475a24fec2,0d829709f562b389bb127a423b073b3ce7ec8f124317f223b925482e7e16a0ee,d7a761cf0625d0a8701d0c83c20606f49c911ba0326dbfe72e24a996fa03326b,dfda56fa621e6d3621cab54a500324be0dc34425b5e061eca99b8bb00742c312,cdeb194932e0ed0f62906f02f2a46a1cb51b71290d46de19a55ae8cce46ef3b5,3e0ce80673b2d4246dffaa728d594fe5e7a7713137abfab699ab2bdb9bfca6e4,80ca937a5e75331b12c247243891bf398b6464709d2864fa9c3857f44247f94c,874e7214286e1f128fb81306ea1436b6160f737f0f572331d962a77d600df27c,8356d16de147c8c20fedd19855db15a32bdec7f0e02a2288ca427232e8d0ee50,1e877466851bab8d5724dc7e0c2446dc2f0e08d65c35a87e6ba6b61bd8e4d764,6736b9125823bd0cf933e476b4abcfadcf8b4c587c49032cf17e52293f145ae6,a7acc8f1e8b3cc0d908b932bd4e6c09368ea1cf71d35cddc007d5629a721bc7b,e6169b076c151bcae53cad45c14c7714758d7174961912705676d01c7acdc7ef,d398592c5e353dea76c37a7e8edcc567195881cf409e0c5df15fc51b73b4e761,1fe6d3fac2b4a6dbe263020a56ee336f3f84fe0db5697ec5db25264d9418c5ae,272aaeb9552a7c17a205d448520c5f7b51a25f5655e98d6b9fc2d38ef2963499,1d66328884e30fee0e4f71eedeefe0401ce990f1380cda74d08c25dc666c65d7,f2b6e23b0790783abf2b93e9db148f08f84a9035203af2ebccd4f209036e2ef4,8d85d8a62ff2e4c8097a05cd57dc1274cc0a39dea30a4aad5440683e6e3c104b,3328a4ee5087a0eb43b151070613f781a8738d197102c960e12d18072ba365c6,929fd301734ed823765f7d4c1f4988ae5a085a119d78c2250cf53bbc0d47f3b7,afc9c0cdc76d2a2ff5dc00be19cb83b06731f5c1c4cf1fb53a26b7a99f73a832,a82e0c8fbb77933d00faed028fc66a02bc4befe10f09e4c3938515db0b173e1d,74ff53a786be4d016686618b8694fe1e1e64cf9cd3da15be71caf2dfa4531de8,29948a18945cbc28802f3ead075a38e931cc7ba6b68cba38fc2b6d82aa549ad0,8586cef4c3ed0c516c0630a35e6a487a0d784fa2143e197dce6cda0896ca79e7,f125a0bef68dbe21b2242d0f7207f918681f36e80223be703e4cc8ecf37044d1,fb8f934c0868a9e6ec851b7e6675acf95cebeb7dbfed1da358591b8ddbed9d6a,12a3c790e7b7a492c51f2820700afb4dc5d32e628d032d795de495063a1f4b11,69889af177177d4cb97a2ca2ea813d1718a8a511fa7be4a38ef8ff2fa6d719e8,590b0b32ab6f64b6dc07f20bc766dc0408d2e0189607888b37d9155f3570f413,ff34eb7ce802e298a9fef78d593280695d27d47850f9255a21d29890ee9ad7e5,112703a12b3799f842c95818aa7f59a9c84d62dfd0619454850200b8a8392d3f,8a38668a291ab74a12050d00f63a9d5aa230d97531be34fdc629a5ce135b9960,3d565a33fb5df2d82e94b36768e296ca3a9627bcb8a58fac6017d17782cc0845,32eac9af49e974496d3cfc4d19a8e5a44fbc19e2a9d4f06ec349af5e80ab22fb,9d6965694facd3c82a711312b868292777a7f633bd3229457f3168bd01ade07c,55d03a6a1a19cd94ea88e7d21c0123b47a513650c444646ed4d6384a1bdead8d,bf17edadcef9182f666dbdc11da558e60d25fad0af8e2aac1b7b68ac62ac3521,4da212b6e133082ff24e4a1dc516b4d0be64c1fa1b97d8645f8cd63c0392601b,7adb3c7dddeaa9c846b18586551ba80fe3d4d79ad4e2193f45f13c2790eca819,3feff7dc76f3b7a4cdc7736447c0046c484153654c0c4b5bbeb29b8d61fb5391,da8b5f3ba1d4a80d82cd6d3776e403dbc37d5113310fc79da8cb315281b15432,dc37669bab1b738e699dcfb193d993fbbc1f16a92dc74bcba3f30f882b748f06,31af820ba9de832e86ba2f22a99eb9f1c84318a177c49b9421998463de443984,f74b66862f46e1f3e8c99b1cfb2f61b88ac355a599bd20004dda8b789df69d70,7b12dc56f44ce6ce73c0a00f2a4be8c627a31d279420c17f7cd11af91aae0be5,e22fa6f94f87ff95ec3dde64ef80da6d25f4dcce8007c77e8c5c82bc4ad88927,a84b2b170c397eefc5f9cbcf44b679e686eb6a8070e57e0e3b52a6f08e99cdff,00abde03f88e20da3b2cf5ad3d645a9900ef11f011c865e595c5f4a9affc16e5,63fb5071919f93c0c54868b8ca512fdc4389a1d1cfdfb67b48f3853f65ead23f,94f1341d9d745fabe3afe29cec2e9e895202814950d32939134cc7d290cd630e,47a590c6e8fa7e833c502d700e7489b6aec0cbc82bf6f4bebc4264b42464e194,4065a78eaffe11e1b920cbfe5793dd3df8cba950ffa0a363625375d800e17bd4,5c85b1980091a3518a33be5f7973611fb7b7341c697986f38012cb823bffe4c0,6b9e089630ec806cbc8c05a15c0c0e6739e30c0f825cbffd5e35c5efc6b2cb97,1a9dbe5bb9a73501b4387644792b3e2bdb69d4c3743badde04a12e38b45c7248,0a47dc1366a79ca6a8fe868a737dad98179512aa19dc1e324bb480e944b8d8be,af82f4dc730b3716f0e3a9ffa59afc7f0a6945f1c911346aef7090528f05f671,6ff385d20ba26b15b3f5da9ee0c3f9a265db79bdfb44f5a66dc54e7025557070,f7c7c1ef20be911afc6c6f85b3145fcd820a42af64a9194049caf72526899b12,b7ce6fe05e14c8c55239d8ad3f2942592359cd654aea8e42a0264117ab88d5e9,3fee5182d328008250a3e1a9aa2a1575895c50cf8ff9983ea8c7f30721ded9fc,8ac033d9a39e9caa3e6cef9dafe53755d16822607d22785e1f9e712944ea4928,f7c81b187785537ebfcc26d1f642602146f0e82840fac410161367f9703e7fd2,2c47c8979d321d8f0a132f84d63bc005f18303610d0285f0492e0b4ef1dfe449,c5fca93db4e3214708aa0f4db63acf49b954320bdda388dae2948b36b6c252b0,cf991455eb0232202b48c885700c91f59b1cb1d68b2496cb9157aecc4b08cca6,d4406064bf5bd9af6a51b2dbf2a70f247cf1842cc31f36d5f6a3956dda370ebb,f2ae4266dbf918852cf71a34879078d9e02a6368c77f3d460ad7937ead95daef,645a013994bf0fa1087bd6e47cf1d9f4ae57bee4b7e719c70cd1ce2ca5a61399,27dee3455f6fdce7aa76755e1f2f625bcd231deaa5979ac8392cd6307a4cbf69,bb1fb86b3ac298cb417259db7c2b649288ccfe9066232708adfdfe2bcbafc49b,66c9f3d56962dce6ea7e08c9821c05de1abe6ed77a3eb6740bfd6f60d1109a73,22fc72a873318e0715fef5c78d7c886c572240b6d62f521e955a8e98d35c9b8e,bf568f394be63cc5271c4380d10d601b75b7e95e7b2aa1df3f1c0c2fbd8f022a,f6d0251ec57eb94b113a4b691d037e4affcc4a31ae05d04153ee6a101fe2192a,9b156ee766e963f1ccad6773560b37d4e012d58cad853de45e3fa854b345ea82,f7a4bf49648786edc5aa238cf76184c5296bc6c34eb43aa38e266f37c7920c1e,4429980f008f122a0749d8e9595ef58ef3e5c64bb574cd0ca5858445a61a3164,32dbc4d06bdb4ea3c56d463dd6bab04c2b369153434b8832e3843a6a836fa56c,08785d45cf7a0052da69b30cce7b474c52694a7529c9cdad7df4a1560c06f2fc,d0ccdd883d460316bdaae788fc167bcf039e4bcf5af47ab7861b9649c5cc8055,17fd34f8a03ac9d888a408583b45c43f8ee838c26bbb58f715b287cefc6a28a0,89775348bfe8d47833b675590e912f775171d7ad2e54f69c2c51363e405b15e2,bd7263a80416a6ca214048ad83222830e38fe4b7350bb50f7a6f61ed56a2f05b,66353257030f51965d8ead2971f0d567ddf34e288a42b8a37e09f49802b7bb2e,50f7b0305890044262fc03e8a2bd55a2a402671b3287fb3de881bcedeb7a2e3f,9914f4470b4b13c8fc5352507778ab4185bfa263a993a195025b461ddececcee,80c295c1cbad63d963aa318e683bd41b1cfd32626bafa5e587fdfeb8c10d5cca,6cd579e147f25e738ca7f39a9b9a73022ce327b6bab8ea3d41c6096223e341d7,025918f0ca7f916fc8d0d41e34e349d3b405e9024044517c31153722ec7ea4e7,989ccbcbe2df7b1e2c1e5f0b5227451b6dde5ddf9f36193192c560b563e742f6,ceef75b4f5f0c9c99664e31f3572d0125366d4c344e4e1f006c8b5eeb4c97113,f6308054aeb279947e3b398418901fe8cd74579708cfdd38c45b9eca63b0e099,c10ccd02c1989294bb0209774b32f5c29530cfae2a53aab01a88e5235a70e976,5dd15cb8483ddf6fbcbbe70d6b54fb0203045d25315e42489e41506de4893e6a,9cdceede9c8c77b1d299aa8b3273e59b6fe7a863a6881281775d760f47afbf2b,6d7a6931c79e2dd9972ea84bf790ea3347d6598eab31d860a57901608ff3cbe4,38fa03a6efa50bd5fedf86c49caffadfc5f0a061758977a3a3664ed89d97c302,ecc9dff809d50af133d749bda8a5caceb47c52e7c2fa4bb1046213da06cc2923,12975ba6c0d28fe96e8b455404abe34098a823092a1ca61d248befcb514ded4c,13c019471ab89e0b624df9c15bf9873ad61e418726cf1cd9cc5f46f38311672d,e80b2a4d7ac6621d09dfb70e8132324bba2c71983b2dd812f7c3359c141a1a88,0e0cd99014386a314f5b4fb391a84beccb4b046ffd288b37ed9bd42a6df000ea,40fea58ee7ebf9cc4325e687a1d3bf1983c51ef826af090e6513cecf3901a607,1c728a19d36a729408f3a15af1522bd24c190584d7d596093bc538b7704ce47e,b5b7561ca9c64694861a9a01ed08c1db87b5902d824a639c5ddc5a03cf4ae59e,82f7a6cbed71a57eea14c3a4ee89a32f6ee57fab26ca9861a6817b4c308c1283,33f55f2f6f8939c5c75018d0c66dfc14dd18d79832909b2138c2eaf717577100,db538b2e2a1f6f60614dab798102a70d8151780d01d169c5bd2c10318c855708,a462340a5c0241b5d29d4f78149b8db22a6a2c6b80c36df08ef7a7e91b4de168,ae33638826d8ab9f27b2b4dae6a67557a776cd26416357f96bf3c41bf33925b1,d464219d3068d72e18481709a27b888011647112484b4a9366fd0ee5f82a5987,7b2f9e2434285eb45a62dd918c022c8f33b64db3dc13e606d5c96743df33c75d,ec4e6cf8a9dfd5ba709cc62726674b1a680ada1a25afe9ad5c7ba1581d59177f,13987d0cab190a14cca6d1b4fd15299d423c62e64e497f3832714dd5129c3c43,7c51d32e526d50a92b4db7d66b5c5120ba9a5bbc574c8a2fb18965f0542959f5,9b8c1c18e1499296a7bb87b512b317ade730340625f1b36ab77254d06afe089f,d13584b3c5c42a5540bc5091b1fc71f34301ea68b42a16eea4e6e79e3007a54b,ecd09f34e82212bedaff750adc772e2410f267b1c8680a1146c69bb0a8d55774,de015fde82d75b7baa6f1e7af6cc306ae406a9bbcf37eb4d73338b1843a28abf,f00a0626f30d7edf6ba84ef375950c22fadc8c9dc31355e2e438cc948cc6cc5b,987f856dbd066aa3f62a4d3ea1a3eac2aebeb4416d83b48901b8fa4196810a5b,ebda5b5674564fa6e26f0b2d697ae4dbb53f0e5cb77a62f15c91aa011136d6cb,9fde767d1e7bcd9e0fdd3081c07c9d74dc3075e6b80702443365c07f4a86f877,e8dc2fc351f89a9dfac7d259abdb9ec5a8334b0a139207713ae8fdfee054778b,3680573624370f5a391baf28c6bfcf5205a0024f55b78d6bff85ba8884c8ab3b,035193910ec0b2888564155a64b2c642ca9bb9a4b00b5ba06c973b249be9e80a,48978c95d982667cda6190ddf6737e1049eb5518a5ca552938fe8f78ba3b5462,1e0800af34b2012970fed05325c5dce44cfd3acde4653fb678210bcf66d9b9a2,ae5385f59b2f85b4a72d14ebda565e5e6c5f3735083f740330be96914c2e1000,b25d074ff7ee20f40b5de0739ef82878a038bee4ec151935fd55b23ad63d8ee0,82f13a75b80d37c55e414e5262a62ed9b24ab6876f9ba5d79fcc4ff7f2d5bbe9,285fc0007e8e696963092163c6260cb723b702298d041227f2c501a403b34a46,10fee85117849c83d7b06f67128add928ee3609992841ef20e4a1d6fc444913b,6a7e402c44b6b70b1c51a67fe2a37a2887fa91347a7a78c900f2dfcf1204d79c,e65cc25ffd4b95953e7451d756aa8b632376a520b8a3ba483bdd29d72b2e63ae,764208c058866181f2110c1962ef71cf06e3f08516b6b1cd91be4595f8442b3d,7954ddd866aa130435cf58e19e15f1a7b299006b20178bbefd378a267eadb945,f9847c609e6506a8049a95485572d0103e552924e027b76a7898909e5be97c00,6293ccfe14ac1c48a1f04c0f83c3a38831da09637b650323d475e53504d4240f,1cc9a284b90baedeb7104ec0a87d9a2f201cf8daee48619019a9b424bd968a05,2ff16ff6b62e0f7b532dbc67f9d713f121f1e5fde6306d94018e63291a9e2bc5,af03c3111061ea13a4dcdc188990c076955fb9061b49256cbbc6aa5476564ef0,06decdb45ffd9874791c5bd0dba4768e41a68314f64380b73cb95cb72a861709,7cfcc3f09a74b39d95bfd06e27afb57723577c54709f9c680caf0fd4ca46e70c,0d8540e571874f543ed6690fb2c80fdbcba9ac0452224d653fe3157f39cdb52c,8ee3ba3e626db7e12efe9ac645325563c3c150a6816f13251eecd9d680813821,edd371c70dae3f92847da89aa9c48a660e469c4f230ba596f1a6f416ecf265ae,3cd6cae07b45caa5d40414a2a384af5b7b7ad2a548f6282ea6476f09b3ac42dc,4e8c43df2928731db63b38c29a35c4308dec3f8c302675d124879467631738cc,b5dee6309643c62d8f0512f8f5dcd54e39d187e7b4764b644786270459bcec09,b35a081b5e10b6439c10b43e08fd387de725a0c17d3209239e45db065a703377,6fc35214c9aa12ccac5909112ed5a6f04fc83e45d662735d801676e047d6992b,fffb510a6b58697c80440fa832041f1e814710ddeb801b83fab0d04f21e1c923,18e76bcd3be42e9d37bd85b128947d9eea9354d4ca9e3c3d03cfc1464ddd00d5,0292c4a9bdbb99f0b0393d749d3e097393d0468460c16bd13ad9bd827caeb76e,d3cce781ec7daadc83d019612ea9e01ed0452bd19257e7d0e8fd1daca49bd918,08b7cf18e8a730064a10f05c5109945e74c6dddcc5d787b29ff42f61ffcff50f,26aa49fd09b23eea583cb5a10e301bd0140f7826c0ba5db38b712caf96922ad8,1d23da646c02606f4b421b9e85e97297573611bdff018bf06369aaae0a0b171d,c91ebf2cf777ace6396eb56d0d3b05f2ecec04267a7b83b4c059a0c631c7424c,87d8f2e96f5f99c99ebe360b9007b2d9894adb58aa9816a0ecd0b14e42db474c,e0ea9bc8b92c474648a8ef66029986b4154e189f48e7308b041ca62ae0a55185,5f448b6411b9ca87a7ccc4e7feb3b2e3517f1c9591331d42be15bdde71e850f9,f793d08b971cbf4bbad1a2ccf5c413cfa5fe7d5ecd981b2e8aca505bc0433bc5,4e51dac3ad49ffd509c2af746cc7c528b5d5a4b3417eb609e282435445016fe1,8d5741b1dbb81896d1abea234175ddb4ccd8fed3c7638b9aee9ed893b26b1d18,45c6fd3cc7c6b84d0c4e65381f74725ff663feafe4018d0715be9df66d6aba32,dc974a23899424e82dec2575a758aef57061c2096801c4cfe3f9a2482ccfbc84,05a2b0308228a73025ebec12366aaa30a0338f73a13fe632e5cbf0d39c55f9e5,6678ff46ec82c6f76d768cda9941464861066f1c9a7a64f662448331d2e1d668,4d392f0c04664dffef75b1cb0b1797b4659b3b74b3f2c8b7a8ee54402c027b16,16b96a6f8941af061b072f6c07111dc3b8d8e54834665e45e46b8c5a2879b258,66bfdcc9d8773841c6f85e8f94a8bc477e4ffd1418c68a3559c1586be5b5aba0,ad14aec7130c94ee57e1454dd9c66997eb193f5b813cd5c1f99166c5b9760378,02d0fed9e5df3ff93c70c05af1805c9bad6e86e156cf84d301c68fce240815a6,a3cfc5692786792b770ca1f25bc9bd660f7be19fe08b2e0a4deba10312eb7e8b,a910411d76a042d709498082e853be7f1aa5a1eb4340a12471acbcfce2af7deb,bd4b60551c89ce1c88357d7acbee8e41e27c230e03d7a0a4b3137a8a0c6d9277,403cdd56ed0b5433dec32b69589cf4d9fb9aa69bb73f5b6d4fce429bab472808,c5f464efa10164610c54d45c0348393bfa16189a8f2b26f8b816e08cea9e9918,6dc90d8910d6d3ddb586d146b7ed26307467ef82a0411cd355d787622605d951,4fbdfaa53f7b252534fc8fe8efbc6e8673fdf3675399cd999113591938435623,4cb30cd36be926564d1d989bfefb56ef7351eebdba88e86b5837c629f93afd8e,31b8457be04bfaba4c62009d6b9444dc17d03501bebfcdec2fcfbc4e1c7d66f1,bcf7bfec1282e4c191e95f6b6c2a78d9498fac8097f6f95a76755d3c5c8ee761,af09fa6fde195d5bc064a02d441cae584f6540582c016eb1344a467da4943063,6f8cc80e557f8ddc9811bd40777bc3933b8424ac51174104042e17b07df7ebbc,c608e6b05d0dfcccd27cb18a0a94c538a8ad9bd04e62be4d62b3687832427bda,cb991550e76f57c6a042e58753ae099849c7280c3afc7a066a55f5d56ab86bdf,2f469999baa8fa3aafd15c83d7fba9e1ba74cb7d7699f4e8863f35d4655f817c,a96690c41fab9e33098e0213e5306a043ffee8594a41c2518865652c6331de95,c5389d8e7e000bbf0647b8e76d28cd66d623e9000ce403b574503dabf0d0899b,634e6dcaacf6b199c4a4fc0fb241e55b85399acb584d037dfa4eee9d9c780660,217d539b1879154de3759f2cc8da5631a4799c9f6a5839c6c6123fa6600501dd,0452e117170ed2e266eae2b5e2123299ed771653ed62d45a782f952f1c72cf22,22f929a74ba1bee07c2ab90961de49c5261b20eb98e74de170382057916517de,979e7d45bd96715d1f0d0912859a92269dd4d49ead06412f998c91c84c270794,27557a937612d0af05cf4ae5266689c708bcc2bb2f68e9dd9516bacc6e915977,5e2dbf144424667db5d0f6985f1b30e06c05aee0d8ede2cc0481b5e83f891dee,17ab4f4333c80a93b8063be36a5bfaa8017be38932b2c2538fe180ae11b99dca,8c51dc70f18fa20d4c8edf0a36c65c7a9c1a54d11dabb8493757418ab388d376,f4ff745365aac13242a43d7e859780be210ce09d942970d91924553548641ec4,9be6ddd007b0b74bc7282b91a84da7a2b3652fa4c052f76d337318dd720d4022,6874525da854ba6193803de8d19b87084649647ca1132e24c3b16773891eeef6,6003842c4bd6d6bc150bf807ebe553fd5cd62fe48eb825d0aac55d24bce421e9,be67d0dfe0720158969c8d7a015732b1dc97860d7b62e095becbe1566e495ec9,c577430bee6b75ad83c3f1349a3ccff4c0e34274943706d44c6d91cb0cf631d1,4168be5fe4ef915fd0b2522f65c576d36cd2d9665b3e735c570a4316c9bfc6d9,08c21b21307a7fb2caabb31503ff62d036d07055a74d35db034b0f58e39dcd81,d9221b998e5d5bd947c7fe0cf066448e0bf8aecbc4f368230d038eed68d8e335,03eb738e6578b75fd8d95a56856b2b8cf86f600cb3469c4c3d4cc5722eda4273,d932984af979a61244f05a77887349bbc19178b43660abbd944be26952e99b95,c37a5fb02e270dac16a81a3f51329d2f3bfd1e1a4db5ab012a8a41a8fbfce7ff,93c6fab1a255417c57e17e4bc5f9bc88fa8044dfbdde7106c06d863e982981cc,c84a83e242b094f0f855c23f6aa7f2d284cf389b55b9eb9f5ef5c81e677423c0,85fd33319c1706db71ff3bc812e736567e09c21df700794cd5f09f09ddab2738,e660737ab0437c7aabec33c2c764de18428eb4a6ec7a34a8de8f82a05f310f07,0c3d13b872d6a5e4d55bb1227555babf99ecca7bb6434a64ae193b83349182a6,bb5872e357eb469aea7c6d4ecf95b534053e89362fd4f6fbce6988151e28fcf2,68de6d1daead6d948454c846c6650ddf0252c03e3271df25fdb1ceb573448d89,e52a74afd95c1a414086d1a2bd25aaa8e811f13323eb94a531e1057831bfd09e,7f4048ba4cf08f811692cd87e1abf67760fcae37240718a2ea6c374e74e2824a,a0a175806e21f5ded6ae2540f31b0a28df35b8707cae0c95cfef4bebd8bdd3c0,b7fce848e58269b75b3916cb3624deb51c6134e92bbc2f3abab680a1af2d70f3,ad85aea92ce78845775893c435aea4c0469114fc9823677f7c82bea8871af503,33e19a57f142b6aa1750de47fea04bdaa3462ad983ef7ce3cd1ccb3794a09b6a,0d41b543adcb0b867fb83aec3360808c79713782405fe6e009e1a3b3901dcb9a,233e43ba12c782063f0fd6683d004939a67639301f4c4d127bef5bd2e06cfbe4,159e33d6134fe44e8bbb566fda0835a2cf105bce0748d33ce59e80b7f19a54a3,b38f9bf6407267832b953a2573ec12aaa7c57988133becc8acb4ee0cbfc96eb1,da8aea9246af5f41561c2ea113ff1908378e610c15fc4503a6d8787731a9d183,bb622dc00a996ea44984502dafc0ab9b5135406b693f79f8eca149e0ae7559dd,22274ab0919d92dad8662bcc67536178d4e89dabf22237132c20f1c9848f2479,a3986656fd9306355f8e28d03102fd70942f5fcfc1c497b34fd6957ebc8425bd,4bec0ec292d341736f0bd7e822ef23fbd0df440c660c4b63cc0c8a3a5d555c50,97a66bb00817412875e140b02bbbe9339a713be7ac3b2c5432b35035aca64332,c881f7ce6972e286f15ef8c3e5e5cf146cbd78c788f4090310e5c7065c2f00c6,8d60256be9b1c870161572b26f09a13ebfff2a6d48e1e98d804ada6dde1f9d9f,9c056a249653ff41e4b66938a3163e79552971683c61bbf5a26b1bc5ef63dad1,025dfa3b1f37ec56ed5f96da6cb31c9d5f10e09b4d78bcd269b545418fc81ff7,9ffd664a7614f3a27b511ea31052247aaec32a87ba4f50df383d31c88fbfd142,b7c59afd3a24d160e3f1563e8538bbe864aa0e36e25b0c316a4c7935bf9b7ff7,bf893413f7156d3d249d6a11e329262745c5c7de11ad5e64aaf50a3329da2dee,4e965c117eed09d38a3c3c7ef15dd434afe87e555f68b776ce31d2ed697d6e97,4f790d1ebba91657e6a8f579c8d4d8dd13abf9c4235c54f4b664657174567428,c86c6f3c3ca44b09ea38f5e430861abb60699126fe8a7670abdbdaa7a7c4d28d,2f9714116d42be7965431b0b1db592296a189900b33d5a48de956796732563ab,78e88774c5fee28584725869d927743efda53714de4142febba0fca848facaac,a5e072f618c2cfeb3400fe2d663923de939132ec2039f696eebe1f2bb8c3400f,0c3a6f551c270be6a4d726d8c443e53f5ce400b9b145bb2bb8fc5595ddf5a1d1,ff4262abf9a6a01a9bc123f6872dd5403326bd68760add1963e9786bc0a4b943,2e15582978b5a54a21d79915d5764b0194dbe9cc0b9c41d8d1a38cc6c91bb73a,068c669fe80f9b80a1ec8fafb49e49b0f4bd8349d1355f12b4f6d38f89f3aa88,6e13bf626a34c8c45ad640f12af4361d1421c905554c10e048cfa1b6e4d607bb,457ba16570d16429dea6df65636f5a5fd7d7aed4d54e071b59cfc74dcb1c4d69,41e28d3bfcf2c7b2c2c7fa301b33896383086c9cbb5271f1654f7bf4262a7495,1ac469d118b2b4e702b9f70ee913765c1cef4117ed3469e9e9729fb74126e747,591b1f862a813f2a87e810a7c002187107eedb3ab56452d0769b40d483e62c29,1cc84d0675df08a4601e540d0e238cbf693424cb7bc5c8c0d45f3d2001f903c7,4345a226eb3ce36c085d25915c807a08d57afe7bbfc40f36bd29e6aa5cb44e13,adcc8374782228267f063632870d0700035273e0b38f30a38de71d4c56add8c9,65cbc02373f173e108561d1dda6eb68ffcd677e8f5ff97a6a45eb41130abedf2,1f1ba345643fa62beae6990e02d83b9380ceeda0de5af4c7bdbd44a7cd1069d4,894fb12ac78e8a38b3bde0e9087d64fff0a3a968cc2e7e6cc21cc8b2dfa68c81,107cace5fab38fb538d647833d08b3991296d1ca2cc8c40b7822908a81656482,d447c1957da458c2755e6f3f36c73d7973f351a1f8b4a70e606fd3f70868b492,b079ec24a1275a58fe11a3f52e0e6641c224cd73a983f7a2b35bbc45aad7e3f8,bf6a48b6e5e380c442c99d4d029819728d7aad4421bb4034d4c20088680cf96b,6325615c7eb7f855f1c4c68e774b6a445d3611f9fdf92ea3e5858e8365b16e16,6bd830fa7364a688b261f3ce6c426823360d64ddbf5ce88751ffb9bbadb9af2e,f5fb67ed0499e10edf588941f08602b700ad6e036f0f31e2d2ffac2920ce8a87,2dc4d0cf09e7b572aa0545093b6d061ed53c62ee06d2db7c4fa088e671bc4018,1a4c54152a4e1aac2c520e606e0a9fe912720a639d74f11a89eeeafd0fba95e6,667ee6aca3ca8cb7aceca2d6d3607b8a8597b6b0774dc5a1489725adbe38ec6f,5c36c50edb7987d80994de9dd4ef2a6056354434f2586776f7de8d52f4755396,f1c059f76938b5140b68298d68e3db6eed15e830242dcabb9421f05c16546a94,6ec0790b57cd3695925690ac82433ac15dbf33380d1da114e3ad45d58d01a4b5,6d103ea3da7cd60dce5a8cdc8f1fe79b86ee7df4bf66c164dacc12da0aebd3d4,c34e4dea38d35273f3b6a3690b446f880626435799ab6ac9a660b4a7e595915c,369a82987ceb42c5c9b3c0caf38b366cf69da8333ea55956969d04a7e9e9904d,63e4634ed1809413217a237a5ad656a9a6b7296a38471899aeab342deefbb68f,a75ba6a4a3f76ae20392e7fe09b8f2a874e2bd3e56aa67bfa279121ced9ecfad,acde694442c4fe41321ee5301a08c6590a4ba872aa3885e58581b6bf65a3bb48,9f9923b564727955a92f132a1735ba2586888c7b55ade9f9633e31f212a74772,6286577bb1847615deb74ac019d719c9582467479f143ae34634c146aedce482,973cac21cf99e397e94a3f557067835c975f7502edad5fcf872fbaedc028675b,ecd109235ef1d9cdac44d37fd610575c4f44c23690976c0618d919bce2679273,21b079cb7b33b8de21005e14cc90c9e87b11404dc5948c73601c4eed94971abd,6de6115d2a98203f5732dde5f0fed6dc338659de7d8c2d64e647c7d124fe9ab4,07341b920ed90c2d333a4f748a1334427f312f5722cde011271d310a1feb2d88,844bd6ccf8e65f19196d20cdbb57d0e84af58ef07f87c9cd39f4174b274bf3cf,c5b1b90de3f1d15a924635d30667cd8090e9f2fe690da95fa7fe620deba3bb88,a3da9f460b7b8c9e164d1c8ace8d98e2b3e03960a67ead1138dec98e1f05f908,b126d4703188126bd1813b963df7d70e59b05102e6df26a8ca070e69e69f23b9,531d61db848ba0648e56a2b096567c4d412b3fe850df5f368b03b28d197bd777,4b6095ff6bf32cfd3d2d2e005df709d1f794a4bffbe6f2bc2a65cc28fa2a0179,244923ab456167a14c1b52625f39bd0921c97a391620be75b3e497b00deb61b7,302ca756a2fdb72707e08da0ae2791cd4f077df8b580ab4fe4025f779ae6444f,e9f11997c59052de54194ba2e40c916f2527954059fbd4a26b68131b640f567c,6cf1fa9b84538b7cf1120a41d9c087e4fabbbb25ff44e7ccb2e528e8101de7e5,561c8a3ca5db0fd56d749bce9694be954a933257c049d2bab1d8a4c9a9de4f09,5160165c95022281eec409c020871c403670ac37eba26444efd79363cd2cc7fe,f8ac13e44c7d2812115539b1cb49e4c204084103d403947026555434ef792534,0c36b89056665766db483a9e9d9c9951db6330ae16229b82e3af8fca5a7cc24d,f64acc2684451da1d4bda5067983ebd9f1cdc552484ecf4b9c1841f12e7f6066,ba2662d0fbf352684fb87d0547d892c37be376469e64668286875edc582d57de,ad3b9035b9f571a3c567fa655bbd22b632e6347f1245b2341c36e4e057ca5969,2c2c2975fd385b0f09adeeec656076fc64c2ce14fa2468e020809ea9c11fe7e7,36d06947b1ad3dd42c8b8f86ac7dc79883082937bf32a12ea0de100e8e69ff17,f38c74021f49f798cd101733b1431daed3799e858b7250bf3c350db448694632,06b3d688faa75f7e7b22fe62580f53b1624d7dafb52e87616fecfff925ba10bc,3b8535350d6f7ed096e8ee01188ced2fef19725ae3202c8448a76ce1259921c0,1329138efd952ad66f1e87833f947b9f8dc94e41bc55e43b5c0ad096a282a048,6a7de61162489796ee8a403a19c8ed74b45042e8d3a860bd85e112975627c3ef,934168218ce0eefb1c7a91b863a72040287546af4d69578094bf4c425a52a8bf,9d03bc62dfaca68a227f97fbf41cbcf20fd661d5140dcbcfb271c025780a47fc,82bceccb6ff00f044b9fe268ae79b553870d7b752ece7b919fe42c2a0977a7a7,1ce1020cf0f74d2cf0ee513dfb2df3cb8c3f4cdb867d2bb3a006823a47cf8b67,ccfb1c4e35a39ae396babad554c60b633fd5b38dbbdaed5f23f3613b060bba08,c26ad547940b812b453187e26bf48c4c3aa6c84f0f807fed1349111f9a4fa1da,99c5d177560ad11dc97b8c5f63bc699556602425e71b6e385fd0d710e58027ca,949c8a7ea7795c4ee63d7fed17ecaf4a3be01454790e9c77a54123c8c66bca2b,d5b1bce1ffd0cf9bd8442c1c133fbb6be1dbda7e35db4ca2b405f34bb083516d,4dca7fdc6bc9df66e46714cba669b140db17c1e96984f4ab9e9567860b02c71e,84e85a8d50372895f35f16114cbe1b92bac598660c29348fe4eac1b40f625cf1,4f2e3b6f679ebdd7b0e78780192e6c995ded22b77bfa51943a1e637a2fdde5ce,fb3854ae311335a6f902b87a9c09e907e6b80488d5cba80108a51d9940cdbe16,38e439200ba776c36ef12dc861a25b4ded4982db6ea1fdbfd81de55778837e64,63cbf7901d76600761a8d1b837338bf80c6d5625d66dc5a14c110b2e5c4345e1,3a75ae42b86cf0ccf642e4b3d2204d80175290fe420d5b0f8daa68c9d99b61ac,3f7aeb806037fd4067c3f689c7d5c629501b653b158f6d51af3c9c40238a4bca,4ef30e90c4a95f22cea063873630f1e34585b6a34a837ead5f468c4cf8296fdf,0fd8e43ed2bfd0f7ca55f39f7a7768aaaa4d53549b6a402f9478abf41427488d,1ac719801328f5c356dff21d09dd672a2e0a6de1d296af6f10faa0aff47af0c9,9b1145abdf48a64da7d7d30f1a4805606215efe9d94a63e9a6bda20e55d7caa8,b83608918b87bb48f85aebff40761ca3fedd8a400e6e76d3e17e2798fe2bf1ae,c83d3f1d5358a6e217b121fac03952247cb8685b009b60e5e7042e84b556b122,6392c6c7163b86b8f41c570aa18e8f8ca3398b79fe56a8021357969f291f16ea,1a8666113c79401835328f48c976c18af019648ba7a9a7f26a88b4985c15c4a3,acc4552255e5aab2ce096d8307de555bfbdea4ff74a54dd43852ab51c06b0669,e2b9ee870002dc29f54f7612428f4bb5f183fa0707841fa1dd180de0a6352dce,9313f8f1121e9f0f37eb6f4fa8ac16f15882c235fefe32650b243d6879ba3288,06c0d8f1a2d0fecfba3a722b1778eb5cd877f4b1be80293e73dbc528e1846d13,6bb6ffbb8c4e4a2ea343df6d18ece066c69dc7f1ccd85c8ead50d6b1876bb6e8,0620074f47242ce2c00f73354db04d46df0e36b53d25c2109d4242ad49a090fe,9a6c36505076caef2411ef84786cfb57a718aeb3f5c6604d771b6c8565e0aa67,e5ce23ac2355062de3e2c2f268d6cb5f97a6ce49796f87a37ef966e166807c36,8b95ff9b9370c2ef3746d81e0e289a62fc688f93a522e6dca6fb1407d66af8ec,17d802aa123638ce5224ec403ddff412bff16f95af428a0a4346a347ec966de3,ff566d91883d65e03a24d6538cf99f3ba7697e9adabbb93101a8641928bf9689,25261d06cc7009f1642b2e9d25e378970a2b0d2e46207a724b9ba208188e571e,74e6c706eba02e9ac1c6f6f82f283b95f772bfba14fb69d67d62bdd7802d803c,0d175a1dcef38174cd5cf491ab9c94186ee81e9f56c9b212d412f63449ba3e39,cebda10680b66bfc1ead49e68eae14a51bc22e5855da65f85e39538ace7401ae,36fa14b3842a642189e118e91ac4d0f4ed0010638bfc28d850a0a7e52e6affef,bc64363749c608db4d521088cf5e444ca975141afaa33523a5a510c36d0f4e32,5c859172de3f2e084cc7e1067317227ca6393f4b4bc0d7059bf3383e490a7ba7,";

std::string msProdSeedContracts400000 = "468122,468147,468154,468169,468169,468169,468170,468170,468170,468172,468172,468172,468174,468174,468174,468174,468174,468176,468191,468202,468218,468227,468229,468236,468239,468241,468281,468301,468305,468334,468334,468336,468336,468340,468341,468347,468351,468367,468377,468397,468405,468437,468448,468495,468550,468555,468716,468742,468742,468824,468843,468968,469011,469020,469023,469090,469092,469092,469097,469099,469103,469174,469321,469348,469362,469366,469371,469399,469618,469646,469664,469761,469770,469770,469771,469805,469882,469923,469987,470024,470063,470072,470096,470104,470129,470299,470337,470387,470425,470432,470512,470597,470631,470635,470672,470676,470676,470676,470676,470678,470678,470678,470705,470707,470707,470832,470916,470921,470955,470960,470985,470987,471019,471033,471055,471260,471320,471344,471344,471448,471528,471552,471597,471616,471631,471646,471725,471740,471750,471785,471785,471812,471834,471860,471869,471878,471882,471895,472157,472177,472261,472263,472293,472305,472316,472394,472394,472397,472445,472503,472503,472503,472503,472503,472525,472549,472608,472643,472670,472671,472671,472678,472740,472744,472777,472782,472798,472838,472862,472870,472873,472921,472945,472947,472976,472981,472988,473005,473024,473138,473256,473314,473319,473369,473410,473519,473529,473544,473567,473594,473694,473699,473745,473765,473770,473772,473772,473784,473797,473798,473871,473931,474075,474162,474209,474217,474223,474233,474326,474351,474362,474401,474444,474454,474465,474469,474477,474482,474484,474485,474494,474506,474508,474519,474524,474552,474576,474600,474617,474617,474617,474617,474617,474617,474618,474618,474618,474618,474618,474618,474618,474618,474618,474619,474624,474625,474628,474644,474648,474668,474721,474766,474844,474853,474855,474866,474872,474884,474919,474938,475018,475065,475109,475209,475219,475233,475262,475272,475288,475301,475321,475381,475390,475438,475493,475507,475525,475526,475526,475527,475527,475528,475531,475549,475549,475555,475572,475579,475584,475593,475594,475614,475622,475633,475701,475729,475747,475763,475801,475818,475874,475908,475917,475925,475925,475925,475925,475949,475950,475951,475962,475975,475996,475997,476002,476071,476203,476237,476275,476299,476317,476366,476402,476403,476406,476455,476550,476700,476731,476807,476837,476919,476997,477012,477020,477065,477167,477167,477182,477201,477214,477248,477252,477257,477258,477275,477286,477286,477287,477287,477323,477341,477395,477397,477476,477481,477548,477681,477701,477860,477895,477901,477905,477935,477938,478013,478107,478135,478191,478206,478207,478271,478276,478291,478295,478338,478365,478372,478378,478383,478584,478615,478655,478664,478758,478856,478869,478871,478893,478895,478911,478948,478964,478972,478974,478979,478994,479033,479035,479044,479087,479113,479121,479122,479142,479142,479143,479201,479241,479263,479312,479482,479518,479672,479672,479744,479805,479825,479828,479846,479858,479862,479871,479910,479953,480001,480007,480086,480098,480173,480195,480237,480278,480288,480291,480312,480403,480403,480441,480479,480574,480626,480669,480679,480712,480713,480721,480723,480755,480756,480790,480794,480802,480814,480872,480882,480893,480933,480939,480945,481053,481065,481072,481078,481083,481085,481094,481115,481148,481158,481212,481213,481251,481339,481451,481452,481461,481511,481570,481590,481607,481608,481640,481641,481783,481788,481790,481799,481811,481864,481892,481895,481925,481957,481971,482060,482407,482445,482492,482495,482501,482542,482582,482587,482590,482612,482661,482700,482742,482771,482803,482805,482806,482806,482806,482806,482807,482807,482807,482807,482807,482808,482809,482809,482809,482809,482809,482810,482810,482810,482812,482812,482812,482883,483005,483120,483120,483141,483202,483251,483264,483277,483334,483351,483389,483498,483501,483569,483589,483592,483598,483599,483639,483647,483648,483705,483705,483722,483740,483822,483823,483827,484108,484108,484125,484192,484193,484214,484214,484222,484234,484429,484450,484456,484476,484517,484527,484558,484575,484576,484609,484687,484702,484917,484978,485048,485075,485087,485198,485209,485220,485317,485328,485335,485335,485336,485348,485363,485453,485474,485480,485480,485480,485497,485509,485579,485598,485603,485726,485838,485886,485888,485976,486005,486007,486011,486011,486025,486064,486100,486134,486134,486145,486148,486162,486167,486204,486218,486223,486230,486234,486234,486234,486235,486242,486271,486280,486294,486337,486348,486381,486462,486606,486705,486756,486799,486850,486922,486923,486952,486952,486957,487024,487098,487162,487169,487183,487196,487226,487231,487241,487278,487314,487345,487384,487400,487408,487475,487494,487494,487504,487578,487631,487673,487694,487716,487717,487729,487737,487768,487793,487843,487894,487950,487965,487980,488011,488012,488013,488014,488014,488014,488014,488014,488014,488014,488015,488016,488016,488016,488016,488016,488016,488016,488016,488016,488019,488021,488038,488054,488056,488081,488121,488218,488240,488240,488467,488618,488632,488636,488656,488661,488745,488772,488828,488852,488852,488852,488852,488852,488852,489011,489023,489023,489036,489062,489095,489121,489121,489126,489150,489198,489252,489263,489284,489292,489300,489317,489341,489348,489436,489437,489449,489464,489510,489619,489643,489653,489655,489656,489680,489723,489733,489739,489764,489826,489830,489830,489869,489892,489942,489945,489960,489977,489986,489992,490009,490016,490016,490034,490047,490056,490058,490082,490091,490112,490123,490132,490157,490216,490239,490260,490375,490407,490538,490547,490547,490553,490564,490567,490625,490712,490733,490743,490783,490784,490862,490862,490864,490868,490880,490910,490932,490933,490994,491044,491044,491044,491044,491046,491047,491047,491047,491047,491047,491047,491047,491070,491074,491092,491116,491125,491140,491161,491161,491211,491213,491214,491246,491403,491405,491407,491492,491522,491553,491737,491742,491755,491755,491779,491798,491811,491841,491862,491868,491881,492052,492099,492121,492157,492200,492233,492279,492314,492362,492430,492503,492554,492567,492611,492615,492682,492779,492818,492818,492901,492939,492974,493017,493042,493079,493084,493085,493105,493119,493206,493226,493241,493246,493256,493261,493270,493288,493300,493359,493362,493382,493415,493442,493459,493462,493599,493599,493602,493609,493617,493617,493652,493679,493684,493709,493718,493770,493834,493869,493877,493903,493914,493939,494047,494220,494291,494318,494342,494387,494399,494477,494579,494603,494680,494761,494784,494787,494801,494815,494859,495011,495127,495194,495235,495262,495266,495274,495274,495274,495275,495276,495276,495276,495276,495277,495277,495278,495279,495280,495280,495280,495280,495281,495281,495341,495360,495384,495468,495474,495483,495501,495529,495529,495595,495613,495669,495684,495707,495712,495720,495862,495880,495892,495941,496173,496207,496209,496222,496238,496254,496254,496299,496310,496327,496331,496338,496404,496406,496407,496434,496490,496500,496500,496500,496500,496507,496511,496555,496560,496568,496579,496584,496600,496601,496606,496643,496673,496675,496744,496818,496835,496857,496900,496950,497040,497044,497107,497109,497180,497197,497283,497301,497303,497331,497343,497344,497368,497392,497393,497394,497397,497403,497405,497405,497413,497424,497448,497448,497467,497482,497486,497686,497818,497830,497850,497879,497903,497926,497963,498066,498066,498066,498067,498067,498078,498082,498088,498094,498101,498107,498142,498163,498166,498246,498363,498371,498385,498419,498447,498472,498494,498515,498620,498720,498753,498890,498960,498994,499035,499065,499161,499211,499211,499211,499213,499213,499236,499303,499315,499429,499444,499457,499492,499534,499534,499537,499540,499547,499551,499567,499607,499611,499615,499619,499620,499621,499623,499627,499633,499633,499633,499634,499634,499634,499635,499638,499638,499638,499638,499638,499639,499639,499639,499639,499641,499644,499648,499651,499657,499661,499665,499666,499668,499668,499670,499671,499671,499671,499674,499678,499684,499687,499690,499690,499691,499692,499692,499692,499692,499693,499693,499693,499695,499695,499695,499695,499695,499695,499695,499695,499699,499700,499700,499700,499700,499700,499701,499701,499701,499706,499706,499706,499726,499726,499728,499728,499730,499730,499730,499730,499730,499730,499730,499731,499733,499733,499733,499733,499733,499733,499733,499733,499733,499734,499734,499737,499742,499743,499746,499751,499751,499751,499751,499752,499753,499753,499754,499754,499754,499754,499755,499758,499758,499758,499758,499758,499759,499760,499761,499765,499777,499777,499777,499777,499777,499777,499777,499778,499778,499778,499778,499778,499778,499778,499778,499778,499779,499781,499781,499782,499783,499788,499791,499792,499801,499801,499807,499812,499818,499831,499833,499853,499858,499864,499866,499871,499874,499883,499892,499909,499909,499909,499909,499909,499909,499909,499909,499909,499909,499909,499909,499909,499909,499909,499909,499910,499910,499910,499910,499910,499911,499911,499911,499911,499911,499911,499911,499911,499919,499934,499935,499935,499935,499935,499935,499935,499935,499935,499966,499967,499968,499972,499978,499978,499981,499981,499991,499998";std::string msProdSeedContracts500000 = "500002,500004,500009,500015,500016,500017,500017,500017,500017,500017,500017,500018,500018,500018,500018,500018,500018,500018,500018,500018,500018,500018,500019,500020,500022,500022,500022,500023,500025,500025,500025,500026,500028,500028,500028,500028,500028,500029,500029,500029,500029,500035,500041,500042,500043,500049,500051,500064,500066,500066,500071,500071,500071,500071,500080,500084,500084,500085,500091,500094,500096,500101,500104,500107,500117,500119,500120,500124,500124,500125,500128,500146,500148,500151,500152,500152,500153,500156,500156,500166,500166,500167,500171,500183,500185,500190,500190,500192,500196,500198,500201,500201,500201,500201,500206,500219,500230,500231,500232,500237,500239,500240,500241,500248,500251,500253,500254,500257,500264,500264,500301,500301,500302,500302,500303,500303,500304,500304,500304,500304,500304,500304,500304,500304,500305,500305,500305,500305,500305,500306,500306,500306,500306,500306,500306,500306,500306,500306,500306,500307,500308,500308,500310,500310,500310,500310,500310,500310,500311,500312,500312,500312,500313,500314,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500317,500318,500321,500321,500321,500322,500381,500388,500388,500388,500391,500400,500424,500425,500436,500437,500474,500497,500570,500624,500656,500661,500672,500684,500684,500686,500686,500686,500688,500688,500688,500688,500688,500690,500690,500692,500692,500692,500694,500695,500695,500695,500695,500695,500695,500695,500695,500695,500695,500695,500695,500695,500696,500696,500696,500696,500696,500697,500698,500698,500699,500699,500699,500699,500699,500703,500722,500744,500757,500761,500773,500785,500797,500804,500817,500820,500823,500848,500881,500883,500902,500912,500914,500916,500920,500921,500922,500922,500922,500922,500922,500922,500922,500922,500922,500922,500922,500922,500922,500922,500922,500922,500922,500939,500945,500949,500956,500968,500969,500974,500981,500982,500997,501013,501033,501041,501041,501045,501045,501049,501049,501061,501064,501077,501084,501093,501104,501108,501108,501108,501109,501109,501109,501109,501109,501109,501109,501109,501109,501109,501109,501116,501116,501120,501121,501130,501132,501148,501150,501155,501162,501162,501188,501192,501200,501208,501208,501209,501210,501211,501218,501224,501228,501234,501237,501242,501249,501254,501254,501267,501268,501273,501274,501278,501279,501283,501283,501300,501315,501359,501366,501366,501368,501397,501408,501408,501408,501408,501413,501414,501437,501438,501441,501449,501479,501489,501489,501498,501498,501503,501506,501532,501537,501548,501615,501618,501619,501619,501619,501619,501619,501619,501619,501619,501619,501619,501619,501619,501619,501619,501619,501621,501623,501623,501623,501623,501624,501625,501625,501625,501625,501625,501626,501626,501627,501627,501627,501627,501627,501627,501628,501628,501633,501646,501647,501661,501708,501716,501730,501742,501742,501750,501757,501761,501764,501775,501778,501780,501787,501788,501812,501820,501820,501822,501828,501830,501834,501841,501848,501852,501855,501864,501865,501882,501905,501905,501908,501910,501911,501950,501955,501957,501957,501961,501961,501963,501966,501973,501983,501984,501993,502000,502009,502058,502058,502065,502069,502090,502090,502103,502105,502107,502134,502152,502152,502154,502174,502174,502175,502176,502181,502183,502193,502235,502294,502323,502325,502326,502347,502354,502357,502357,502357,502385,502394,502401,502425,502425,502439,502439,502469,502488,502508,502524,502530,502533,502545,502561,502580,502585,502595,502612,502620,502632,502657,502681,502682,502682,502687,502707,502740,502775,502788,502791,502795,502795,502795,502796,502796,502797,502797,502797,502797,502797,502797,502797,502797,502797,502798,502798,502798,502798,502799,502800,502800,502800,502800,502801,502801,502801,502801,502802,502804,502804,502804,502804,502805,502806,502806,502807,502807,502809,502811,502811,502812,502812,502812,502812,502813,502814,502814,502816,502818,502823,502841,502848,502870,502875,502878,502880,502883,502888,502900,502903,502904,502904,502904,502910,502915,502916,502924,502928,502946,502949,502949,502961,502970,502973,502986,502992,502992,502992,502992,502992,502993,502998,502998,503015,503017,503021,503023,503039,503043,503052,503069,503075,503085,503085,503085,503093,503097,503099,503103,503126,503128,503128,503129,503143,503153,503170,503179,503192,503207,503252,503252,503259,503263,503275,503289,503318,503321,503343,503343,503345,503359,503365,503377,503386,503397,503406,503406,503406,503406,503406,503406,503407,503407,503408,503411,503425,503437,503438,503438,503441,503455,503456,503461,503499,503504,503506,503508,503510,503520,503528,503540,503547,503560,503571,503574,503580,503581,503597,503597,503625,503628,503633,503646,503653,503696,503700,503715,503754,503768,503778,503793,503818,503821,503821,503831,503831,503833,503841,503845,503851,503851,503852,503852,503854,503865,503865,503867,503884,503938,503953,503965,503966,503968,503973,503975,503996,503996,503998,504006,504015,504019,504037,504065,504092,504093,504099,504188,504226,504226,504248,504257,504271,504278,504279,504281,504282,504309,504327,504331,504341,504344,504378,504396,504397,504397,504397,504428,504445,504447,504457,504457,504471,504471,504475,504481,504489,504494,504531,504551,504552,504553,504555,504562,504569,504569,504572,504581,504585,504635,504661,504668,504691,504693,504699,504706,504716,504743,504749,504749,504749,504750,504750,504750,504750,504750,504750,504751,504751,504751,504751,504751,504752,504755,504756,504756,504756,504756,504756,504756,504757,504757,504757,504757,504757,504757,504757,504757,504757,504760,504761,504761,504762,504773,504793,504793,504799,504799,504799,504813,504835,504841,504844,504888,504893,504895,504898,504910,504926,504927,504954,504955,504971,504988,505043,505088,505091,505093,505153,505154,505188,505212,505271,505274,505294,505303,505326,505326,505329,505350,505356,505358,505358,505359,505371,505371,505394,505394,505428,505440,505440,505442,505457,505464,505472,505527,505530,505543,505550,505579,505586,505609,505626,505662,505663,505667,505672,505676,505688,505715,505761,505794,505797,505808,505895,505922,505951,506011,506019,506026,506040,506043,506065,506093,506093,506102,506113,506124,506125,506158,506161,506165,506169,506212,506238,506264,506264,506268,506269,506269,506270,506271,506280,506325,506329,506348,506358,506360,506401,506403,506417,506438,506466,506466,506481,506481,506482,506485,506489,506494,506494,506496,506496,506516,506528,506529,506530,506535,506560,506566,506566,506570,506580,506584,506606,506620,506649,506653,506657,506663,506673,506674,506681,506681,506687,506695,506699,506703,506716,506716,506722,506724,506761,506772,506774,506820,506839,506855,506880,506919,506923,506927,506946,506952,506965,507041,507064,507122,507130,507144,507177,507197,507213,507238,507268,507292,507292,507304,507343,507352,507379,507393,507433,507433,507444,507445,507450,507463,507509,507518,507525,507528,507540,507551,507554,507565,507568,507568,507609,507621,507645,507681,507700,507713,507721,507725,507823,507852,507853,507890,507894,507938,507944,507985,507985,507993,508006,508006,508011,508012,508017,508018,508018,508019,508019,508019,508019,508019,508019,508019,508019,508019,508019,508019,508019,508019,508019,508019,508019,508019,508019,508020,508020,508020,508020,508021,508021,508021,508021,508024,508024,508024,508024,508024,508024,508024,508024,508024,508024,508025,508025,508025,508025,508026,508026,508026,508026,508026,508026,508026,508027,508027,508027,508028,508028,508029,508029,508029,508041,508052,508056,508062,508096,508152,508185,508186,508198,508230,508230,508235,508284,508296,508298,508325,508343,508346,508365,508372,508372,508372,508383,508399,508411,508412,508418,508455,508463,508475,508484,508501,508549,508588,508596,508613,508649,508651,508692,508699,508699,508705,508726,508736,508795,508795,508806,508806,508806,508806,508806,508806,508832,508832,508833,508833,508833,508833,508833,508834,508835,508836,508836,508836,508838,508840,508846,508847,508866,508874,508902,508903,508914,508926,508929,508953,508963,508978,508983,508986,509006,509023,509036,509036,509056,509062,509067,509095,509099,509109,509143,509144,509154,509168,509176,509197,509223,509223,509226,509234,509239,509266,509277,509277,509278,509281,509281,509350,509370,509371,509378,509379,509384,509389,509401,509409,509444,509453,509501,509506,509533,509535,509618,509627,509644,509658,509673,509690,509698,509709,509733,509785,509786,509796,509804,509813,509842,509842,509843,509863,509884,509926,510011,510041,510051,510051,510051,510079,510127,510133,510156,510182,510188,510196,510222,510271,510309,510318,510414,510419,510439,510442,510490,510516,510522,510532,510557,510557,510558,510572,510580,510580,510581,510612,510615,510631,510674,510726,510733,510734,510754,510772,510796,510846,510854,510904,510914,510960,510960,510960,510961,510961,510961,510961,510963,510965,510965,510965,510965,510966,510967,510967,510967,510967,510967,510967,510967,510967,510967,510968,510968,510968,510968,510968,510968,510994,510997,511022,511035,511040,511044,511067,511069,511096,511113,511113,511120,511138,511143,511148,511148,511175,511176,511183,511232,511242,511283,511300,511332,511349,511361,511395,511447,511466,511477,511507,511508,511510,511511,511522,511523,511527,511529,511533,511546,511562,511565,511565,511606,511606,511606,511606,511606,511606,511606,511606,511641,511641,511679,511702,511781,511790,511849,511850,511865,511871,511879,511886,511928,511945,511965,511978,511984,511985,511994,512010,512033,512045,512082,512089,512103,512135,512170,512189,512192,512215,512222,512248,512297,512311,512316,512360,512364,512378,512400,512407,512445,512504,512540,512573,512599,512620,512624,512640,512647,512656,512667,512670,512700,512711,512738,512741,512776,512795,512796,512806,512857,512861,512862,512862,512863,512863,512863,512863,512863,512863,512863,512864,512865,512865,512865,512865,512865,512867,512869,512872,512909,512920,512981,512998,513003,513038,513045,513078,513087,513096,513106,513111,513114,513126,513160,513198,513266,513337,513349,513376,513399,513450,513506,513561,513564,513640,513689,513708,513718,513743,513765,513776,513784,513801,513806,513810,513819,513822,513825,513827,513827,513834,513866,513899,513901,513901,513907,513907,513907,513907,513907,513907,513907,513907,513908,513909,513909,513910,513910,513911,513913,513913,513914,513950,513950,513950,513967,514026,514033,514034,514043,514119,514189,514206,514232,514299,514413,514497,514498,514539,514542,514565,514571,514582,514588,514624,514633,514652,514689,514702,514743,514759,514760,514762,514762,514762,514763,514764,514764,514764,514765,514765,514768,514770,514777,514825,514837,514849,514863,514877,514915,514987,515036,515071,515095,515206,515210,515271,515284,515305,515349,515374,515381,515404,515411,515439,515445,515454,515479,515495,515495,515502,515553,515559,515586,515622,515646,515659,515695,515716,515717,515717,515717,515762,515780,515823,515859,515884,515884,515898,515935,516049,516098,516098,516122,516132,516133,516133,516133,516139,516200,516200,516210,516227,516260,516290,516341,516344,516379,516379,516493,516527,516568,516639,516783,516805,516812,516813,516842,516906,516911,516930,516963,516982,516995,516998,516998,516998,516999,517000,517000,517000,517001,517001,517001,517001,517001,517001,517001,517001,517001,517002,517004,517004,517004,517004,517068,517092,517096,517123,517243,517252,517291,517339,517357,517365,517375,517375,517394,517403,517423,517430,517430,517466,517467,517488,517501,517519,517550,517570,517575,517605,517726,517753,517770,517820,517841,518052,518098,518142,518161,518201,518223,518231,518290,518308,518317,518319,518319,518335,518340,518342,518360,518407,518407,518426,518429,518503,518504,518525,518607,518663,518665,518669,518669,518673,518760,518770,518778,518799,518822,518848,518889,518944,518944,518968,519015,519026,519056,519058,519083,519175,519178,519181,519187,519191,519201,519208,519246,519253,519269,519294,519312,519327,519327,519327,519332,519342,519392,519425,519430,519475,519476,519519,519571,519578,519610,519611,519722,519723,519736,519759,519834,519848,519868,519882,519914,519921,519934,519936,519936,519936,519937,519940,519946,519946,519946,519946,519946,519946,519946,519946,519947,519948,519948,519948,519948,519948,519948,519948,519948,519948,519949,519951,519951,519951,519951,520001,520020,520043,520055,520099,520114,520139,520182,520182,520197,520206,520220,520224,520290,520293,520295,520306,520313,520316,520339,520380,520384,520411,520422,520517,520517,520518,520580,520681,520687,520740,520812,520818,520898,520905,520930,520962,520974,520985,521032,521077,521084,521107,521147,521196,521212,521216,521241,521285,521306,521401,521530,521589,521609,521609,521609,521611,521611,521611,521611,521612,521633,521640,521732,521763,521795,521843,521860,521904,521984,522007,522014,522035,522039,522079,522093,522308,522373,522388,522388,522398,522406,522413,522450,522512,522529,522553,522663,522758,522788,522791,522848,522970,522989,522995,523021,523063,523082,523100,523146,523188,523237,523284,523303,523316,523402,523441,523463,523488,523493,523527,523568,523605,523623,523627,523640,523660,523687,523687,523776,523812,523812,523820,523842,523863,523982,523987,523995,524027,524029,524050,524074,524119,524177,524265,524290,524291,524300,524300,524325,524327,524352,524353,524353,524374,524428,524500,524501,524529,524568,524593,524599,524640,524653,524655,524704,524761,524781,524799,524816,524826,524827,524829,524831,524851,524851,524859,524868,524888,524990,525014,525038,525082,525151,525254,525269,525333,525381,525418,525423,525423,525455,525457,525457,525457,525458,525459,525459,525461,525461,525461,525462,525467,525467,525467,525467,525467,525467,525468,525468,525469,525472,525479,525480,525484,525485,525486,525486,525486,525486,525486,525486,525486,525486,525510,525513,525526,525586,525609,525613,525627,525650,525675,525675,525683,525712,525723,525732,525799,525804,525821,525872,525896,525903,525907,525965,525982,525983,526034,526035,526042,526051,526069,526087,526090,526090,526090,526090,526109,526123,526181,526259,526301,526355,526448,526449,526517,526519,526573,526576,526581,526593,526617,526649,526709,526720,526724,526755,526776,526780,526788,526789,526814,526907,526944,526985,527011,527050,527056,527059,527131,527142,527144,527181,527181,527181,527192,527212,527213,527225,527237,527237,527288,527305,527310,527312,527328,527337,527337,527337,527337,527337,527337,527337,527337,527338,527365,527365,527365,527365,527384,527397,527416,527453,527491,527525,527593,527716,527764,527790,527797,527802,527932,527993,528074,528087,528087,528087,528087,528087,528088,528088,528088,528088,528088,528088,528088,528088,528088,528088,528088,528089,528146,528148,528159,528175,528180,528190,528271,528283,528287,528288,528304,528304,528304,528343,528373,528377,528382,528395,528405,528427,528433,528441,528474,528478,528481,528559,528573,528721,528787,528814,528818,528833,528861,528862,528862,528862,528862,528862,528862,528865,528885,528885,528885,528885,528885,528885,528885,528885,528885,528898,529012,529038,529052,529064,529073,529080,529082,529110,529176,529176,529188,529231,529282,529301,529307,529339,529375,529414,529513,529529,529570,529648,529708,529747,529862,529873,529873,529873,529873,529873,529873,529873,529881,529899,529900,529914,529914,529932,529947,529985,529985,529995,530011,530035,530040,530059,530082,530083,530094,530099,530101,530106,530112,530190,530190,530190,530194,530198,530201,530203,530204,530249,530257,530298,530298,530315,530320,530328,530365,530365,530373,530426,530500,530657,530686,530686,530730,530730,530730,530742,530777,530790,530790,530790,530794,530843,530934,530940,530998,531004,531048,531048,531048,531054,531095,531097,531104,531104,531106,531120,531162,531190,531215,531269,531326,531366,531372,531382,531397,531628,531676,531701,531711,531711,531739,531739,531745,531756,531773,531802,531831,531904,531912,531912,531913,531934,531943,531944,531953,531989,531991,532057,532057,532057,532057,532058,532059,532059,532059,532127,532130,532133,532138,532141,532147,532165,532171,532171,532173,532181,532188,532197,532237,532246,532250,532260,532260,532262,532265,532274,532284,532290,532327,532334,532399,532421,532424,532425,532462,532483,532514,532518,532522,532538,532557,532557,532573,532592,532641,532645,532668,532713,532735,532739,532739,532800,532875,532875,532890,532905,532964,533009,533040,533046,533047,533047,533086,533089,533090,533090,533116,533127,533127,533165,533191,533283,533291,533293,533405,533409,533418,533597,533656,533677,533707,533770,533770,533772,533781,533783,533786,533811,533891,533901,533941,533947,533948,533966,533968,534004,534015,534024,534043,534044,534065,534077,534120,534120,534142,534151,534201,534310,534324,534374,534410,534443,534443,534443,534445,534445,534445,534445,534445,534445,534445,534445,534446,534446,534446,534446,534446,534446,534446,534446,534446,534447,534447,534447,534447,534448,534450,534450,534450,534450,534451,534451,534451,534451,534452,534525,534545,534562,534574,534606,534633,534668,534714,534769,534796,534796,534806,534806,534815,534821,534837,534867,534887,534922,534930,534942,534944,534948,534971,534984,534998,535000,535011,535017,535057,535220,535226,535244,535339,535372,535387,535387,535387,535387,535389,535392,535392,535392,535392,535392,535448,535531,535559,535604,535634,535666,535725,535735,535741,535861,535869,535869,535869,535869,535869,535893,535920,535936,535978,536000,536044,536083,536287,536381,536383,536404,536512,536521,536527,536538,536553,536557,536557,536581,536611,536652,536659,536673,536768,536802,536804,536806,536821,536836,536942,536980,536993,537029,537038,537138,537179,537221,537394,537395,537403,537470,537472,537515,537538,537570,537572,537622,537656,537662,537669,537670,537694,537701,537719,537721,537721,537722,537726,537726,537736,537740,537742,537742,537744,537745,537745,537746,537824,537860,537861,537975,537991,538036,538051,538114,538223,538231,538244,538252,538277,538333,538341,538375,538375,538378,538379,538392,538398,538399,538399,538418,538433,538441,538453,538557,538603,538620,538665,538672,538714,538722,538744,538828,538831,538944,538954,538976,538990,539071,539101,539127,539156,539156,539163,539196,539201,539245,539256,539257,539259,539259,539266,539269,539343,539382,539390,539397,539403,539442,539445,539493,539496,539501,539501,539516,539554,539591,539608,539608,539609,539637,539683,539713,539716,539732,539768,539920,539948,539949,539952,539952,539952,539952,539952,539953,539955,539956,539956,539956,539956,539956,539968,539968,539968,539968,539968,539968,539969,539971,539971,539971,539971,539971,539971,539971,539972,539974,539974,539974,539974,539974,539974,539989,540006,540027,540043,540051,540079,540080,540099,540150,540161,540172,540192,540233,540243,540260,540261,540267,540286,540317,540320,540331,540379,540382,540383,540391,540404,540416,540422,540455,540466,540467,540508,540533,540600,540717,540730,540730,540848,540895,540979,540980,540989,541041,541045,541191,541198,541202,541222,541315,541316,541365,541441,541441,541451,541459,541551,541695,541697,541732,541738,541738,541738,541738,541738,541738,541738,541739,541739,541780,541811,541861,541863,541867,541955,541965,542003,542024,542040,542075,542086,542101,542107,542189,542270,542317,542323,542343,542374,542395,542415,542432,542477,542479,542481,542497,542498,542508,542519,542533,542594,542598,542618,542634,542634,542635,542638,542639,542639,542639,542639,542640,542686,542693,542699,542714,542717,542717,542717,542723,542757,542824,542850,542850,542885,542897,542902,542903,542903,542913,542915,542948,542949,542950,542969,542989,542989,542989,542999,542999,543019,543042,543042,543044,543044,543060,543061,543061,543063,543074,543141,543141,543207,543316,543339,543339,543339,543339,543339,543361,543426,543449,543450,543533,543533,543545,543604,543653,543693,543693,543694,543705,543705,543733,543841,543880,543887,543932,543939,543952,543960,543961,543961,543962,543963,544038,544061,544064,544071,544108,544213,544321,544371,544391,544424,544522,544532,544532,544612,544658,544670,544677,544690,544700,544705,544718,544738,544752,544791,544798,544800,544811,544834,544834,544842,544870,544901,544917,544918,544978,545054,545077,545112,545117,545122,545203,545333,545340,545370,545370,545370,545372,545372,545372,545372,545372,545372,545372,545372,545373,545377,545414,545487,545529,545533,545533,545534,545559,545600,545600,545669,545694,545700,545709,545743,545753,545775,545805,545825,545858,545893,545893,545893,545893,545893,545920,545999,546029,546029,546029,546029,546029,546042,546097,546108,546136,546145,546155,546212,546303,546347,546349,546417,546447,546471,546584,546584,546585,546585,546585,546591,546610,546610,546610,546610,546610,546634,546645,546685,546686,546686,546761,546816,546908,546931,546967,546988,546993,546993,547007,547007,547023,547063,547092,547141,547141,547142,547186,547189,547198,547231,547234,547249,547284,547290,547316,547338,547351,547354,547354,547390,547492,547498,547501,547501,547501,547501,547501,547546,547553,547575,547611,547611,547611,547611,547611,547612,547613,547613,547614,547614,547617,547618,547620,547620,547640,547644,547659,547723,547730,547749,547790,547819,547834,547856,547874,547889,547925,547944,547952,547956,547969,547977,548009,548074,548278,548376,548382,548455,548513,548520,548541,548542,548548,548561,548564,548569,548569,548577,548586,548597,548657,548664,548684,548743,548758,548765,548801,548883,548883,548883,548937,548940,548954,548971,548985,549005,549048,549057,549067,549133,549133,549133,549134,549134,549134,549134,549134,549134,549134,549134,549177,549192,549310,549365,549369,549403,549446,549456,549554,549571,549572,549575,549616,549669,549692,549692,549738,549741,549751,549790,549810,549828,549948,549953,549955,549965,549992";std::string msProdSeedContracts550000 = "550012,550050,550073,550077,550118,550141,550148,550156,550166,550168,550183,550208,550212,550249,550259,550269,550270,550325,550366,550421,550428,550456,550493,550590,550747,550794,550823,550871,550943,550954,550993,551032,551046,551070,551070,551076,551083,551148,551157,551209,551211,551272,551319,551328,551356,551362,551392,551395,551403,551422,551430,551430,551522,551529,551536,551574,551597,551598,551672,551695,551708,551841,551901,552023,552024,552024,552026,552026,552101,552132,552142,552156,552176,552260,552270,552272,552276,552276,552277,552295,552301,552307,552329,552364,552364,552394,552417,552425,552427,552441,552455,552469,552535,552541,552550,552593,552631,552637,552649,552773,552829,552873,552914,552931,552948,553001,553026,553045,553053,553098,553111,553111,553126,553224,553352,553387,553407,553408,553415,553415,553580,553622,553715,553834,553881,553942,553943,553968,553968,553992,554000,554005,554006,554013,554014,554020,554021,554021,554023,554026,554026,554026,554026,554028,554031,554034,554037,554066,554093,554103,554125,554127,554131,554139,554140,554141,554142,554142,554142,554142,554143,554144,554145,554145,554146,554146,554146,554146,554147,554147,554148,554149,554150,554150,554150,554150,554150,554150,554151,554151,554151,554152,554152,554152,554153,554154,554158,554158,554166,554166,554173,554173,554175,554187,554189,554195,554195,554195,554195,554195,554205,554226,554226,554238,554255,554268,554283,554284,554285,554361,554361,554382,554385,554388,554388,554392,554402,554404,554488,554523,554544,554566,554569,554587,554604,554613,554643,554649,554659,554688,554690,554698,554717,554732,554740,554792,554792,554792,554817,554854,554864,554865,554881,554889,554900,554900,554900,554900,554900,554905,554917,554924,554935,554936,554964,554978,554999,554999,555045,555077,555085,555139,555148,555161,555188,555217,555228,555235,555254,555270,555328,555365,555405,555411,555413,555418,555456,555471,555521,555564,555574,555584,555606,555641,555641,555682,555700,555708,555711,555715,555744,555755,555770,555780,555786,555806,555808,555858,555884,555921,555923,555923,555924,555924,555924,555924,555933,555943,555944,555951,555955,555969,555972,555972,555976,555990,555993,556013,556015,556050,556050,556052,556055,556065,556120,556126,556160,556180,556181,556181,556185,556186,556186,556189,556189,556189,556189,556189,556189,556189,556197,556232,556283,556298,556302,556336,556352,556357,556382,556386,556418,556491,556501,556501,556501,556523,556539,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556548,556555,556564,556564,556564,556568,556657,556662,556663,556668,556668,556668,556685,556699,556703,556723,556755,556792,556822,556848,556901,556923,556923,556927,556931,557007,557082,557110,557126,557234,557321,557391,557392,557458,557529,557540,557549,557558,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557563,557567,557580,557596,557596,557600,557600,557601,557605,557607,557608,557608,557608,557609,557640,557647,557662,557681,557683,557721,557792,557818,557820,557833,557865,557871,557884,557884,557884,557885,557885,557885,557885,557889,557889,557889,557889,557889,557889,557889,557889,557889,557889,557889,557962,557972,557985,557985,558005,558157,558206,558220,558251,558254,558266,558287,558301,558304,558319,558361,558372,558390,558409,558412,558412,558412,558412,558413,558414,558415,558417,558418,558418,558418,558420,558420,558421,558426,558435,558440,558442,558444,558462,558462,558469,558469,558500,558588,558610,558614,558647,558677,558682,558682,558687,558690,558696,558713,558770,558777,558781,558801,558822,558838,558873,558876,559002,559032,559034,559035,559078,559089,559102,559103,559214,559230,559230,559230,559274,559281,559347,559374,559394,559410,559432,559433,559433,559435,559443,559446,559456,559456,559460,559495,559516,559518,559521,559521,559526,559527,559540,559589,559606,559623,559630,559634,559641,559679,559680,559681,559854,559858,559976,560018,560091,560114,560125,560145,560161,560207,560246,560247,560269,560303,560354,560463,560543,560547,560551,560562,560577,560667,560683,560697,560725,560755,560762,560788,560792,560821,560831,560846,560846,560925,560947,561002,561027,561052,561058,561058,561058,561058,561058,561058,561058,561058,561059,561061,561061,561061,561062,561065,561069,561069,561069,561069,561069,561071,561158,561171,561197,561216,561217,561231,561300,561344,561349,561352,561355,561359,561362,561478,561482,561492,561502,561513,561513,561553,561561,561594,561641,561647,561651,561696,561714,561760,561788,561797,561912,561913,561939,561943,561972,561989,562024,562041,562049,562116,562259,562260,562270,562286,562292,562324,562330,562344,562372,562375,562381,562394,562401,562403,562466,562539,562591,562595,562641,562651,562658,562671,562674,562680,562681,562946,562955,562962,563057,563084,563112,563176,563185,563195,563247,563265,563288,563352,563359,563387,563417,563420,563420,563435,563439,563458,563485,563517,563532,563543,563552,563561,563576,563701,563715,563744,563845,563845,563882,563902,563911,563915,563930,564013,564014,564044,564064,564081,564092,564190,564223,564265,564281,564304,564304,564332,564338,564380,564406,564408,564518,564524,564566,564575,564581,564584,564587,564603,564650,564659,564677,564788,564788,564822,564869,564910,565026,565040,565042,565077,565086,565086,565086,565086,565086,565086,565086,565086,565087,565088,565089,565091,565091,565091,565091,565091,565091,565091,565091,565091,565144,565157,565183,565217,565219,565219,565222,565229,565238,565255,565261,565278,565284,565298,565314,565317,565320,565325,565328,565330,565336,565366,565368,565371,565373,565387,565405,565421,565427,565449,565486,565587,565732,565753,565774,565856,565861,565861,565861,565875,565885,565984,565999,566026,566045,566060,566065,566089,566110,566131,566178,566244,566281,566319,566361,566375,566391,566413,566416,566461,566518,566559,566623,566664,566665,566683,566692,566831,566939,566956,567086,567086,567136,567137,567141,567141,567157,567161,567161,567161,567161,567161,567187,567209,567211,567218,567259,567259,567271,567381,567382,567412,567464,567757,567760,567813,567843,567846,567863,567896,567897,567920,567934,567938,567960,567977,567980,568030,568030,568074,568077,568150,568185,568246,568329,568345,568395,568395,568395,568395,568395,568396,568396,568396,568396,568400,568400,568400,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568410,568434,568494,568531,568599,568907,568912,568931,568949,568964,568992,569032,569073,569110,569170,569190,569218,569259,569443,569449,569507,569652,569720,569788,569823,569842,569851,569878,569936,569959,569995,570038,570212,570264,570294,570306,570314,570317,570344,570362,570401,570549,570610,570628,570628,570638,570663,570733,570758,570825,570841,570866,570913,570917,570929,570956,570992,571028,571082,571109,571149,571161,571180,571201,571208,571235,571319,571330,571356,571416,571544,571577,571681,571700,571830,571849,571879,571887,571927,571946,571979,572006,572019,572097,572202,572289,572293,572334,572389,572498,572535,572652,572702,572797,572836,572955,572972,573040,573045,573092,573134,573143,573155,573270,573283,573416,573445,573446,573446,573447,573448,573449,573449,573449,573449,573449,573450,573451,573452,573452,573452,573452,573452,573454,573456,573457,573457,573457,573457,573462,573462,573462,573462,573517,573520,573560,573571,573589,573598,573604,573604,573637,573642,573685,573824,573824,573825,573825,573827,573828,573911,573913,573922,573922,573961,574021,574043,574089,574134,574178,574212,574221,574233,574333,574333,574334,574348,574386,574396,574399,574434,574442,574466,574466,574466,574513,574559,574561,574572,574573,574584,574611,574640,574649,574654,574689,574718,574745,574769,574788,574793,574834,574836,574892,574898,574930,574974";std::string msProdSeedContracts575000 = "575048,575060,575087,575120,575132,575161,575161,575181,575186,575207,575230,575283,575300,575300,575304,575304,575304,575304,575304,575304,575304,575304,575309,575313,575382,575460,575472,575477,575480,575487,575487,575487,575488,575505,575525,575540,575571,575604,575609,575626,575680,575683,575684,575684,575698,575701,575710,575737,575740,575742,575751,575789,575789,575789,575789,575789,575790,575790,575790,575791,575791,575793,575793,575793,575793,575793,575793,575793,575794,575795,575853,575879,575993,576079,576092,576096,576127,576146,576224,576243,576307,576332,576337,576353,576355,576356,576393,576411,576420,576422,576429,576429,576446,576585,576591,576643,576685,576810,576818,576896,576897,576913,576949,577002,577042,577128,577201,577280,577281,577282,577289,577323,577348,577349,577366,577403,577415,577417,577459,577459,577460,577462,577497,577498,577528,577541,577569,577572,577593,577638,577797,577799,577799,577799,577799,577800,577808,577824,577832,577833,577957,577962,577999,578092,578112,578148,578168,578180,578230,578231,578235,578255,578255,578255,578265,578280,578300,578300,578300,578300,578300,578300,578300,578300,578300,578301,578301,578301,578301,578301,578301,578309,578321,578346,578356,578392,578414,578415,578432,578443,578447,578455,578457,578464,578475,578476,578488,578489,578515,578529,578530,578533,578533,578569,578624,578631,578634,578647,578672,578756,578757,578762,578792,578792,578794,578796,578809,578811,578820,578828,578838,578845,578936,578941,578958,578989,579065,579078,579109,579143,579173,579175,579202,579202,579202,579202,579231,579253,579259,579279,579283,579285,579285,579293,579342,579364,579370,579372,579372,579374,579384,579387,579388,579396,579418,579418,579434,579442,579508,579512,579526,579571,579600,579600,579624,579635,579651,579668,579708,579728,579734,579734,579745,579749,579781,579811,579870,579905,579955,580009,580012,580061,580088,580187,580190,580210,580215,580217,580218,580222,580222,580223,580223,580252,580285,580294,580305,580308,580314,580314,580315,580315,580316,580330,580348,580349,580353,580517,580623,580624,580624,580704,580704,580749,580756,580786,580810,580887,580888,580898,580977,580977,580979,580983,581035,581035,581035,581035,581036,581067,581071,581071,581088,581127,581136,581167,581168,581208,581225,581253,581255,581259,581276,581283,581288,581325,581331,581349,581359,581362,581397,581401,581462,581503,581555,581610,581614,581621,581684,581689,581694,581694,581694,581695,581696,581697,581697,581697,581697,581697,581721,581722,581757,581773,581780,581794,581800,581807,581826,581847,581927,581928,581941,581998,582017,582026,582030,582054,582055,582069,582070,582071,582080,582091,582091,582103,582103,582105,582118,582128,582139,582141,582141,582141,582143,582188,582191,582191,582253,582273,582293,582303,582325,582340,582343,582347,582381,582413,582425,582442,582455,582458,582482,582559,582561,582581,582697,582732,582763,582812,582812,582826,582852,582874,582876,582898,582902,582912,582930,582934,582942,582954,582954,582954,582956,582963,582969,582971,582984,582993,582994,582995,582995,583013,583063,583080,583109,583135,583238,583253,583260,583307,583332,583427,583428,583441,583445,583500,583525,583561,583635,583704,583705,583737,583791,583817,583827,583847,583866,583879,583879,583880,583881,583918,583942,583973,583977,583978,584010,584012,584012,584034,584055,584065,584093,584131,584163,584265,584324,584337,584358,584409,584440,584488,584525,584547,584581,584581,584582,584622,584622,584623,584637,584639,584674,584713,584724,584744,584747,584755,584762,584799,584799,584799,584799,584799,584799,584799,584799,584799,584805,584808,584810,584816,584862,584907,584930,584960,584968,585025,585166,585193,585206,585228,585313,585324,585335,585420,585443,585476,585527,585529,585536,585550,585558,585558,585558,585562,585627,585631,585649,585680,585685,585689,585735,585749,585758,585767,585780,585784,585797,585805,585806,585927,586180,586183,586184,586209,586251,586296,586319,586319,586338,586414,586472,586479,586504,586512,586515,586527,586528,586534,586547,586560,586561,586561,586561,586640,586685,586696,586702,586769,586786,586786,586829,586841,586861,586872,586873,586891,587053,587074,587077,587082,587098,587105,587111,587114,587164,587238,587287,587317,587342,587433,587461,587484,587499,587513,587525,587538,587539,587542,587544,587561,587562,587562,587579,587598,587605,587611,587618,587685,587722,587737,587748,587783,587885,587890,587937,587949,587950,587950,587950,587950,587950,587950,587950,587950,587950,587950,587950,587978,587995,588008,588015,588039,588068,588079,588099,588100,588102,588141,588155,588177,588201,588253,588275,588285,588320,588320,588336,588348,588384,588412,588435,588488,588488,588498,588500,588502,588549,588573,588607,588634,588695,588730,588737,588747,588848,588877,588890,588921,588937,589051,589077,589083,589083,589084,589114,589181,589245,589252,589263,589271,589282,589282,589282,589292,589294,589294,589307,589317,589323,589358,589359,589487,589494,589500,589500,589515,589574,589613,589710,589745,589940,589964,590017,590048,590060,590073,590091,590092,590092,590138,590161,590168,590205,590208,590209,590249,590264,590273,590292,590411,590424,590553,590622,590827,590839,590893,590902,590929,590947,590982,590989,591055,591078,591120,591132,591210,591211,591212,591212,591212,591213,591215,591215,591215,591215,591215,591215,591215,591215,591215,591215,591215,591215,591215,591224,591226,591253,591257,591340,591349,591349,591380,591420,591430,591438,591462,591567,591606,591680,591730,591745,591750,591908,591913,591956,591985,592068,592102,592109,592145,592225,592320,592371,592395,592409,592515,592528,592792,592792,592890,592915,592965,592967,593025,593055,593127,593275,593275,593290,593356,593381,593413,593594,593696,593701,593798,593961,593971,594003,594077,594082,594097,594114,594130,594268,594340,594427,594468,594476,594476,594529,594661,594824,594824,594829,594847,594864,594969,595042,595061,595068,595102,595111,595118,595153,595246,595323,595363,595405,595454,595454,595454,595463,595479,595480,595505,595554,595555,595555,595557,595743,595753,595828,595859,595874,595874,595886,595921,595921,595936,596071,596105,596105,596105,596259,596280,596296,596330,596331,596332,596349,596363,596440,596465,596474,596504,596504,596589,596721,596763,596764,596764,596765,596765,596765,596767,596767,596768,596772,596775,596800,596806,596808,596828,596828,596828,596854,596888,596890,596965,597002,597019,597044,597070,597070,597070,597077,597083,597156,597177,597189,597208,597213,597213,597213,597213,597213,597213,597213,597213,597213,597213,597214,597233,597243,597272,597277,597277,597361,597406,597411,597421,597468,597472,597472,597517,597523,597537,597580,597609,597611,597611,597613,597613,597782,597836,597853,597941,597972,597973,597981,598029,598091,598155,598193,598217,598262,598263,598265,598306,598307,598316,598330,598337,598337,598361,598361,598451,598487,598491,598514,598596,598612,598618,598689,598692,598699,598768,598831,598831,598898,598906,598993,599058,599058,599097,599141,599144,599159,599161,599216,599240,599240,599259,599321,599345,599353,599353,599365,599365,599368,599368,599368,599370,599371,599393,599426,599464,599473,599484,599485,599485,599486,599486,599486,599486,599489,599491,599514,599514,599514,599520,599520,599542,599542,599592,599600,599612,599636,599636,599656,599664,599683,599688,599707,599710,599781,599810,599873,599900,599957,599960";std::string msProdSeedContracts600000 = "600066,600071,600075,600211,600279,600325,600340,600376,600422,600441,600447,600458,600530,600533,600629,600632,600637,600748,600777,600788,600788,600928,600940,601163,601201,601201,601201,601203,601203,601260,601313,601320,601327,601378,601386,601417,601451,601501,601501,601508,601514,601520,601521,601528,601546,601569,601621,601624,601656,601683,601760,601802,601823,601891,601891,601891,601908,601944,601955,601972,601975,601975,601994,602021,602034,602082,602096,602113,602117,602122,602166,602225,602276,602281,602339,602349,602362,602379,602431,602435,602451,602458,602482,602693,602756,602780,602803,602819,602830,602916,602917,602973,602981,603050,603058,603059,603105,603151,603166,603185,603235,603257,603279,603300,603373,603514,603521,603586,603638,603653,603752,603886,603892,603932,603953,603988,604004,604041,604074,604099,604117,604119,604119,604119,604119,604119,604120,604124,604124,604124,604124,604124,604124,604124,604124,604124,604124,604124,604124,604124,604124,604126,604132,604132,604136,604147,604167,604181,604185,604203,604215,604216,604226,604226,604259,604279,604310,604353,604445,604462,604469,604469,604469,604487,604510,604585,604596,604695,604708,604751,604764,604811,604820,604854,604855,604867,604912,604939,604939,604939,604950,604950,604952,604952,604963,604967,604975,605001,605028,605046,605083,605097,605101,605107,605211,605281,605290,605291,605359,605399,605403,605478,605482,605491,605495,605560,605595,605601,605606,605616,605620,605646,605647,605693,605735,605735,605793,605794,605805,605860,605880,605880,605943,605962,605991,606001,606026,606059,606066,606126,606198,606219,606294,606339,606339,606390,606435,606537,606542,606577,606585,606615,606655,606663,606672,606702,606850,606865,606894,607000,607000,607000,607000,607000,607000,607001,607002,607002,607002,607002,607002,607003,607005,607006,607007,607007,607007,607007,607007,607007,607008,607021,607031,607040,607048,607056,607074,607180,607245,607246,607248,607465,607478,607538,607543,607560,607567,607590,607635,607713,607713,607719,607734,607741,607762,607837,607853,607944,607944,607975,608232,608266,608281,608307,608310,608323,608368,608376,608403,608415,608432,608451,608456,608491,608501,608508,608532,608552,608558,608579,608585,608592,608676,608683,608818,608885,608902,608905,608905,608914,608925,608939,608959,608967,609026,609026,609040,609088,609091,609153,609287,609305,609305,609314,609342,609403,609414,609468,609474,609477,609483,609489,609492,609510,609537,609538,609553,609584,609630,609634,609674,609682,609778,609825,609827,609893,609893,609959,610013,610027,610040,610053,610151,610154,610180,610185,610186,610277,610326,610352,610395,610403,610432,610468,610469,610469,610470,610471,610471,610501,610518,610522,610522,610522,610522,610522,610522,610527,610527,610527,610527,610528,610528,610528,610530,610530,610530,610530,610530,610530,610530,610530,610531,610566,610572,610581,610582,610594,610668,610760,610876,610876,610877,610877,610891,610939,610949,610980,610982,610988,611018,611031,611046,611057,611083,611091,611092,611135,611150,611155,611178,611190,611217,611251,611292,611311,611382,611419,611431,611533,611535,611551,611562,611616,611662,611672,611683,611789,611828,611840,611872,611889,611900,611920,611977,612027,612115,612153,612160,612182,612268,612317,612425,612425,612428,612469,612530,612563,612564,612565,612575,612640,612650,612750,612822,612822,612822,612876,612877,612914,612930,612949,613000,613050,613090,613126,613197,613218,613254,613255,613260,613264,613275,613322,613322,613347,613353,613410,613410,613443,613541,613544,613671,613671,613672,613672,613672,613674,613675,613675,613675,613676,613680,613779,613783,613802,613827,613847,613854,613882,613906,613920,613932,613978,614022,614070,614094,614127,614339,614675,614689,614834,614883,614998,615004,615004,615004,615010,615067,615325,615325,615406,615476,615526,615600,615600,615677,615680,615687,615713,615714,615827,615897,615902,615903,615903,615907,615991,616122,616132,616228,616230,616292,616452,616470,616473,616519,616528,616629,616710,616711,616714,616715,616752,616758,616775,616811,616811,616812,616813,616813,616813,616814,616814,616814,616814,616876,616950,616983,617131,617151,617402,617554,617555,617583,617587,617618,617645,617649,617938,617982,617990,618001,618028,618028,618073,618289,618382,618400,618415,618426,618442,618515,618524,618536,618544,618544,618555,618556,618567,618571,618581,618676,618729,618745,618751,618780,618830,618831,618838,618858,618870,618871,618905,619095,619098,619133,619166,619188,619271,619295,619378,619433,619442,619447,619453,619474,619474,619505,619562,619653,619658,619690,619709,619756,619769,619927,619950,620115,620144,620204,620243,620279,620314,620334,620344,620375,620386,620386,620386,620436,620440,620440,620446,620521,620570,620573,620574,620574,620707,620730,620972,620974,620974,621008,621008,621164,621180,621192,621206,621206,621206,621206,621206,621206,621206,621207,621207,621207,621207,621207,621209,621211,621220,621225,621236,621389,621472,621491,621492,621493,621501,621522,621531,621563,621574,621586,621592,621596,621628,621904,621937,621943,621973,621988,621991,622101,622190,622205,622224,622227,622227,622262,622285,622374,622409,622452,622453,622468,622500,622525,622552,622553,622615,622667,622829,622834,622858,622858,622858,622858,622858,622859,622859,622860,622894,622943,622959,623111,623170,623174,623247,623247,623270,623271,623271,623275,623324,623350,623355,623375,623399,623705,623708,623777,623799,623928,623965,623977,624009,624014,624019,624019,624021,624022,624032,624037,624047,624061,624063,624070,624081,624084,624085,624087,624087,624088,624104,624117,624126,624140,624150,624160,624160,624160,624166,624169,624170,624170,624170,624173,624173,624175,624175,624175,624175,624175,624175,624175,624175,624179,624179,624180,624180,624180,624180,624180,624180,624180,624180,624181,624181,624181,624181,624185,624186,624186,624186,624186,624186,624186,624186,624186,624189,624189,624192,624194,624194,624195,624198,624199,624201,624216,624264,624266,624275,624275,624281,624281,624286,624290,624298,624298,624330,624345,624346,624349,624387,624393,624397,624398,624399,624399,624423,624431,624534,624535,624605,624613,624636,624647,624652,624652,624658,624683,624696,624699,624707,624707,624718,624718,624741,624758,624766,624791,624849,624867,624867,624867,624867,624867,624867,624867,624867,624867,624867,624867,624867,624867,624867,624867,624867,624867,624878,624916,624916,624917,624917,624931,624934,624934,624941,624968,624980,624984,625001,625032,625034,625049,625102,625122,625122,625122,625145,625169,625169,625169,625169,625169,625169,625169,625170,625170,625171,625237,625237,625244,625282,625327,625327,625327,625327,625338,625338,625339,625381,625381,625381,625382,625493,625502,625503,625503,625503,625503,625503,625503,625503,625503,625503,625503,625518,625527,625601,625601,625611,625634,625651,625703,625721,625725,625748,625751,625767,625768,625797,625802,625836,625841,625892,625929,625939,625941,625983,626017,626068,626083,626111,626126,626143,626153,626161,626264,626333,626360,626411,626412,626424,626431,626453,626466,626466,626516,626524,626628,626705,626705,626717,626757,626762,626770,626778,626784,626806,626814,626842,626919,626959,627004,627028,627028,627028,627028,627028,627028,627028,627028,627028,627028,627028,627028,627028,627028,627031,627031,627031,627038,627039,627041,627042,627043,627047,627061,627067,627095,627096,627098,627156,627164,627205,627239,627257,627279,627328,627331,627335,627339,627340,627343,627343,627358,627364,627410,627433,627457,627498,627527,627532,627544,627556,627556,627602,627630,627654,627660,627664,627694,627694,627714,627755,627797,627804,627831,627837,627844,627845,627865,627890,627915,627988,627998,628007,628012,628012,628079,628093,628169,628246,628267,628267,628270,628314,628321,628446,628483,628510,628532,628584,628602,628606,628662,628671,628674,628678,628709,628712,628737,628754,628755,628809,628880,628907,628908,628946,628966,628973,628975,628981,628991,629051,629189,629290,629367,629401,629401,629413,629413,629448,629487,629491,629513,629603,629651,629685,629690,629712,629726,629726,629730,629741,629760,629787,629789,629790,629816,629819,629824,629841,629863,629883,629941,629943,630008,630152,630289,630297,630307,630336,630414,630428,630510,630510,630511,630530,630537,630551,630616,630620,630645,630666,630670,630696,630718,630741,630749,630766,630782,630783,630800,630809,630809,630839,630869,630912,630959,630985,630986,630986,630986,630986,630988,630989,630989,630989,630989,630989,630989,630990,630990,630991,630991,630991,630991,630991,630991,630991,630991,630991,630999,631046,631083,631304,631411,631496,631575,631590,631624,631674,631680,631711,631715,631733,631735,631762,631820,632027,632167,632222,632236,632255,632268,632329,632335,632340,632340,632340,632340,632340,632340,632340,632395,632445,632458,632489,632491,632498,632500,632509,632528,632531,632563,632566,632589,632597,632645,632645,632652,632680,632730,632745,632750,633059,633061,633067,633093,633155,633168,633180,633218,633222,633233,633233,633238,633261,633309,633332,633497,633504,633557,633631,633636,633638,633654,633681,633690,633712,633714,633733,633844,633977,634053,634073,634075,634201,634209,634275,634317,634320,634323,634324,634354,634368,634368,634383,634407,634418,634521,634604,634623,634672,634681,634721,634756,634978,634983,634986,635000,635002,635021,635032,635061,635097,635104,635110,635160,635167,635187,635199,635225,635257,635274,635287,635330,635337,635348,635356,635410,635443,635446,635525,635695,635734,635737,635754,635767,635781,635802,635897,635940,636029,636034,636043,636061,636062,636063,636116,636142,636148,636153,636163,636184,636185,636200,636211,636224,636304,636305,636306,636307,636331,636338,636339,636344,636350,636379,636434,636446,636635,636656,636663,636670,636670,636677,636709,636709,636759,636765,636799,636801,636808,636922,636945,637047,637060,637104,637189,637262,637263,637285,637329,637329,637329,637329,637330,637345,637392,637464,637555,637589,637589,637593,637647,637673,637673,637674,637787,637961,637975,638063,638074,638167,638213,638302,638347,638373,638479,638545,638575,638638,638698,638730,638836,638846,638899,639045,639067,639082,639118,639141,639142,639144,639144,639368,639490,639556,639881,639970,639982,640003,640018,640241,640253,640254,640254,640254,640254,640254,640257,640257,640257,640276,640323,640357,640456,640516,640592,640611,640649,640752,640753,640839,640847,640882,640898,640933,640946,640949,640980,640994,641004,641026,641080,641124,641229,641238,641245,641263,641283,641288,641291,641373,641387,641387,641393,641402,641604,641744,641767,641826,641852,641873,641905,641919,641921,641926,641926,641947,642047,642053,642055,642056,642061,642141,642223,642239,642251,642272,642281,642286,642305,642380,642503,642524,642608,642640,642890,642898,642906,642913,642954,642989,643001,643003,643010,643015,643018,643022,643062,643074,643104,643115,643118,643146,643146,643156,643226,643289,643293,643293,643314,643339,643339,643339,643339,643437,643445,643481,643515,643523,643565,643603,643648,643665,643679,643702,643758,643759,643762,643821,643821,643860,643889,644088,644096,644099,644099,644099,644110,644144,644147,644154,644247,644297,644325,644348,644498,644550,644586,644750,644811,644836,644926,645003,645039,645046,645046,645046,645081,645093,645137,645219,645229,645244,645256,645325,645338,645388,645438,645451,645468,645470,645480,645481,645553,645567,645660,645678,645693,645699,645752,645752,645752,645808,645883,645940,645952,645960,645969,646047,646047,646087,646094,646113,646145,646148,646154,646155,646174,646222,646232,646254,646275,646291,646310,646328,646329,646360,646362,646366,646454,646476,646478,646512,646553,646662,646761,646812,646900,646941,646947,646960,646997,647000,647012,647023,647026,647067,647077,647137,647154,647155,647190,647225,647263,647280,647290,647291,647296,647298,647323,647357,647368,647487,647490,647502,647503,647503,647512,647535,647684,647781,647840,647845,647891,647923,647976,648007,648062,648065,648077";

std::string BackupGridcoinWallet();
extern double GetPoSKernelPS2();
extern std::string GetBoincDataDir2();
double GetUntrustedMagnitude(std::string cpid, double& out_owed);

extern uint256 GridcoinMultipleAlgoHash(std::string t1);
extern bool OutOfSyncByAgeWithChanceOfMining();

int RebootClient();
vector<CInv> vNotFound;

std::string YesNo(bool bin);

extern double GetGridcoinBalance(std::string SendersGRCAddress);
int64_t GetMaximumBoincSubsidy(int64_t nTime);
extern bool IsLockTimeWithinMinutes(int64_t locktime, int minutes);
extern bool IsLockTimeWithinMinutes(double locktime, int minutes);
double GetNetworkProjectCountWithRAC();
extern double CalculatedMagnitude(int64_t locktime,bool bUseLederstrumpf);
extern int64_t GetCoinYearReward(int64_t nTime);
extern void AddNMRetired(double height,double LockTime, std::string cpid, MiningCPID bb);


map<uint256, CBlockIndex*> mapBlockIndex;
set<pair<COutPoint, unsigned int> > setStakeSeen;

CBigNum bnProofOfWorkLimit(~uint256(0) >> 20); // "standard" scrypt target limit for proof of work, results with 0,000244140625 proof-of-work difficulty
CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);
CBigNum bnProofOfStakeLimitV2(~uint256(0) >> 20);
CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);

//Gridcoin Minimum Stake Age (16 Hours)
unsigned int nStakeMinAge = 16 * 60 * 60; // 16 hours
unsigned int nStakeMaxAge = -1; // unlimited
unsigned int nModifierInterval = 10 * 60; // time to elapse before new modifier is computed
bool bCryptoLotteryEnabled = true;
bool bRemotePaymentsEnabled = false;
bool bNewbieFeatureEnabled = false;
bool bOPReturnEnabled = true;
bool bOptionPaymentsEnabled = false;

// Gridcoin:
int nCoinbaseMaturity = 100;
CBlockIndex* pindexGenesisBlock = NULL;
int nBestHeight = -1;
int nLastBestHeight = -1;

uint256 nBestChainTrust = 0;
uint256 nBestInvalidTrust = 0;
uint256 hashBestChain = 0;
CBlockIndex* pindexBest = NULL;
int64_t nTimeBestReceived = 0;
CMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have




map<uint256, CBlock*> mapOrphanBlocks;
multimap<uint256, CBlock*> mapOrphanBlocksByPrev;
set<pair<COutPoint, unsigned int> > setStakeSeenOrphan;

map<uint256, CTransaction> mapOrphanTransactions;
map<uint256, set<uint256> > mapOrphanTransactionsByPrev;

// Constant stuff for coinbase transactions we create:
CScript COINBASE_FLAGS;
const string strMessageMagic = "Gridcoin Signed Message:\n";

// Settings
int64_t nTransactionFee = MIN_TX_FEE;
int64_t nReserveBalance = 0;
int64_t nMinimumInputValue = 0;

std::map<std::string, std::string> mvApplicationCache;
std::map<std::string, int64_t> mvApplicationCacheTimestamp;
std::map<std::string, double> mvNeuralNetworkHash;
std::map<std::string, double> mvCurrentNeuralNetworkHash;

std::map<std::string, double> mvNeuralVersion;

std::map<std::string, StructCPID> mvDPOR;
std::map<std::string, StructCPID> mvDPORCopy;

std::map<std::string, StructCPID> mvResearchAge;
std::map<std::string, MiningCPID> mvBlockIndex;
std::map<std::string, std::string> mvCPIDBlockHashes;

extern enum Checkpoints::CPMode CheckpointsMode;

// Gridcoin - Rob Halford

extern std::string GetHttpPage(std::string cpid, bool usedns, bool clearcache);
extern std::string RetrieveMd5(std::string s1);
extern std::string aes_complex_hash(uint256 scrypt_hash);

volatile bool bNetAveragesLoaded = false;
volatile bool bTallyStarted      = false;
volatile bool bRestartGridcoinMiner = false;
volatile bool bForceUpdate = false;
volatile bool bExecuteCode = false;
volatile bool bAddressUser = false;
volatile bool bCheckedForUpgrade = false;
volatile bool bCheckedForUpgradeLive = false;
volatile bool bGlobalcomInitialized = false;
volatile bool bStakeMinerOutOfSyncWithNetwork = false;
volatile bool bDoTally = false;
volatile bool bExecuteGridcoinServices = false;
volatile bool bTallyFinished = false;
volatile bool bGridcoinGUILoaded = false;
volatile bool bRequestFromHonestNode = false;

extern bool CheckWorkCPU(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey);
extern double LederstrumpfMagnitude2(double Magnitude, int64_t locktime);
extern double cdbl(std::string s, int place);

extern double GetBlockValueByHash(uint256 hash);
extern void WriteAppCache(std::string key, std::string value);
extern std::string AppCache(std::string key);
void StartPostOnBackgroundThread(int height, MiningCPID miningcpid, uint256 hashmerkleroot, double nNonce, double subsidy, unsigned int nVersion, std::string message);
extern void LoadCPIDsInBackground();
bool SubmitGridcoinCPUWork(CBlock* pblock, CReserveKey& reservekey, double nonce);
CBlock* getwork_cpu(MiningCPID miningcpid, bool& succeeded,CReserveKey& reservekey);
extern int GetBlockType(uint256 prevblockhash);
extern bool GetTransactionFromMemPool(const uint256 &hash, CTransaction &txOut);
extern unsigned int DiffBytes(double PoBDiff);
extern int Races(int iMax1000);
int ReindexWallet();

std::string cached_getblocks_args = "";
extern bool AESSkeinHash(unsigned int diffbytes, double rac, uint256 scrypthash, std::string& out_skein, std::string& out_aes512);
std::string DefaultGetblocksCommand();
CClientUIInterface uiDog;
void ExecuteCode();
extern void CreditCheck(std::string cpid, bool clearcache);
extern void ThreadCPIDs();
extern std::string GetGlobalStatus();

extern void printbool(std::string comment, bool boo);
extern bool OutOfSyncByAge();
extern std::vector<std::string> split(std::string s, std::string delim);
extern bool ProjectIsValid(std::string project);
extern std::string SerializeBoincBlock(MiningCPID mcpid);
extern MiningCPID DeserializeBoincBlock(std::string block);

extern void InitializeCPIDs();
extern void ResendWalletTransactions2();
double GetNetworkAvgByProject(std::string projectname);
extern bool IsCPIDValid_Retired(std::string cpid, std::string ENCboincpubkey);
extern bool IsCPIDValidv2(MiningCPID& mc, int height);
extern void FindMultiAlgorithmSolution(CBlock* pblock, uint256 hash, uint256 hashTaget, double miningrac);
extern std::string getfilecontents(std::string filename);
extern std::string ToOfficialName(std::string proj);
extern bool LessVerbose(int iMax1000);
extern bool GetBlockNew(uint256 blockhash, int& out_height, CBlock& blk, bool bForceDiskRead);
extern std::string ExtractXML(std::string XMLdata, std::string key, std::string key_end);
extern void ShutdownGridcoinMiner();
extern bool OutOfSync();
extern MiningCPID GetNextProject(bool bForce);
extern void HarvestCPIDs(bool cleardata);

bool FindTransactionSlow(uint256 txhashin, CTransaction& txout,  std::string& out_errors);
std::string msCurrentRAC = "";
static boost::thread_group* cpidThreads = NULL;
//static boost::thread_group* tallyThreads = NULL;
extern void FlushGridcoinBlockFile(bool fFinalize);



///////////////////////////////
// Standard Boinc Projects ////
///////////////////////////////



 //Global variables to display current mined project in various places:
 std::string 	msMiningProject = "";
 std::string 	msMiningCPID = "";
 std::string    msPrimaryCPID = "";
 std::string    msENCboincpublickey = "";
 double      	mdMiningRAC =0;
 double         mdMiningNetworkRAC = 0;
 double			mdPORNonce = 0;
 double         mdPORNonceSolved = 0;
 double         mdLastPorNonce = 0;
 double         mdMachineTimer = 0;
 double         mdMachineTimerLast = 0;
 bool           mbBlocksDownloaded = false;
 // Mining status variables
 std::string    msHashBoinc    = "";
 std::string    msHashBoincTxId= "";
 std::string    msMiningErrors = "";
 std::string    msMiningErrors2 = "";
 std::string    msMiningErrors3 = "";
 std::string    msMiningErrors5 = "";
 std::string    msMiningErrors6 = "";
 std::string    msMiningErrors7 = "";
 std::string    msMiningErrors8 = "";
 std::string    msPeek = "";
 std::string    msLastCommand = "";

 std::string    msAttachmentGuid = "";

 std::string    msMiningErrorsIncluded = "";
 std::string    msMiningErrorsExcluded = "";
 std::string    msSuperBlockHashes = "";
 std::string    msContracts = "";

 std::string    msRSAOverview = "";
 std::string    Organization = "";
 std::string    OrganizationKey = "";
 std::string    msNeuralResponse = "";
 std::string    msHDDSerial = "";
 //When syncing, we grandfather block rejection rules up to this block, as rules became stricter over time and fields changed

 int nGrandfather = 631000;
 int nNewIndex = 271625;
 int nNewIndex2 = 364500;

 int64_t nGenesisSupply = 340569880;

 //GPU Projects:
 std::string 	msGPUMiningProject = "";
 std::string 	msGPUMiningCPID = "";
 std::string    msGPUENCboincpublickey = "";
 std::string    msGPUboinckey = "";
 double    	    mdGPUMiningRAC = 0;
 double         mdGPUMiningNetworkRAC = 0;
 // Stats for Main Screen:
 double         mdLastPoBDifficulty = 0;
 double         mdLastDifficulty = 0;
 std::string    msGlobalStatus = "";
 std::string    msLastPaymentTime = "";
 std::string    msMyCPID = "";
 double         mdOwed = 0;

 // CPU Miner threads global vars

 volatile double nGlobalHashCounter = 0;


 bool fImporting = false;
 bool fReindex = false;
 bool fBenchmark = false;
 bool fTxIndex = false;
 bool fColdBoot = true;

 int nBestAccepted = -1;


 uint256 nBestChainWork = 0;
 uint256 nBestInvalidWork = 0;
 //Optimizing internal cpu miner:
 uint256 GlobalhashMerkleRoot = 0;
 uint256 GlobalSolutionPowHash = 0;


// Gridcoin status    *************
MiningCPID GlobalCPUMiningCPID = GetMiningCPID();
int nBoincUtilization = 0;
double nMinerPaymentCount = 0;
int nPrint = 0;
std::string sBoincMD5 = "";
std::string sBoincBA = "";
std::string sRegVer = "";
std::string sBoincDeltaOverTime = "";
std::string sMinedHash = "";
std::string sSourceBlock = "";
std::string sDefaultWalletAddress = "";


std::map<std::string, StructCPID> mvCPIDs;        //Contains the project stats at the user level
std::map<std::string, StructCPID> mvCreditNode;   //Contains the verified stats at the user level
std::map<std::string, StructCPID> mvNetwork;      //Contains the project stats at the network level
std::map<std::string, StructCPID> mvNetworkCopy;      //Contains the project stats at the network level


std::map<std::string, StructCPID> mvNetworkCPIDs; //Contains CPID+Projects at the network level
//std::map<std::string, StructCPID> mvCreditNodeCPIDProject; //Contains verified CPID+Projects;
std::map<std::string, StructCPID> mvCreditNodeCPID;        // Contains verified CPID Magnitudes;
std::map<std::string, StructCPIDCache> mvCPIDCache; //Contains cached blocknumbers for CPID+Projects;
std::map<std::string, StructCPIDCache> mvAppCache; //Contains cached blocknumbers for CPID+Projects;
std::map<std::string, StructBlockCache> mvBlockCache;  //Contains Cached Blocks
std::map<std::string, StructCPID> mvBoincProjects; // Contains all of the allowed boinc projects;
std::map<std::string, StructCPID> mvMagnitudes; // Contains Magnitudes by CPID & Outstanding Payments Owed per CPID
std::map<std::string, StructCPID> mvMagnitudesCopy; // Contains Magnitudes by CPID & Outstanding Payments Owed per CPID

std::map<std::string, int> mvTimers; // Contains event timers that reset after max ms duration iterator is exceeded

// End of Gridcoin Global vars

std::map<int, int> blockcache;
bool bDebugMode = false;
bool bPoolMiningMode = false;
bool bBoincSubsidyEligible = false;
bool bCPUMiningMode = false;




//////////////////////////////////////////////////////////////////////////////
//
// dispatching functions
//

// These functions dispatch to one or all registered wallets


bool GetBlockNew(uint256 blockhash, int& out_height, CBlock& blk, bool bForceDiskRead)
{
    try
	{
			//First check the cache:
			StructBlockCache cache;
			cache = mvBlockCache[blockhash.GetHex()];
			if (cache.initialized)
			{
				 CTransaction txNew;
				 txNew.vin.resize(1);
				 txNew.vin[0].prevout.SetNull();
				 txNew.vout.resize(1);
				 txNew.hashBoinc = cache.hashBoinc;
				 blk.vtx.resize(1);
				 blk.vtx[0] = txNew;
				 blk.nVersion  = cache.nVersion;
				 if (!bForceDiskRead) return true;
			}

			CBlockIndex* pblockindex = mapBlockIndex[blockhash];
			bool result = blk.ReadFromDisk(pblockindex);
			if (!result) return false;
			//Cache the block
			cache.initialized = true;
			cache.hashBoinc = blk.vtx[0].hashBoinc;
			cache.hash = blockhash.GetHex();
			cache.nVersion = blk.nVersion;
			mvBlockCache[blockhash.GetHex()] = cache;
			out_height = pblockindex->nHeight;
			return true;
	}

	catch (std::exception &e)
	{
		printf("Catastrophic error retrieving GetBlockNew\r\n");
		return false;
	}
	catch(...)
	{
		printf("Catastrophic error retrieving block in GetBlockNew (06182014) \r\n");
		return false;
	}


}



  double GetGridcoinBalance(std::string SendersGRCAddress)
  {
    int nMinDepth = 1;
    int nMaxDepth = 9999999;
	if (SendersGRCAddress=="") return 0;
    set<CBitcoinAddress> setAddress;
    CBitcoinAddress address(SendersGRCAddress);
	if (!address.IsValid())
	{
		printf("Checkpoints::GetGridcoinBalance::InvalidAddress");
        return 0;
	}
	setAddress.insert(address);
    vector<COutput> vecOutputs;
    pwalletMain->AvailableCoins(vecOutputs, false);
	double global_total = 0;
    BOOST_FOREACH(const COutput& out, vecOutputs)
    {
        if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)
            continue;
        if(setAddress.size())
        {
            CTxDestination address;
            if(!ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))
                continue;
            if (!setAddress.count(address))
                continue;
        }
        int64_t nValue = out.tx->vout[out.i].nValue;
        //const CScript& pk = out.tx->vout[out.i].scriptPubKey;
        //CTxDestination address;
		global_total += nValue;
    }

    return CoinToDouble(global_total);
}


void ResetTimerMain(std::string timer_name)
{
	mvTimers[timer_name] = 0;
}


bool TimerMain(std::string timer_name, int max_ms)
{
	mvTimers[timer_name] = mvTimers[timer_name] + 1;
	if (mvTimers[timer_name] > max_ms)
	{
		mvTimers[timer_name]=0;
		return true;
	}
	return false;
}

bool UpdateNeuralNetworkQuorumData()
{
			#if defined(WIN32) && defined(QT_GUI)
			    if (!bGlobalcomInitialized) return false;
				std::string errors1 = "";
     			int64_t superblock_age = GetAdjustedTime() - mvApplicationCacheTimestamp["superblock;magnitudes"];
				std::string myNeuralHash = "";
				double popularity = 0;
				std::string consensus_hash = GetNeuralNetworkSupermajorityHash(popularity);
				std::string sAge = RoundToString((double)superblock_age,0);
				std::string sBlock = mvApplicationCache["superblock;block_number"];
				std::string sTimestamp = TimestampToHRDate(mvApplicationCacheTimestamp["superblock;magnitudes"]);
				std::string data = "<QUORUMDATA><AGE>" + sAge + "</AGE><HASH>" + consensus_hash + "</HASH><BLOCKNUMBER>" + sBlock + "</BLOCKNUMBER><TIMESTAMP>"
					+ sTimestamp + "</TIMESTAMP><PRIMARYCPID>" + msPrimaryCPID + "</PRIMARYCPID></QUORUMDATA>";
				std::string testnet_flag = fTestNet ? "TESTNET" : "MAINNET";
				qtExecuteGenericFunction("SetTestNetFlag",testnet_flag);
				qtExecuteDotNetStringFunction("SetQuorumData",data);
				return true;
			#endif
			return false;
}

bool PushGridcoinDiagnostics()
{
		#if defined(WIN32) && defined(QT_GUI)
  			    if (!bGlobalcomInitialized) return false;
				std::string errors1 = "";
                LoadAdminMessages(false,errors1);
				std::string cpiddata = GetListOf("beacon");
				std::string sWhitelist = GetListOf("project");
				int64_t superblock_age = GetAdjustedTime() - mvApplicationCacheTimestamp["superblock;magnitudes"];
				double popularity = 0;
				std::string consensus_hash = GetNeuralNetworkSupermajorityHash(popularity);
				std::string sAge = RoundToString((double)superblock_age,0);
				std::string sBlock = mvApplicationCache["superblock;block_number"];
				std::string sTimestamp = TimestampToHRDate(mvApplicationCacheTimestamp["superblock;magnitudes"]);
				printf("Pushing diagnostic data...");
				double lastblockage = PreviousBlockAge();
				double PORDiff = GetDifficulty(GetLastBlockIndex(pindexBest, true));
				std::string data = "<WHITELIST>" + sWhitelist + "</WHITELIST><CPIDDATA>"
					+ cpiddata + "</CPIDDATA><QUORUMDATA><AGE>" + sAge + "</AGE><HASH>" + consensus_hash + "</HASH><BLOCKNUMBER>" + sBlock + "</BLOCKNUMBER><TIMESTAMP>"
					+ sTimestamp + "</TIMESTAMP><PRIMARYCPID>" + msPrimaryCPID + "</PRIMARYCPID><LASTBLOCKAGE>" + RoundToString(lastblockage,0) + "</LASTBLOCKAGE><DIFFICULTY>" + RoundToString(PORDiff,2) + "</DIFFICULTY></QUORUMDATA>";
				std::string testnet_flag = fTestNet ? "TESTNET" : "MAINNET";
				qtExecuteGenericFunction("SetTestNetFlag",testnet_flag);
			    double dResponse = qtPushGridcoinDiagnosticData(data);
				return true;
		#endif
		return false;
}

bool FullSyncWithDPORNodes()
{
			#if defined(WIN32) && defined(QT_GUI)

				std::string sDisabled = GetArgument("disableneuralnetwork", "false");
				if (sDisabled=="true") return false;
				// 3-30-2016 : First try to get the master database from another neural network node if these conditions occur:
				// The foreign node is fully synced.  The foreign nodes quorum hash matches the supermajority hash.  My hash != supermajority hash.
				double dCurrentPopularity = 0;
				std::string sCurrentNeuralSupermajorityHash = GetCurrentNeuralNetworkSupermajorityHash(dCurrentPopularity);
				std::string sMyNeuralHash = "";
				#if defined(WIN32) && defined(QT_GUI)
					       sMyNeuralHash = qtGetNeuralHash("");
				#endif
				if (!sMyNeuralHash.empty() && !sCurrentNeuralSupermajorityHash.empty() && sMyNeuralHash != sCurrentNeuralSupermajorityHash)
				{
					bool bNodeOnline = RequestSupermajorityNeuralData();
					if (bNodeOnline) return false;  // Async call to another node will continue after the node responds.
				}
			
				std::string errors1 = "";
                LoadAdminMessages(false,errors1);
				std::string cpiddata = GetListOf("beacon");
				std::string sWhitelist = GetListOf("project");
				int64_t superblock_age = GetAdjustedTime() - mvApplicationCacheTimestamp["superblock;magnitudes"];
				double popularity = 0;
				std::string consensus_hash = GetNeuralNetworkSupermajorityHash(popularity);
				std::string sAge = RoundToString((double)superblock_age,0);
				std::string sBlock = mvApplicationCache["superblock;block_number"];
				std::string sTimestamp = TimestampToHRDate(mvApplicationCacheTimestamp["superblock;magnitudes"]);
				std::string data = "<WHITELIST>" + sWhitelist + "</WHITELIST><CPIDDATA>"
					+ cpiddata + "</CPIDDATA><QUORUMDATA><AGE>" + sAge + "</AGE><HASH>" + consensus_hash + "</HASH><BLOCKNUMBER>" + sBlock + "</BLOCKNUMBER><TIMESTAMP>"
					+ sTimestamp + "</TIMESTAMP><PRIMARYCPID>" + msPrimaryCPID + "</PRIMARYCPID></QUORUMDATA>";
				//if (fDebug3) printf("Syncing neural network %s \r\n",data.c_str());
				std::string testnet_flag = fTestNet ? "TESTNET" : "MAINNET";
				qtExecuteGenericFunction("SetTestNetFlag",testnet_flag);
				qtSyncWithDPORNodes(data);
			#endif
			return true;
}



double GetPoSKernelPS2()
{
    int nPoSInterval = 72;
    double dStakeKernelsTriedAvg = 0;
    int nStakesHandled = 0, nStakesTime = 0;

    CBlockIndex* pindex = pindexBest;;
    CBlockIndex* pindexPrevStake = NULL;

    while (pindex && nStakesHandled < nPoSInterval)
    {
        if (pindex->IsProofOfStake())
        {
            dStakeKernelsTriedAvg += GetDifficulty(pindex) * 4294967296.0;
            nStakesTime += pindexPrevStake ? (pindexPrevStake->nTime - pindex->nTime) : 0;
            pindexPrevStake = pindex;
            nStakesHandled++;
        }

        pindex = pindex->pprev;
    }

    double result = 0;

    if (nStakesTime)
        result = dStakeKernelsTriedAvg / nStakesTime;

    if (IsProtocolV2(nBestHeight))
        result *= STAKE_TIMESTAMP_MASK + 1;

    return result/100;
}


std::string GetGlobalStatus()
{
	//Populate overview

	try
	{
		std::string status = "";
		double boincmagnitude = CalculatedMagnitude(GetAdjustedTime(),false);
		uint64_t nWeight = 0;
		pwalletMain->GetStakeWeight(nWeight);
		nBoincUtilization = boincmagnitude; //Legacy Support for the about screen
		double weight = nWeight/COIN;
		double PORDiff = GetDifficulty(GetLastBlockIndex(pindexBest, true));
		std::string sWeight = RoundToString((double)weight,0);
		std::string sOverviewCPID = bPoolMiningMode ? "POOL" : GlobalCPUMiningCPID.cpid;

		//9-6-2015 Add RSA fields to overview
		if ((double)weight > 100000000000000)
		{
				sWeight = sWeight.substr(0,13) + "E" + RoundToString((double)sWeight.length()-13,0);
		}
		status = "&nbsp;<br>Blocks: " + RoundToString((double)nBestHeight,0) + "; PoR Difficulty: "
			+ RoundToString(PORDiff,3) + "; Net Weight: " + RoundToString(GetPoSKernelPS2(),2)
			+ "<br>DPOR Weight: " +  sWeight + "; Status: " + msMiningErrors
			+ "<br>Magnitude: " + RoundToString(boincmagnitude,2) + "; Project: " + msMiningProject
			+ "<br>CPID: " +  sOverviewCPID + " " +  msMiningErrors2 + " "
			+ "<br>" + msMiningErrors5 + " " + msMiningErrors6 + " " + msMiningErrors7 + " " + msMiningErrors8 + " "
			+ "<br>" + msRSAOverview + "<br>&nbsp;";
		//The last line break is for Windows 8.1 Huge Toolbar
		msGlobalStatus = status;
		return status;
	}
	catch (std::exception& e)
	{
			msMiningErrors = "Error obtaining status.";

			printf("Error obtaining status\r\n");
			return "";
		}
		catch(...)
		{
			msMiningErrors = "Error obtaining status (08-18-2014).";
			return "";
		}

}



std::string AppCache(std::string key)
{

	StructCPIDCache setting = mvAppCache["cache"+key];
	if (!setting.initialized)
	{
		setting.initialized=true;
		setting.xml = "";
		mvAppCache.insert(map<string,StructCPIDCache>::value_type("cache"+key,setting));
	    mvAppCache["cache"+key]=setting;
	}
	return setting.xml;
}



bool Timer_Main(std::string timer_name, int max_ms)
{
	mvTimers[timer_name] = mvTimers[timer_name] + 1;
	if (mvTimers[timer_name] > max_ms)
	{
		mvTimers[timer_name]=0;
		return true;
	}
	return false;
}



void WriteAppCache(std::string key, std::string value)
{
	StructCPIDCache setting = mvAppCache["cache"+key];
	if (!setting.initialized)
	{
		setting.initialized=true;
		setting.xml = "";
		mvAppCache.insert(map<string,StructCPIDCache>::value_type("cache"+key,setting));
	    mvAppCache["cache"+key]=setting;
	}
	setting.xml = value;
	mvAppCache["cache"+key]=setting;
}



void RegisterWallet(CWallet* pwalletIn)
{
    {
        LOCK(cs_setpwalletRegistered);
        setpwalletRegistered.insert(pwalletIn);
    }
}

void UnregisterWallet(CWallet* pwalletIn)
{
    {
        LOCK(cs_setpwalletRegistered);
        setpwalletRegistered.erase(pwalletIn);
    }
}


MiningCPID GetInitializedGlobalCPUMiningCPID(std::string cpid)
{

	MiningCPID mc = GetMiningCPID();
	mc.initialized = true;
	mc.cpid=cpid;
	mc.projectname = cpid;
	mc.cpidv2=cpid;
	mc.cpidhash = "";
	mc.email = cpid;
	mc.boincruntimepublickey = cpid;
	mc.rac=0;
	mc.encboincpublickey = "";
	mc.enccpid = "";
	mc.NetworkRAC = 0;
	mc.Magnitude = 0;
    mc.clientversion = "";
	mc.RSAWeight = GetRSAWeightByCPID(cpid);
	mc.LastPaymentTime = nLastBlockSolved;
	mc.diffbytes = 0;
	mc.lastblockhash = "0";
	return mc;
}


MiningCPID GetNextProject(bool bForce)
{



	if (GlobalCPUMiningCPID.projectname.length() > 3   &&  GlobalCPUMiningCPID.projectname != "INVESTOR"  && GlobalCPUMiningCPID.Magnitude > 1)
	{
				if (!Timer_Main("globalcpuminingcpid",10))
				{
					//Prevent Thrashing
					return GlobalCPUMiningCPID;
				}
	}


	std::string sBoincKey = GetArgument("boinckey","");
    if (!sBoincKey.empty())
	{
		if (fDebug3 && LessVerbose(50)) printf("Using cached boinckey for project %s\r\n",GlobalCPUMiningCPID.projectname.c_str());
					msMiningProject = GlobalCPUMiningCPID.projectname;
					msMiningCPID = GlobalCPUMiningCPID.cpid;
					if (LessVerbose(5)) printf("BoincKey - Mining project %s     RAC(%f)  enc %s\r\n",	GlobalCPUMiningCPID.projectname.c_str(), GlobalCPUMiningCPID.rac, msENCboincpublickey.c_str());
					double ProjectRAC = GetNetworkAvgByProject(GlobalCPUMiningCPID.projectname);
					GlobalCPUMiningCPID.NetworkRAC = ProjectRAC;
					mdMiningNetworkRAC = GlobalCPUMiningCPID.NetworkRAC;
					GlobalCPUMiningCPID.Magnitude = CalculatedMagnitude(GetAdjustedTime(),false);
					if (fDebug3) printf("(boinckey) For CPID %s Verified Magnitude = %f",GlobalCPUMiningCPID.cpid.c_str(),GlobalCPUMiningCPID.Magnitude);
					msMiningErrors = (msMiningCPID == "INVESTOR" || msPrimaryCPID=="INVESTOR" || msMiningCPID.empty()) ? "Staking Interest" : "Mining";
					GlobalCPUMiningCPID.RSAWeight = GetRSAWeightByCPID(GlobalCPUMiningCPID.cpid);
					GlobalCPUMiningCPID.LastPaymentTime = GetLastPaymentTimeByCPID(GlobalCPUMiningCPID.cpid);
					return GlobalCPUMiningCPID;
	}

	
	msMiningProject = "";
	msMiningCPID = "";
	mdMiningRAC = 0;
	msENCboincpublickey = "";
	GlobalCPUMiningCPID = GetInitializedGlobalCPUMiningCPID("");

	std::string email = GetArgument("email", "NA");
	boost::to_lower(email);



	if ( (IsInitialBlockDownload() || !bCPIDsLoaded) && !bForce)
	{
			if (LessVerbose(100))		    printf("CPUMiner: Gridcoin is downloading blocks Or CPIDs are not yet loaded...");
			MilliSleep(200);
			return GlobalCPUMiningCPID;
	}


	try
	{

		if (mvCPIDs.size() < 1)
		{
			if (fDebug && LessVerbose(10)) printf("Gridcoin has no CPIDs...");
			//Let control reach the investor area
		}

		int iValidProjects=0;
		//Count valid projects:
		for(map<string,StructCPID>::iterator ii=mvCPIDs.begin(); ii!=mvCPIDs.end(); ++ii)
		{
				StructCPID structcpid = mvCPIDs[(*ii).first];
				if (		msPrimaryCPID == structcpid.cpid &&
					structcpid.initialized && structcpid.Iscpidvalid && structcpid.rac > 10)			iValidProjects++;
		}

		// Find next available CPU project:
		int iDistributedProject = 0;
		int iRow = 0;

		if (email=="" || email=="NA") iValidProjects = 0;  //Let control reach investor area


		if (iValidProjects > 0)
		{
		for (int i = 0; i <= 4;i++)
		{
			iRow=0;
			iDistributedProject = (rand() % iValidProjects)+1;

			for(map<string,StructCPID>::iterator ii=mvCPIDs.begin(); ii!=mvCPIDs.end(); ++ii)
			{

				StructCPID structcpid = mvCPIDs[(*ii).first];
				if (GetArg("-fullbore", "false") != "true")	MilliSleep(35);

				if (structcpid.initialized)
				{
					if (msPrimaryCPID == structcpid.cpid &&
						structcpid.Iscpidvalid && structcpid.projectname.length() > 1 && structcpid.rac > 10)
					{
							iRow++;
							if (i==4 || iDistributedProject == iRow)
							{
								if (true)
								{
									GlobalCPUMiningCPID.enccpid = structcpid.boincpublickey;
									bool checkcpid = IsCPIDValid_Retired(structcpid.cpid,GlobalCPUMiningCPID.enccpid);
									if (!checkcpid)
									{
										printf("CPID invalid %s  1.  ",structcpid.cpid.c_str());
										continue;
									}

									if (checkcpid)
									{

									GlobalCPUMiningCPID.email = email;

									if (LessVerbose(1) || fDebug) printf("Ready to CPU Mine project %s with CPID %s, RAC(%f) \r\n",
										structcpid.projectname.c_str(),structcpid.cpid.c_str(),
										structcpid.rac);
									//Required for project to be mined in a block:
									GlobalCPUMiningCPID.cpid=structcpid.cpid;
									GlobalCPUMiningCPID.projectname = structcpid.projectname;
									GlobalCPUMiningCPID.rac=structcpid.rac;
									GlobalCPUMiningCPID.encboincpublickey = structcpid.boincpublickey;
									GlobalCPUMiningCPID.encaes = structcpid.boincpublickey;


									GlobalCPUMiningCPID.boincruntimepublickey = structcpid.cpidhash;
									uint256 pbh = 1;
									GlobalCPUMiningCPID.cpidv2 = ComputeCPIDv2(GlobalCPUMiningCPID.email,GlobalCPUMiningCPID.boincruntimepublickey, pbh);
									GlobalCPUMiningCPID.lastblockhash = "0";

									if (!IsCPIDValidv2(GlobalCPUMiningCPID,1))
									{
										printf("CPID INVALID 2 %s, %s  ",GlobalCPUMiningCPID.cpid.c_str(),GlobalCPUMiningCPID.cpidv2.c_str());
										continue;
									}


									//Only used for global status:
									msMiningProject = structcpid.projectname;
									msMiningCPID = structcpid.cpid;
									mdMiningRAC = structcpid.rac;

									double ProjectRAC = GetNetworkAvgByProject(GlobalCPUMiningCPID.projectname);
									GlobalCPUMiningCPID.NetworkRAC = ProjectRAC;
									mdMiningNetworkRAC = GlobalCPUMiningCPID.NetworkRAC;
									GlobalCPUMiningCPID.Magnitude = CalculatedMagnitude(GetAdjustedTime(),false);
									if (fDebug && LessVerbose(2)) printf("For CPID %s Verified Magnitude = %f",GlobalCPUMiningCPID.cpid.c_str(),GlobalCPUMiningCPID.Magnitude);
									//Reserved for GRC Speech Synthesis
									msMiningErrors = (msMiningCPID == "INVESTOR" || msPrimaryCPID=="INVESTOR" || msMiningCPID.empty() || msPrimaryCPID.empty()) ? "Staking Interest" : "Boinc Mining";
									GlobalCPUMiningCPID.RSAWeight = GetRSAWeightByCPID(GlobalCPUMiningCPID.cpid);
									GlobalCPUMiningCPID.LastPaymentTime = GetLastPaymentTimeByCPID(GlobalCPUMiningCPID.cpid);
									return GlobalCPUMiningCPID;
									}
								}
							}

					}

				}
			}

		}
		}

		msMiningErrors = (msPrimaryCPID == "INVESTOR") ? "" : "All BOINC projects exhausted.";
		msMiningProject = "INVESTOR";
		msMiningCPID = "INVESTOR";
		mdMiningRAC = 0;
		msENCboincpublickey = "";
		GlobalCPUMiningCPID = GetInitializedGlobalCPUMiningCPID("INVESTOR");
		mdMiningNetworkRAC = 0;
		if (fDebug10) printf("-Investor mode-");

	  	}
		catch (std::exception& e)
		{
			msMiningErrors = "Error obtaining next project.  Error 16172014.";

			printf("Error obtaining next project\r\n");
		}
		catch(...)
		{
			msMiningErrors = "Error obtaining next project.  Error 06172014.";
			printf("Error obtaining next project 2.\r\n");
		}
		return GlobalCPUMiningCPID;

}



// check whether the passed transaction is from us
bool static IsFromMe(CTransaction& tx)
{
    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
        if (pwallet->IsFromMe(tx))
            return true;
    return false;
}

// get the wallet transaction with the given hash (if it exists)
bool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)
{
    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
        if (pwallet->GetTransaction(hashTx,wtx))
            return true;
    return false;
}

// erases transaction with the given hash from all wallets
void static EraseFromWallets(uint256 hash)
{
    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
        pwallet->EraseFromWallet(hash);
}

// make sure all wallets know about the given transaction, in the given block
void SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fConnect)
{
    if (!fConnect)
    {
        // ppcoin: wallets need to refund inputs when disconnecting coinstake
        if (tx.IsCoinStake())
        {
            BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
                if (pwallet->IsFromMe(tx))
                    pwallet->DisableTransaction(tx);
        }
        return;
    }

    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);
}

// notify wallets about a new best chain
void static SetBestChain(const CBlockLocator& loc)
{
    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
        pwallet->SetBestChain(loc);
}

// notify wallets about an updated transaction
void static UpdatedTransaction(const uint256& hashTx)
{
    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
        pwallet->UpdatedTransaction(hashTx);
}

// dump all wallets
void static PrintWallets(const CBlock& block)
{
    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
        pwallet->PrintWallet(block);
}

// notify wallets about an incoming inventory (for request counts)
void static Inventory(const uint256& hash)
{
    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
        pwallet->Inventory(hash);
}

// ask wallets to resend their transactions
void ResendWalletTransactions(bool fForce)
{
    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
        pwallet->ResendWalletTransactions(fForce);
}


double CoinToDouble(double surrogate)
{
	//Converts satoshis to a human double amount
	double coin = (double)surrogate/(double)COIN;
	return coin;
}

double GetTotalBalance()
{
	double total = 0;
    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)
	{
        total = total + pwallet->GetBalance();
		total = total + pwallet->GetStake();
	}
	return total/COIN;
}
//////////////////////////////////////////////////////////////////////////////
//
// mapOrphanTransactions
//

bool AddOrphanTx(const CTransaction& tx)
{
    uint256 hash = tx.GetHash();
    if (mapOrphanTransactions.count(hash))
        return false;

    // Ignore big transactions, to avoid a
    // send-big-orphans memory exhaustion attack. If a peer has a legitimate
    // large transaction with a missing parent then we assume
    // it will rebroadcast it later, after the parent transaction(s)
    // have been mined or received.
    // 10,000 orphans, each of which is at most 5,000 bytes big is
    // at most 500 megabytes of orphans:

    size_t nSize = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);

    if (nSize > 90000)
    {
        if (fDebug3) printf("ignoring large orphan tx (size: %"PRIszu", hash: %s)\n", nSize, hash.ToString().substr(0,10).c_str());
        return false;
    }

    mapOrphanTransactions[hash] = tx;
    BOOST_FOREACH(const CTxIn& txin, tx.vin)
        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);

    if (fDebug) printf("stored orphan tx %s (mapsz %"PRIszu")\n", hash.ToString().substr(0,10).c_str(),   mapOrphanTransactions.size());
    return true;
}

void static EraseOrphanTx(uint256 hash)
{
    if (!mapOrphanTransactions.count(hash))
        return;
    const CTransaction& tx = mapOrphanTransactions[hash];
    BOOST_FOREACH(const CTxIn& txin, tx.vin)
    {
        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);
        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())
            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);
    }
    mapOrphanTransactions.erase(hash);
}

unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)
{
    unsigned int nEvicted = 0;
    while (mapOrphanTransactions.size() > nMaxOrphans)
    {
        // Evict a random orphan:
        uint256 randomhash = GetRandHash();
        map<uint256, CTransaction>::iterator it = mapOrphanTransactions.lower_bound(randomhash);
        if (it == mapOrphanTransactions.end())
            it = mapOrphanTransactions.begin();
        EraseOrphanTx(it->first);
        ++nEvicted;
    }
    return nEvicted;
}



std::string DefaultWalletAddress()
{
	try
	{
		//Gridcoin - Find the default public GRC address (since a user may have many receiving addresses):
		if (sDefaultWalletAddress.length() > 0) return sDefaultWalletAddress;
		string strAccount;
		BOOST_FOREACH(const PAIRTYPE(CTxDestination, string)& item, pwalletMain->mapAddressBook)
		{
    		 const CBitcoinAddress& address = item.first;
			 const std::string& strName = item.second;
			 bool fMine = IsMine(*pwalletMain, address.Get());
			 if (fMine && strName == "Default") 
			 {
				 sDefaultWalletAddress=CBitcoinAddress(address).ToString();
				 return sDefaultWalletAddress;
			 }
		}


		//Cant Find

		BOOST_FOREACH(const PAIRTYPE(CTxDestination, string)& item, pwalletMain->mapAddressBook)
		{
    		 const CBitcoinAddress& address = item.first;
			 //const std::string& strName = item.second;
			 bool fMine = IsMine(*pwalletMain, address.Get());
			 if (fMine)
			 {
				 sDefaultWalletAddress=CBitcoinAddress(address).ToString();
				 return sDefaultWalletAddress;
			 }
		}
	}
	catch (std::exception& e)
	{
		return "ERROR";
	}
    return "NA";
}






//////////////////////////////////////////////////////////////////////////////
//
// CTransaction and CTxIndex
//

bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)
{
    SetNull();
    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))
        return false;
    if (!ReadFromDisk(txindexRet.pos))
        return false;
    if (prevout.n >= vout.size())
    {
        SetNull();
        return false;
    }
    return true;
}

bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)
{
    CTxIndex txindex;
    return ReadFromDisk(txdb, prevout, txindex);
}

bool CTransaction::ReadFromDisk(COutPoint prevout)
{
    CTxDB txdb("r");
    CTxIndex txindex;
    return ReadFromDisk(txdb, prevout, txindex);
}





bool IsStandardTx(const CTransaction& tx)
{
	std::string reason = "";
    if (tx.nVersion > CTransaction::CURRENT_VERSION)
        return false;

    // Treat non-final transactions as non-standard to prevent a specific type
    // of double-spend attack, as well as DoS attacks. (if the transaction
    // can't be mined, the attacker isn't expending resources broadcasting it)
    // Basically we don't want to propagate transactions that can't included in
    // the next block.
    //
    // However, IsFinalTx() is confusing... Without arguments, it uses
    // chainActive.Height() to evaluate nLockTime; when a block is accepted, chainActive.Height()
    // is set to the value of nHeight in the block. However, when IsFinalTx()
    // is called within CBlock::AcceptBlock(), the height of the block *being*
    // evaluated is what is used. Thus if we want to know if a transaction can
    // be part of the *next* block, we need to call IsFinalTx() with one more
    // than chainActive.Height().
    //
    // Timestamps on the other hand don't get any special treatment, because we
    // can't know what timestamp the next block will have, and there aren't
    // timestamp applications where it matters.
    if (!IsFinalTx(tx, nBestHeight + 1)) {
        return false;
    }
    // nTime has different purpose from nLockTime but can be used in similar attacks
    if (tx.nTime > FutureDrift(GetAdjustedTime(), nBestHeight + 1)) {
        return false;
    }

    // Extremely large transactions with lots of inputs can cost the network
    // almost as much to process as they cost the sender in fees, because
    // computing signature hashes is O(ninputs*txsize). Limiting transactions
    // to MAX_STANDARD_TX_SIZE mitigates CPU exhaustion attacks.
    unsigned int sz = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);
    if (sz >= MAX_STANDARD_TX_SIZE)
        return false;

    BOOST_FOREACH(const CTxIn& txin, tx.vin)
    {

		// Biggest 'standard' txin is a 15-of-15 P2SH multisig with compressed
		// keys. (remember the 520 byte limit on redeemScript size) That works
		// out to a (15*(33+1))+3=513 byte redeemScript, 513+1+15*(73+1)=1624
        // bytes of scriptSig, which we round off to 1650 bytes for some minor
		// future-proofing. That's also enough to spend a 20-of-20
		// CHECKMULTISIG scriptPubKey, though such a scriptPubKey is not
		// considered standard)

        if (txin.scriptSig.size() > 1650)
            return false;
        if (!txin.scriptSig.IsPushOnly())
            return false;
        if (fEnforceCanonical && !txin.scriptSig.HasCanonicalPushes()) {
            return false;
        }
    }

    unsigned int nDataOut = 0;
    txnouttype whichType;
    BOOST_FOREACH(const CTxOut& txout, tx.vout) {
        if (!::IsStandard(txout.scriptPubKey, whichType))
            return false;
        if (whichType == TX_NULL_DATA)
            nDataOut++;
        if (txout.nValue == 0)
            return false;
        if (fEnforceCanonical && !txout.scriptPubKey.HasCanonicalPushes()) {
            return false;
        }
    }


	// not more than one data txout per non-data txout is permitted
    // only one data txout is permitted too
    if (nDataOut > 1 && nDataOut > tx.vout.size()/2)
	{
        reason = "multi-op-return";
        return false;
    }


    return true;
}

bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)
{
    AssertLockHeld(cs_main);
    // Time based nLockTime implemented in 0.1.6
    if (tx.nLockTime == 0)
        return true;
    if (nBlockHeight == 0)
        nBlockHeight = nBestHeight;
    if (nBlockTime == 0)
        nBlockTime = GetAdjustedTime();
    if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))
        return true;
    BOOST_FOREACH(const CTxIn& txin, tx.vin)
        if (!txin.IsFinal())
            return false;
    return true;
}

//
// Check transaction inputs, and make sure any
// pay-to-script-hash transactions are evaluating IsStandard scripts
//
// Why bother? To avoid denial-of-service attacks; an attacker
// can submit a standard HASH... OP_EQUAL transaction,
// which will get accepted into blocks. The redemption
// script can be anything; an attacker could use a very
// expensive-to-check-upon-redemption script like:
//   DUP CHECKSIG DROP ... repeated 100 times... OP_1
//
bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const
{
    if (IsCoinBase())
        return true; // Coinbases don't use vin normally

    for (unsigned int i = 0; i < vin.size(); i++)
    {
        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);

        vector<vector<unsigned char> > vSolutions;
        txnouttype whichType;
        // get the scriptPubKey corresponding to this input:
        const CScript& prevScript = prev.scriptPubKey;
        if (!Solver(prevScript, whichType, vSolutions))
            return false;
        int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);
        if (nArgsExpected < 0)
            return false;

        // Transactions with extra stuff in their scriptSigs are
        // non-standard. Note that this EvalScript() call will
        // be quick, because if there are any operations
        // beside "push data" in the scriptSig the
        // IsStandard() call returns false
        vector<vector<unsigned char> > stack;
		if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))            return false;

        if (whichType == TX_SCRIPTHASH)
        {
            if (stack.empty())
                return false;
            CScript subscript(stack.back().begin(), stack.back().end());
            vector<vector<unsigned char> > vSolutions2;
            txnouttype whichType2;
            if (!Solver(subscript, whichType2, vSolutions2))
                return false;
            if (whichType2 == TX_SCRIPTHASH)
                return false;

            int tmpExpected;
            tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);
            if (tmpExpected < 0)
                return false;
            nArgsExpected += tmpExpected;
        }

        if (stack.size() != (unsigned int)nArgsExpected)
            return false;
    }

    return true;
}

unsigned int CTransaction::GetLegacySigOpCount() const
{
    unsigned int nSigOps = 0;
    BOOST_FOREACH(const CTxIn& txin, vin)
    {
        nSigOps += txin.scriptSig.GetSigOpCount(false);
    }
    BOOST_FOREACH(const CTxOut& txout, vout)
    {
        nSigOps += txout.scriptPubKey.GetSigOpCount(false);
    }
    return nSigOps;
}


int CMerkleTx::SetMerkleBranch(const CBlock* pblock)
{
    AssertLockHeld(cs_main);

    CBlock blockTmp;
    if (pblock == NULL)
    {
        // Load the block this tx is in
        CTxIndex txindex;
        if (!CTxDB("r").ReadTxIndex(GetHash(), txindex))
            return 0;
        if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))
            return 0;
        pblock = &blockTmp;
    }

    // Update the tx's hashBlock
    hashBlock = pblock->GetHash();

    // Locate the transaction
    for (nIndex = 0; nIndex < (int)pblock->vtx.size(); nIndex++)
        if (pblock->vtx[nIndex] == *(CTransaction*)this)
            break;
    if (nIndex == (int)pblock->vtx.size())
    {
        vMerkleBranch.clear();
        nIndex = -1;
        printf("ERROR: SetMerkleBranch() : couldn't find tx in block\n");
        return 0;
    }

    // Fill in merkle branch
    vMerkleBranch = pblock->GetMerkleBranch(nIndex);

    // Is the tx in a block that's in the main chain
    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);
    if (mi == mapBlockIndex.end())
        return 0;
    CBlockIndex* pindex = (*mi).second;
    if (!pindex || !pindex->IsInMainChain())
        return 0;

    return pindexBest->nHeight - pindex->nHeight + 1;
}




bool CTransaction::CheckTransaction() const
{
    // Basic checks that don't depend on any context
    if (vin.empty())
        return DoS(10, error("CTransaction::CheckTransaction() : vin empty"));
    if (vout.empty())
        return DoS(10, error("CTransaction::CheckTransaction() : vout empty"));
    // Size limits
    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)
        return DoS(100, error("CTransaction::CheckTransaction() : size limits failed"));

    // Check for negative or overflow output values
    int64_t nValueOut = 0;
    for (unsigned int i = 0; i < vout.size(); i++)
    {
        const CTxOut& txout = vout[i];
        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())
            return DoS(100, error("CTransaction::CheckTransaction() : txout empty for user transaction"));
        if (txout.nValue < 0)
            return DoS(100, error("CTransaction::CheckTransaction() : txout.nValue negative"));
        if (txout.nValue > MAX_MONEY)
            return DoS(100, error("CTransaction::CheckTransaction() : txout.nValue too high"));
        nValueOut += txout.nValue;
        if (!MoneyRange(nValueOut))
            return DoS(100, error("CTransaction::CheckTransaction() : txout total out of range"));
    }

    // Check for duplicate inputs
    set<COutPoint> vInOutPoints;
    BOOST_FOREACH(const CTxIn& txin, vin)
    {
        if (vInOutPoints.count(txin.prevout))
            return false;
        vInOutPoints.insert(txin.prevout);
    }

    if (IsCoinBase())
    {
        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)
            return DoS(100, error("CTransaction::CheckTransaction() : coinbase script size is invalid"));
    }
    else
    {
        BOOST_FOREACH(const CTxIn& txin, vin)
            if (txin.prevout.IsNull())
                return DoS(10, error("CTransaction::CheckTransaction() : prevout is null"));
    }

    return true;
}

int64_t CTransaction::GetMinFee(unsigned int nBlockSize, enum GetMinFee_mode mode, unsigned int nBytes) const
{
    // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE
    int64_t nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;

    unsigned int nNewBlockSize = nBlockSize + nBytes;
    int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;

    // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01
    if (nMinFee < nBaseFee)
    {
        BOOST_FOREACH(const CTxOut& txout, vout)
            if (txout.nValue < CENT)
                nMinFee = nBaseFee;
    }

    // Raise the price as the block approaches full
    if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)
    {
        if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)
            return MAX_MONEY;
        nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);
    }

    if (!MoneyRange(nMinFee))
        nMinFee = MAX_MONEY;
    return nMinFee;
}


bool AcceptToMemoryPool(CTxMemPool& pool, CTransaction &tx, bool* pfMissingInputs)
{
    AssertLockHeld(cs_main);
    if (pfMissingInputs)
        *pfMissingInputs = false;

    if (!tx.CheckTransaction())
        return error("AcceptToMemoryPool : CheckTransaction failed");

    // Coinbase is only valid in a block, not as a loose transaction
    if (tx.IsCoinBase())
        return tx.DoS(100, error("AcceptToMemoryPool : coinbase as individual tx"));

    // ppcoin: coinstake is also only valid in a block, not as a loose transaction
    if (tx.IsCoinStake())
        return tx.DoS(100, error("AcceptToMemoryPool : coinstake as individual tx"));

    // Rather not work on nonstandard transactions (unless -testnet)
    if (!fTestNet && !IsStandardTx(tx))
        return error("AcceptToMemoryPool : nonstandard transaction type");

    // is it already in the memory pool?
    uint256 hash = tx.GetHash();
    if (pool.exists(hash))
        return false;

    // Check for conflicts with in-memory transactions
    CTransaction* ptxOld = NULL;
    {
		LOCK(pool.cs); // protect pool.mapNextTx
		for (unsigned int i = 0; i < tx.vin.size(); i++)
		{
			COutPoint outpoint = tx.vin[i].prevout;
			if (pool.mapNextTx.count(outpoint))
			{
				// Disable replacement feature for now
				return false;

				// Allow replacing with a newer version of the same transaction
				if (i != 0)
					return false;
				ptxOld = pool.mapNextTx[outpoint].ptx;
				if (IsFinalTx(*ptxOld))
					return false;
				if (!tx.IsNewerThan(*ptxOld))
					return false;
				for (unsigned int i = 0; i < tx.vin.size(); i++)
				{
					COutPoint outpoint = tx.vin[i].prevout;
					if (!pool.mapNextTx.count(outpoint) || pool.mapNextTx[outpoint].ptx != ptxOld)
						return false;
				}
				break;
			}
		}
    }

    {
        CTxDB txdb("r");

        // do we already have it?
        if (txdb.ContainsTx(hash))
            return false;

        MapPrevTx mapInputs;
        map<uint256, CTxIndex> mapUnused;
        bool fInvalid = false;
        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))
        {
            if (fInvalid)
                return error("AcceptToMemoryPool : FetchInputs found invalid tx %s", hash.ToString().substr(0,10).c_str());
            if (pfMissingInputs)
                *pfMissingInputs = true;
            return false;
        }

        // Check for non-standard pay-to-script-hash in inputs
        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)
            return error("AcceptToMemoryPool : nonstandard transaction input");

        // Note: if you modify this code to accept non-standard transactions, then
        // you should add code here to check that the transaction does a
        // reasonable number of ECDSA signature verifications.

        int64_t nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();
        unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);

        // Don't accept it if it can't get into a block
        int64_t txMinFee = tx.GetMinFee(1000, GMF_RELAY, nSize);
        if (nFees < txMinFee)
            return error("AcceptToMemoryPool : not enough fees %s, %"PRId64" < %"PRId64,
                         hash.ToString().c_str(),
                         nFees, txMinFee);

        // Continuously rate-limit free transactions
        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to
        // be annoying or make others' transactions take longer to confirm.
        if (nFees < MIN_RELAY_TX_FEE)
        {
            static CCriticalSection cs;
            static double dFreeCount;
            static int64_t nLastTime;
            int64_t nNow =  GetAdjustedTime();

            {
                LOCK(pool.cs);
                // Use an exponentially decaying ~10-minute window:
                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));
                nLastTime = nNow;
                // -limitfreerelay unit is thousand-bytes-per-minute
                // At default rate it would take over a month to fill 1GB
                if (dFreeCount > GetArg("-limitfreerelay", 15)*10*1000 && !IsFromMe(tx))
                    return error("AcceptToMemoryPool : free transaction rejected by rate limiter");
                if (fDebug)
                    printf("Rate limit dFreeCount: %g => %g\n", dFreeCount, dFreeCount+nSize);
                dFreeCount += nSize;
            }
        }

        // Check against previous transactions
        // This is done last to help prevent CPU exhaustion denial-of-service attacks.
        if (!tx.ConnectInputs(txdb, mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))
        {
			// If this happens repeatedly, purge peers
			if (TimerMain("AcceptToMemoryPool", 20))
			{
				CleanInboundConnections(true);
			}	
			if (fDebug)
			{
				return error("AcceptToMemoryPool : Unable to Connect Inputs %s", hash.ToString().c_str());
			}
			else
			{
				return false;
			}
	    }
    }

    // Store transaction in memory
    {
        LOCK(pool.cs);
        if (ptxOld)
        {
            printf("AcceptToMemoryPool : replacing tx %s with new version\n", ptxOld->GetHash().ToString().c_str());
            pool.remove(*ptxOld);
        }
        pool.addUnchecked(hash, tx);
    }

    ///// are we sure this is ok when loading transactions or restoring block txes
    // If updated, erase old tx from wallet
    if (ptxOld)
        EraseFromWallets(ptxOld->GetHash());
	if (fDebug)     printf("AcceptToMemoryPool : accepted %s (poolsz %"PRIszu")\n",           hash.ToString().c_str(),           pool.mapTx.size());
    return true;
}

bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)
{
    // Add to memory pool without checking anything.  Don't call this directly,
    // call AcceptToMemoryPool to properly check the transaction first.
    {
        mapTx[hash] = tx;
        for (unsigned int i = 0; i < tx.vin.size(); i++)
            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);
        nTransactionsUpdated++;
    }
    return true;
}


bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)
{
    // Remove transaction from memory pool
    {
        LOCK(cs);
        uint256 hash = tx.GetHash();
        if (mapTx.count(hash))
        {
            if (fRecursive) {
                for (unsigned int i = 0; i < tx.vout.size(); i++) {
                    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));
                    if (it != mapNextTx.end())
                        remove(*it->second.ptx, true);
                }
            }
            BOOST_FOREACH(const CTxIn& txin, tx.vin)
                mapNextTx.erase(txin.prevout);
            mapTx.erase(hash);
            nTransactionsUpdated++;
        }
    }
    return true;
}

bool CTxMemPool::removeConflicts(const CTransaction &tx)
{
    // Remove transactions which depend on inputs of tx, recursively
    LOCK(cs);
    BOOST_FOREACH(const CTxIn &txin, tx.vin) {
        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);
        if (it != mapNextTx.end()) {
            const CTransaction &txConflict = *it->second.ptx;
            if (txConflict != tx)
                remove(txConflict, true);
        }
    }
    return true;
}

void CTxMemPool::clear()
{
    LOCK(cs);
    mapTx.clear();
    mapNextTx.clear();
    ++nTransactionsUpdated;
}

void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)
{
    vtxid.clear();

    LOCK(cs);
    vtxid.reserve(mapTx.size());
    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)
        vtxid.push_back((*mi).first);
}




int CMerkleTx::GetDepthInMainChainINTERNAL(CBlockIndex* &pindexRet) const
{
    if (hashBlock == 0 || nIndex == -1)
        return 0;
    AssertLockHeld(cs_main);

    // Find the block it claims to be in
    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);
    if (mi == mapBlockIndex.end())
        return 0;
    CBlockIndex* pindex = (*mi).second;
    if (!pindex || !pindex->IsInMainChain())
        return 0;

    // Make sure the merkle branch connects to this block
    if (!fMerkleVerified)
    {
        if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)
            return 0;
        fMerkleVerified = true;
    }

    pindexRet = pindex;
    return pindexBest->nHeight - pindex->nHeight + 1;
}

int CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const
{
    AssertLockHeld(cs_main);
    int nResult = GetDepthInMainChainINTERNAL(pindexRet);
    if (nResult == 0 && !mempool.exists(GetHash()))
        return -1; // Not in chain, not in mempool

    return nResult;
}

int CMerkleTx::GetBlocksToMaturity() const
{
    if (!(IsCoinBase() || IsCoinStake()))
        return 0;
    return max(0, (nCoinbaseMaturity+10) - GetDepthInMainChain());
}


bool CMerkleTx::AcceptToMemoryPool()
{
    return ::AcceptToMemoryPool(mempool, *this, NULL);
}



bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb)
{

    {
        // Add previous supporting transactions first
        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)
        {
            if (!(tx.IsCoinBase() || tx.IsCoinStake()))
            {
                uint256 hash = tx.GetHash();
                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))
                    tx.AcceptToMemoryPool();
            }
        }
        return AcceptToMemoryPool();
    }
    return false;
}

bool CWalletTx::AcceptWalletTransaction()
{
    CTxDB txdb("r");
    return AcceptWalletTransaction(txdb);
}

int CTxIndex::GetDepthInMainChain() const
{
    // Read block header
    CBlock block;
    if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))
        return 0;
    // Find the block in the index
    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());
    if (mi == mapBlockIndex.end())
        return 0;
    CBlockIndex* pindex = (*mi).second;
    if (!pindex || !pindex->IsInMainChain())
        return 0;
    return 1 + nBestHeight - pindex->nHeight;
}

// Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock
bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)
{
    {
        LOCK(cs_main);
        {
            if (mempool.lookup(hash, tx))
            {
                return true;
            }
        }
        CTxDB txdb("r");
        CTxIndex txindex;
        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))
        {
            CBlock block;
            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))
                hashBlock = block.GetHash();
            return true;
        }
    }
    return false;
}






//////////////////////////////////////////////////////////////////////////////
//
// CBlock and CBlockIndex
//

static CBlockIndex* pblockindexFBBHLast;
CBlockIndex* FindBlockByHeight(int nHeight)
{
    CBlockIndex *pblockindex;
    if (nHeight < nBestHeight / 2)
        pblockindex = pindexGenesisBlock;
    else
        pblockindex = pindexBest;
    if (pblockindexFBBHLast && abs(nHeight - pblockindex->nHeight) > abs(nHeight - pblockindexFBBHLast->nHeight))
        pblockindex = pblockindexFBBHLast;
    while (pblockindex->nHeight > nHeight)
        pblockindex = pblockindex->pprev;
    while (pblockindex->nHeight < nHeight)
        pblockindex = pblockindex->pnext;
    pblockindexFBBHLast = pblockindex;
    return pblockindex;
}


CBlockIndex* RPCFindBlockByHeight(int nHeight)
{
	//This keeps the threads separated and ensures pointers are in distinct locations
    CBlockIndex *RPCpblockindex;
    if (nHeight < nBestHeight / 2)
        RPCpblockindex = pindexGenesisBlock;
    else
        RPCpblockindex = pindexBest;
    while (RPCpblockindex->nHeight > nHeight)
	{
        RPCpblockindex = RPCpblockindex->pprev;
	}
    while (RPCpblockindex->nHeight < nHeight)
	{
        RPCpblockindex = RPCpblockindex->pnext;
	}
    return RPCpblockindex;
}

CBlockIndex* MainFindBlockByHeight(int nHeight)
{
    CBlockIndex *Mainpblockindex;
    if (nHeight < nBestHeight / 2)
        Mainpblockindex = pindexGenesisBlock;
    else
        Mainpblockindex = pindexBest;
    while (Mainpblockindex->nHeight > nHeight)
	{
        Mainpblockindex = Mainpblockindex->pprev;
	}
    while (Mainpblockindex->nHeight < nHeight)
	{
        Mainpblockindex = Mainpblockindex->pnext;
	}
    return Mainpblockindex;
}



bool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)
{
    if (!fReadTransactions)
    {
        *this = pindex->GetBlockHeader();
        return true;
    }
    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))
        return false;
    if (GetHash() != pindex->GetBlockHash())
        return error("CBlock::ReadFromDisk() : GetHash() doesn't match index");
    return true;
}

uint256 static GetOrphanRoot(const CBlock* pblock)
{
    // Work back to the first block in the orphan chain
    while (mapOrphanBlocks.count(pblock->hashPrevBlock))
        pblock = mapOrphanBlocks[pblock->hashPrevBlock];
    return pblock->GetHash();
}

// ppcoin: find block wanted by given orphan block
uint256 WantedByOrphan(const CBlock* pblockOrphan)
{
    // Work back to the first block in the orphan chain
    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))
        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];
    return pblockOrphan->hashPrevBlock;
}


static CBigNum GetProofOfStakeLimit(int nHeight)
{
    if (IsProtocolV2(nHeight))
        return bnProofOfStakeLimitV2;
    else
        return bnProofOfStakeLimit;
}


double CalculatedMagnitude(int64_t locktime,bool bUseLederstrumpf)
{
	// Get neural network magnitude:
	std::string cpid = "";
	if (GlobalCPUMiningCPID.initialized && !GlobalCPUMiningCPID.cpid.empty()) cpid = GlobalCPUMiningCPID.cpid;
	StructCPID stDPOR = GetInitializedStructCPID2(cpid,mvDPOR);
	return bUseLederstrumpf ? LederstrumpfMagnitude2(stDPOR.Magnitude,locktime) : stDPOR.Magnitude;
}

double CalculatedMagnitude2(std::string cpid, int64_t locktime,bool bUseLederstrumpf)
{
	// Get neural network magnitude:
	StructCPID stDPOR = GetInitializedStructCPID2(cpid,mvDPOR);
	return bUseLederstrumpf ? LederstrumpfMagnitude2(stDPOR.Magnitude,locktime) : stDPOR.Magnitude;
}



// miner's coin base reward
int64_t GetProofOfWorkReward(int64_t nFees, int64_t locktime, int64_t height)
{
	//NOTE: THIS REWARD IS ONLY USED IN THE POW PHASE (Block < 8000):
    int64_t nSubsidy = CalculatedMagnitude(locktime,true) * COIN;
    if (fDebug && GetBoolArg("-printcreation"))
        printf("GetProofOfWorkReward() : create=%s nSubsidy=%"PRId64"\n", FormatMoney(nSubsidy).c_str(), nSubsidy);
	if (nSubsidy < (30*COIN)) nSubsidy=30*COIN;
	//Gridcoin Foundation Block:
	if (height==10)
	{
		nSubsidy = nGenesisSupply * COIN;
	}
	if (fTestNet) nSubsidy += 1000*COIN;

    return nSubsidy + nFees;
}


int64_t GetProofOfWorkMaxReward(int64_t nFees, int64_t locktime, int64_t height)
{
	int64_t nSubsidy = (GetMaximumBoincSubsidy(locktime)+1) * COIN;
	if (height==10)
	{
		//R.Halford: 10-11-2014: Gridcoin Foundation Block:
		//Note: Gridcoin Classic emitted these coins.  So we had to add them to block 10.  The coins were burned then given back to the owners that mined them in classic (as research coins).
		nSubsidy = nGenesisSupply * COIN;
	}

	if (fTestNet) nSubsidy += 1000*COIN;
    return nSubsidy + nFees;
}

//Survey Results: Start inflation rate: 9%, end=1%, 30 day steps, 9 steps, mag multiplier start: 2, mag end .3, 9 steps
int64_t GetMaximumBoincSubsidy(int64_t nTime)
{
	// Gridcoin Global Daily Maximum Researcher Subsidy Schedule
	int MaxSubsidy = 500;
    if (nTime >= 1410393600 && nTime <= 1417305600) MaxSubsidy = 	500; // between inception  and 11-30-2014
	if (nTime >= 1417305600 && nTime <= 1419897600) MaxSubsidy = 	400; // between 11-30-2014 and 12-30-2014
	if (nTime >= 1419897600 && nTime <= 1422576000) MaxSubsidy = 	400; // between 12-30-2014 and 01-30-2015
	if (nTime >= 1422576000 && nTime <= 1425254400) MaxSubsidy = 	300; // between 01-30-2015 and 02-28-2015
	if (nTime >= 1425254400 && nTime <= 1427673600) MaxSubsidy = 	250; // between 02-28-2015 and 03-30-2015
	if (nTime >= 1427673600 && nTime <= 1430352000) MaxSubsidy = 	200; // between 03-30-2015 and 04-30-2015
	if (nTime >= 1430352000 && nTime <= 1438310876) MaxSubsidy = 	150; // between 05-01-2015 and 07-31-2015
	if (nTime >= 1438310876 && nTime <= 1445309276) MaxSubsidy = 	100; // between 08-01-2015 and 10-20-2015
	if (nTime >= 1445309276 && nTime <= 1447977700) MaxSubsidy = 	 75; // between 10-20-2015 and 11-20-2015
	if (nTime > 1447977700)                         MaxSubsidy =   	 50; // from  11-20-2015 forever
    return MaxSubsidy+.5;  //The .5 allows for fractional amounts after the 4th decimal place (used to store the POR indicator)
}

int64_t GetCoinYearReward(int64_t nTime)
{
	// Gridcoin Global Interest Rate Schedule
	int64_t INTEREST = 9;
   	if (nTime >= 1410393600 && nTime <= 1417305600) INTEREST = 	 9 * CENT; // 09% between inception  and 11-30-2014
	if (nTime >= 1417305600 && nTime <= 1419897600) INTEREST = 	 8 * CENT; // 08% between 11-30-2014 and 12-30-2014
	if (nTime >= 1419897600 && nTime <= 1422576000) INTEREST = 	 8 * CENT; // 08% between 12-30-2014 and 01-30-2015
	if (nTime >= 1422576000 && nTime <= 1425254400) INTEREST = 	 7 * CENT; // 07% between 01-30-2015 and 02-30-2015
	if (nTime >= 1425254400 && nTime <= 1427673600) INTEREST = 	 6 * CENT; // 06% between 02-30-2015 and 03-30-2015
	if (nTime >= 1427673600 && nTime <= 1430352000) INTEREST = 	 5 * CENT; // 05% between 03-30-2015 and 04-30-2015
	if (nTime >= 1430352000 && nTime <= 1438310876) INTEREST =   4 * CENT; // 04% between 05-01-2015 and 07-31-2015
	if (nTime >= 1438310876 && nTime <= 1447977700) INTEREST =   3 * CENT; // 03% between 08-01-2015 and 11-20-2015
	if (nTime > 1447977700)                         INTEREST = 1.5 * CENT; //1.5% from 11-21-2015 forever
	return INTEREST;
}

double GetMagnitudeMultiplier(int64_t nTime)
{
	// Gridcoin Global Resarch Subsidy Multiplier Schedule
	double magnitude_multiplier = 2;
	if (nTime >= 1410393600 && nTime <= 1417305600) magnitude_multiplier =    2;  // between inception and 11-30-2014
	if (nTime >= 1417305600 && nTime <= 1419897600) magnitude_multiplier =  1.5;  // between 11-30-2014 and 12-30-2014
	if (nTime >= 1419897600 && nTime <= 1422576000) magnitude_multiplier =  1.5;  // between 12-30-2014 and 01-30-2015
	if (nTime >= 1422576000 && nTime <= 1425254400) magnitude_multiplier =    1;  // between 01-30-2015 and 02-30-2015
	if (nTime >= 1425254400 && nTime <= 1427673600) magnitude_multiplier =   .9;  // between 02-30-2015 and 03-30-2015
	if (nTime >= 1427673600 && nTime <= 1430352000) magnitude_multiplier =   .8;  // between 03-30-2015 and 04-30-2015
    if (nTime >= 1430352000 && nTime <= 1438310876) magnitude_multiplier =   .7;  // between 05-01-2015 and 07-31-2015
	if (nTime >= 1438310876 && nTime <= 1447977700) magnitude_multiplier =  .60;  // between 08-01-2015 and 11-20-2015
	if (nTime > 1447977700)                         magnitude_multiplier =  .50;  // from 11-21-2015  forever
	return magnitude_multiplier;
}


int64_t GetProofOfStakeMaxReward(int64_t nCoinAge, int64_t nFees, int64_t locktime)
{
	int64_t nInterest = nCoinAge * GetCoinYearReward(locktime) * 33 / (365 * 33 + 8);
	nInterest += 10*COIN;
	int64_t nBoinc    = (GetMaximumBoincSubsidy(locktime)+1) * COIN;
	int64_t nSubsidy  = nInterest + nBoinc;
    return nSubsidy + nFees;
}

double GetProofOfResearchReward(std::string cpid, bool VerifyingBlock)
{

		StructCPID mag = GetInitializedStructCPID2(cpid,mvMagnitudes);

		if (!mag.initialized) return 0;
		double owed = (mag.owed*1.0);
		if (owed < 0) owed = 0;
		// Coarse Payment Rule (helps prevent sync problems):
		if (!VerifyingBlock)
		{
			//If owed less than 4% of max subsidy, assess at 0:
			if (owed < (GetMaximumBoincSubsidy(GetAdjustedTime())/50))
			{
				owed = 0;
			}
			//Coarse payment rule:
			if (mag.totalowed > (GetMaximumBoincSubsidy(GetAdjustedTime())*2))
			{
				//If owed more than 2* Max Block, pay normal amount
	            owed = (owed*1);
			}
			else
			{
				owed = owed/2;
			}

			if (owed > (GetMaximumBoincSubsidy(GetAdjustedTime()))) owed = GetMaximumBoincSubsidy(GetAdjustedTime());


		}
		//End of Coarse Payment Rule
		return owed * COIN;
}


// miner's coin stake reward based on coin age spent (coin-days)

int64_t GetProofOfStakeReward(int64_t nCoinAge, int64_t nFees, std::string cpid,
	bool VerifyingBlock, int VerificationPhase, int64_t nTime, CBlockIndex* pindexLast, std::string operation,
	double& OUT_POR, double& OUT_INTEREST, double& dAccrualAge, double& dMagnitudeUnit, double& AvgMagnitude)
{

	// Non Research Age - RSA Mode - Legacy (before 10-20-2015)
	if (!IsResearchAgeEnabled(pindexLast->nHeight))
	{
			int64_t nInterest = nCoinAge * GetCoinYearReward(nTime) * 33 / (365 * 33 + 8);
			int64_t nBoinc    = GetProofOfResearchReward(cpid,VerifyingBlock);
			int64_t nSubsidy  = nInterest + nBoinc;
			if (fDebug10 || GetBoolArg("-printcreation"))
			{
				printf("GetProofOfStakeReward(): create=%s nCoinAge=%"PRId64" nBoinc=%"PRId64"   \n",
				FormatMoney(nSubsidy).c_str(), nCoinAge, nBoinc);
			}
			int64_t maxStakeReward1 = GetProofOfStakeMaxReward(nCoinAge, nFees, nTime);
			int64_t maxStakeReward2 = GetProofOfStakeMaxReward(nCoinAge, nFees, GetAdjustedTime());
			int64_t maxStakeReward = Floor(maxStakeReward1,maxStakeReward2);
			if ((nSubsidy+nFees) > maxStakeReward) nSubsidy = maxStakeReward-nFees;
			int64_t nTotalSubsidy = nSubsidy + nFees;
			if (nBoinc > 1)
			{
				std::string sTotalSubsidy = RoundToString(CoinToDouble(nTotalSubsidy)+.00000123,8);
				if (sTotalSubsidy.length() > 7)
				{
					sTotalSubsidy = sTotalSubsidy.substr(0,sTotalSubsidy.length()-4) + "0124";
					nTotalSubsidy = cdbl(sTotalSubsidy,8)*COIN;
				}
			}

			OUT_POR = CoinToDouble(nBoinc);
			OUT_INTEREST = CoinToDouble(nInterest);
			return nTotalSubsidy;
	}
	else
	{
			// Research Age Subsidy - PROD
		    int64_t nBoinc = ComputeResearchAccrual(nTime, cpid, operation, pindexLast, VerifyingBlock, VerificationPhase, dAccrualAge, dMagnitudeUnit, AvgMagnitude);
			int64_t nInterest = nCoinAge * GetCoinYearReward(nTime) * 33 / (365 * 33 + 8);

			// TestNet: For any subsidy < 30 day duration, ensure 100% that we have a start magnitude and an end magnitude, otherwise make subsidy 0 : PASS
			// TestNet: For any subsidy > 30 day duration, ensure 100% that we have a midpoint magnitude in Every Period, otherwise, make subsidy 0 : In Test as of 09-06-2015
			// TestNet: Ensure no magnitudes are out of bounds to ensure we do not generate an insane payment : PASS (Lifetime PPD takes care of this)
			// TestNet: Any subsidy with a duration wider than 6 months should not be paid : PASS

			int64_t maxStakeReward = GetMaximumBoincSubsidy(nTime) * COIN * 255;

			if (nBoinc > maxStakeReward) nBoinc = maxStakeReward;
			int64_t nSubsidy = nInterest + nBoinc;

			if (fDebug10 || GetBoolArg("-printcreation"))
			{
				printf("GetProofOfStakeReward(): create=%s nCoinAge=%"PRId64" nBoinc=%"PRId64"   \n",
				FormatMoney(nSubsidy).c_str(), nCoinAge, nBoinc);
			}

			int64_t nTotalSubsidy = nSubsidy + nFees;
			if (nBoinc > 1)
			{
				std::string sTotalSubsidy = RoundToString(CoinToDouble(nTotalSubsidy)+.00000123,8);
				if (sTotalSubsidy.length() > 7)
				{
					sTotalSubsidy = sTotalSubsidy.substr(0,sTotalSubsidy.length()-4) + "0124";
					nTotalSubsidy = cdbl(sTotalSubsidy,8)*COIN;
				}
			}

			OUT_POR = CoinToDouble(nBoinc);
			OUT_INTEREST = CoinToDouble(nInterest);
			return nTotalSubsidy;

	}
}



static const int64_t nTargetTimespan = 16 * 60;  // 16 mins

//
// maximum nBits value could possible be required nTime after
//
unsigned int ComputeMaxBits(CBigNum bnTargetLimit, unsigned int nBase, int64_t nTime)
{
    CBigNum bnResult;
    bnResult.SetCompact(nBase);
    bnResult *= 2;
    while (nTime > 0 && bnResult < bnTargetLimit)
    {
        // Maximum 200% adjustment per day...
        bnResult *= 2;
        nTime -= 24 * 60 * 60;
    }
    if (bnResult > bnTargetLimit)
        bnResult = bnTargetLimit;
    return bnResult.GetCompact();
}

//
// minimum amount of work that could possibly be required nTime after
// minimum proof-of-work required was nBase
//
unsigned int ComputeMinWork(unsigned int nBase, int64_t nTime)
{
    return ComputeMaxBits(bnProofOfWorkLimit, nBase, nTime);
}

//
// minimum amount of stake that could possibly be required nTime after
// minimum proof-of-stake required was nBase
//
unsigned int ComputeMinStake(unsigned int nBase, int64_t nTime, unsigned int nBlockTime)
{
    return ComputeMaxBits(bnProofOfStakeLimit, nBase, nTime);
}


// ppcoin: find last block index up to pindex
const CBlockIndex* GetLastBlockIndex(const CBlockIndex* pindex, bool fProofOfStake)
{
    while (pindex && pindex->pprev && (pindex->IsProofOfStake() != fProofOfStake))
        pindex = pindex->pprev;
    return pindex;
}


//Find prior block hash
uint256 GetBlockHash256(const CBlockIndex* pindex_hash)
{
	if (pindex_hash == NULL) return 0;
	if (!pindex_hash) return 0;
	return pindex_hash->GetBlockHash();
}

static unsigned int GetNextTargetRequiredV1(const CBlockIndex* pindexLast, bool fProofOfStake)
{
    CBigNum bnTargetLimit = fProofOfStake ? bnProofOfStakeLimit : bnProofOfWorkLimit;

    if (pindexLast == NULL)
        return bnTargetLimit.GetCompact(); // genesis block

    const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake);
    if (pindexPrev->pprev == NULL)
        return bnTargetLimit.GetCompact(); // first block
    const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev->pprev, fProofOfStake);
    if (pindexPrevPrev->pprev == NULL)
        return bnTargetLimit.GetCompact(); // second block

    int64_t nTargetSpacing = GetTargetSpacing(pindexLast->nHeight);
    int64_t nActualSpacing = pindexPrev->GetBlockTime() - pindexPrevPrev->GetBlockTime();

    // ppcoin: target change every block
    // ppcoin: retarget with exponential moving toward target spacing
    CBigNum bnNew;
    bnNew.SetCompact(pindexPrev->nBits);
    int64_t nInterval = nTargetTimespan / nTargetSpacing;
    bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing);
    bnNew /= ((nInterval + 1) * nTargetSpacing);

    if (bnNew > bnTargetLimit)
        bnNew = bnTargetLimit;

    return bnNew.GetCompact();
}

static unsigned int GetNextTargetRequiredV2(const CBlockIndex* pindexLast, bool fProofOfStake)
{
    CBigNum bnTargetLimit = fProofOfStake ? GetProofOfStakeLimit(pindexLast->nHeight) : bnProofOfWorkLimit;

    if (pindexLast == NULL)
        return bnTargetLimit.GetCompact(); // genesis block

    const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake);
    if (pindexPrev->pprev == NULL)
        return bnTargetLimit.GetCompact(); // first block
    const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev->pprev, fProofOfStake);
    if (pindexPrevPrev->pprev == NULL)
        return bnTargetLimit.GetCompact(); // second block

    int64_t nTargetSpacing = GetTargetSpacing(pindexLast->nHeight);
    int64_t nActualSpacing = pindexPrev->GetBlockTime() - pindexPrevPrev->GetBlockTime();
    if (nActualSpacing < 0)
        nActualSpacing = nTargetSpacing;

    // ppcoin: target change every block
    // ppcoin: retarget with exponential moving toward target spacing
    CBigNum bnNew;
    bnNew.SetCompact(pindexPrev->nBits);

	//Gridcoin - Reset Diff to 1 on 12-19-2014 (R Halford) - Diff sticking at 2065 due to many incompatible features
	if (pindexLast->nHeight >= 91387 && pindexLast->nHeight <= 91500)
	{
		    return bnTargetLimit.GetCompact();
	}

	//1-14-2015 R Halford - Make diff reset to zero after periods of exploding diff:
	double PORDiff = GetDifficulty(GetLastBlockIndex(pindexBest, true));
	if (PORDiff > 900000)
	{
		    return bnTargetLimit.GetCompact();
	}


	//Since our nTargetTimespan is (16 * 60) or 16 mins and our TargetSpacing = 64, the nInterval = 15 min

    int64_t nInterval = nTargetTimespan / nTargetSpacing;
    bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing);
    bnNew /= ((nInterval + 1) * nTargetSpacing);

    if (bnNew <= 0 || bnNew > bnTargetLimit)
	{
	    bnNew = bnTargetLimit;
	}

    return bnNew.GetCompact();
}

unsigned int GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake)
{
	//After block 89600, new diff algorithm is used
    if (pindexLast->nHeight < 89600)
        return GetNextTargetRequiredV1(pindexLast, fProofOfStake);
    else
        return GetNextTargetRequiredV2(pindexLast, fProofOfStake);
}

bool CheckProofOfWork(uint256 hash, unsigned int nBits)
{
    CBigNum bnTarget;
    bnTarget.SetCompact(nBits);

    // Check range
    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)
        return error("CheckProofOfWork() : nBits below minimum work");

    // Check proof of work matches claimed amount
    if (hash > bnTarget.getuint256())
        return error("CheckProofOfWork() : hash doesn't match nBits");

    return true;
}

// Return maximum amount of blocks that other nodes claim to have
int GetNumBlocksOfPeers()
{
	if (IsLockTimeWithinMinutes(nLastCalculatedMedianPeerCount,1))
	{
		return nLastMedianPeerCount;
	}
	nLastCalculatedMedianPeerCount = GetAdjustedTime();
	nLastMedianPeerCount = std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());
    return nLastMedianPeerCount;
}

bool IsInitialBlockDownload()
{
    LOCK(cs_main);
    if (pindexBest == NULL || nBestHeight < GetNumBlocksOfPeers())
        return true;
    static int64_t nLastUpdate;
    static CBlockIndex* pindexLastBest;
    if (pindexBest != pindexLastBest)
    {
        pindexLastBest = pindexBest;
        nLastUpdate =  GetAdjustedTime();
    }
    return ( GetAdjustedTime() - nLastUpdate < 15 &&
            pindexBest->GetBlockTime() <  GetAdjustedTime() - 8 * 60 * 60);
}

void static InvalidChainFound(CBlockIndex* pindexNew)
{
    if (pindexNew->nChainTrust > nBestInvalidTrust)
    {
        nBestInvalidTrust = pindexNew->nChainTrust;
        CTxDB().WriteBestInvalidTrust(CBigNum(nBestInvalidTrust));
        uiInterface.NotifyBlocksChanged();
    }

    uint256 nBestInvalidBlockTrust = pindexNew->nChainTrust - pindexNew->pprev->nChainTrust;
    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;

    printf("InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%"PRId64"  date=%s\n",
      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,
      CBigNum(pindexNew->nChainTrust).ToString().c_str(), nBestInvalidBlockTrust.Get64(),
      DateTimeStrFormat("%x %H:%M:%S", pindexNew->GetBlockTime()).c_str());
    printf("InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%"PRId64"  date=%s\n",
      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,
      CBigNum(pindexBest->nChainTrust).ToString().c_str(),
      nBestBlockTrust.Get64(),
      DateTimeStrFormat("%x %H:%M:%S", pindexBest->GetBlockTime()).c_str());
}


void CBlock::UpdateTime(const CBlockIndex* pindexPrev)
{
    nTime = max(GetBlockTime(), GetAdjustedTime());
}



bool CTransaction::DisconnectInputs(CTxDB& txdb)
{
    // Relinquish previous transactions' spent pointers
    if (!IsCoinBase())
    {
        BOOST_FOREACH(const CTxIn& txin, vin)
        {
            COutPoint prevout = txin.prevout;
            // Get prev txindex from disk
            CTxIndex txindex;
            if (!txdb.ReadTxIndex(prevout.hash, txindex))
                return error("DisconnectInputs() : ReadTxIndex failed");

            if (prevout.n >= txindex.vSpent.size())
                return error("DisconnectInputs() : prevout.n out of range");

            // Mark outpoint as not spent
            txindex.vSpent[prevout.n].SetNull();

            // Write back
            if (!txdb.UpdateTxIndex(prevout.hash, txindex))
                return error("DisconnectInputs() : UpdateTxIndex failed");
        }
    }

    // Remove transaction from index
    // This can fail if a duplicate of this transaction was in a chain that got
    // reorganized away. This is only possible if this transaction was completely
    // spent, so erasing it would be a no-op anyway.
    txdb.EraseTxIndex(*this);

    return true;
}


bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,
                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)
{
    // FetchInputs can return false either because we just haven't seen some inputs
    // (in which case the transaction should be stored as an orphan)
    // or because the transaction is malformed (in which case the transaction should
    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.
    fInvalid = false;

    if (IsCoinBase())
        return true; // Coinbase transactions have no inputs to fetch.

    for (unsigned int i = 0; i < vin.size(); i++)
    {
        COutPoint prevout = vin[i].prevout;
        if (inputsRet.count(prevout.hash))
            continue; // Got it already

        // Read txindex
        CTxIndex& txindex = inputsRet[prevout.hash].first;
        bool fFound = true;
        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))
        {
            // Get txindex from current proposed changes
            txindex = mapTestPool.find(prevout.hash)->second;
        }
        else
        {
            // Read txindex from txdb
            fFound = txdb.ReadTxIndex(prevout.hash, txindex);
        }
        if (!fFound && (fBlock || fMiner))
            return fMiner ? false : error("FetchInputs() : %s prev tx %s index entry not found", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());

        // Read txPrev
        CTransaction& txPrev = inputsRet[prevout.hash].second;
        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))
        {
            // Get prev tx from single transactions in memory
            if (!mempool.lookup(prevout.hash, txPrev))
			{
				if (fDebug) printf("FetchInputs() : %s mempool Tx prev not found %s", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());
				return false;
			}
            if (!fFound)
                txindex.vSpent.resize(txPrev.vout.size());
        }
        else
        {
            // Get prev tx from disk
            if (!txPrev.ReadFromDisk(txindex.pos))
                return error("FetchInputs() : %s ReadFromDisk prev tx %s failed", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());
        }
    }

    // Make sure all prevout.n indexes are valid:
    for (unsigned int i = 0; i < vin.size(); i++)
    {
        const COutPoint prevout = vin[i].prevout;
        assert(inputsRet.count(prevout.hash) != 0);
        const CTxIndex& txindex = inputsRet[prevout.hash].first;
        const CTransaction& txPrev = inputsRet[prevout.hash].second;
        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())
        {
            // Revisit this if/when transaction replacement is implemented and allows
            // adding inputs:
            fInvalid = true;
            return DoS(100, error("FetchInputs() : %s prevout.n out of range %d %"PRIszu" %"PRIszu" prev tx %s\n%s", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));
        }
    }

    return true;
}

const CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const
{
    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);
    if (mi == inputs.end())
        throw std::runtime_error("CTransaction::GetOutputFor() : prevout.hash not found");

    const CTransaction& txPrev = (mi->second).second;
    if (input.prevout.n >= txPrev.vout.size())
        throw std::runtime_error("CTransaction::GetOutputFor() : prevout.n out of range");

    return txPrev.vout[input.prevout.n];
}





void WriteStringToFile(const boost::filesystem::path &path, std::string sOut)
{
    FILE* file = fopen(path.string().c_str(), "w");
    if (file)
    {
        fprintf(file, "%s\r\n", sOut.c_str());
        fclose(file);
    }
}




std::vector<std::string> &split_bychar(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}


std::vector<std::string> split_bychar(const std::string &s, char delim)
{
    std::vector<std::string> elems;
    split_bychar(s, delim, elems);
    return elems;
}


std::vector<std::string> split(std::string s, std::string delim)
{
	//Split a std::string by a std::string delimiter into a vector of strings:
	size_t pos = 0;
	std::string token;
	std::vector<std::string> elems;
	while ((pos = s.find(delim)) != std::string::npos)
	{
		token = s.substr(0, pos);
		elems.push_back(token);
		s.erase(0, pos + delim.length());
	}
	elems.push_back(s);
	return elems;

}



int64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const
{
    if (IsCoinBase())
        return 0;

    int64_t nResult = 0;
    for (unsigned int i = 0; i < vin.size(); i++)
    {
        nResult += GetOutputFor(vin[i], inputs).nValue;
    }
    return nResult;

}


double PreviousBlockAge()
{
    	if (nBestHeight < 10) return 99999;
		if (IsLockTimeWithinMinutes(nLastCalculatedMedianTimePast,1))
		{
			return nLastBlockAge;
		}
		nLastCalculatedMedianTimePast = GetAdjustedTime();
	    // Returns the time in seconds since the last block:
		double nTime = max(pindexBest->GetMedianTimePast()+1, GetAdjustedTime());
		double nActualTimespan = nTime - pindexBest->pprev->GetBlockTime();
		nLastBlockAge = nActualTimespan;
		return nActualTimespan;
}



bool ClientOutOfSync()
{
	//This function will return True if the client is downloading blocks, reindexing, or out of sync by more than 30 blocks as compared to its peers, or if its best block is over 30 mins old
	double lastblockage = PreviousBlockAge();
	if (lastblockage > (30*60)) return true;
	if (fReindex || fImporting ) return true;
	if (pindexBest == NULL || nBestHeight < GetNumBlocksOfPeers()-30) return true;
	return false;
}



bool OutOfSyncByMoreThan(double dMinutes)
{
	double lastblockage = PreviousBlockAge();
	if (lastblockage > (60*dMinutes)) return true;
	if (fReindex || fImporting ) return true;
	if (pindexBest == NULL || nBestHeight < GetNumBlocksOfPeers()-30) return true;
	return false;
}



bool OutOfSyncByAge()
{
	double lastblockage = PreviousBlockAge();
	if (lastblockage > (60*30)) return true;
	if (fReindex || fImporting ) return true;
	return false;
}


bool LessVerbose(int iMax1000)
{
	 //Returns True when RND() level is lower than the number presented
	 int iVerbosityLevel = rand() % 1000;
	 if (iVerbosityLevel < iMax1000) return true;
	 return false;
}


bool KeyEnabled(std::string key)
{
	if (mapArgs.count("-" + key))
	{
			std::string sBool = GetArg("-" + key, "false");
			if (sBool == "true") return true;
	}
	return false;
}


bool OutOfSyncByAgeWithChanceOfMining()
{
	// If the client is out of sync, we dont want it to mine orphan blocks on its own fork, so we return OOS when that is the case 95% of the time:
	// If the client is in sync, this function returns false and the client mines.
	// The reason we allow mining 5% of the time, is if all nodes leave Gridcoin, we want someone to be able to jump start the coin in that extremely rare circumstance (IE End of Life, or Network Outage across the country, etc).
	try
	{
		    if (fTestNet) return false;
		    if (KeyEnabled("overrideoutofsyncrule")) return false;
			bool oosbyage = OutOfSyncByAge();
			//Rule 1: If  Last Block Out of sync by Age - Return Out of Sync 95% of the time:
			if (oosbyage) if (LessVerbose(900)) return true;
			// Rule 2 : Dont mine on Fork Rule:
	     	//If the diff is < .00015 in Prod, Most likely the client is mining on a fork: (Make it exceedingly hard):
			double PORDiff = GetDifficulty(GetLastBlockIndex(pindexBest, true));
			if (!fTestNet && PORDiff < .00010)
			{
				printf("Most likely you are mining on a fork! Diff %f",PORDiff);
				if (LessVerbose(950)) return true;
			}
			return false;
	}
	catch (std::exception &e)
	{
				printf("Error while assessing Sync Condition\r\n");
				return true;
	}
	catch(...)
	{
				printf("Error while assessing Sync Condition[2].\r\n");
				return true;
	}
	return true;

}


int Races(int iMax1000)
{
	 int i = rand() % iMax1000;
	 if (i < 1) i = 1;
	 return i;
}


unsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const
{
    if (IsCoinBase())
        return 0;

    unsigned int nSigOps = 0;
    for (unsigned int i = 0; i < vin.size(); i++)
    {
        const CTxOut& prevout = GetOutputFor(vin[i], inputs);
        if (prevout.scriptPubKey.IsPayToScriptHash())
            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);
    }
    return nSigOps;
}

bool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,
    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)
{
    // Take over previous transactions' spent pointers
    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain
    // fMiner is true when called from the internal bitcoin miner
    // ... both are false when called from CTransaction::AcceptToMemoryPool
    if (!IsCoinBase())
    {
        int64_t nValueIn = 0;
        int64_t nFees = 0;
        for (unsigned int i = 0; i < vin.size(); i++)
        {
            COutPoint prevout = vin[i].prevout;
            assert(inputs.count(prevout.hash) > 0);
            CTxIndex& txindex = inputs[prevout.hash].first;
            CTransaction& txPrev = inputs[prevout.hash].second;

            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())
                return DoS(100, error("ConnectInputs() : %s prevout.n out of range %d %"PRIszu" %"PRIszu" prev tx %s\n%s", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));

            // If prev is coinbase or coinstake, check that it's matured
            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())
                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)
                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)
                        return error("ConnectInputs() : tried to spend %s at depth %d", txPrev.IsCoinBase() ? "coinbase" : "coinstake", pindexBlock->nHeight - pindex->nHeight);

            // ppcoin: check transaction timestamp
            if (txPrev.nTime > nTime)
                return DoS(100, error("ConnectInputs() : transaction timestamp earlier than input transaction"));

            // Check for negative or overflow input values
            nValueIn += txPrev.vout[prevout.n].nValue;
            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))
                return DoS(100, error("ConnectInputs() : txin values out of range"));

        }
        // The first loop above does all the inexpensive checks.
        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.
        // Helps prevent CPU exhaustion attacks.
        for (unsigned int i = 0; i < vin.size(); i++)
        {
            COutPoint prevout = vin[i].prevout;
            assert(inputs.count(prevout.hash) > 0);
            CTxIndex& txindex = inputs[prevout.hash].first;
            CTransaction& txPrev = inputs[prevout.hash].second;

            // Check for conflicts (double-spend)
            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier
            // for an attacker to attempt to split the network.
            if (!txindex.vSpent[prevout.n].IsNull())
			{
				if (fMiner)
				{
					msMiningErrorsExcluded += " ConnectInputs() : " + GetHash().GetHex() + " used at "
						+ txindex.vSpent[prevout.n].ToString() + ";   ";
					return false;
				}
				if (!txindex.vSpent[prevout.n].IsNull())
				{
					if (fTestNet && pindexBlock->nHeight < nGrandfather)
					{
						return fMiner ? false : true;
					}
					if (!fTestNet && pindexBlock->nHeight < nGrandfather)
					{
						return fMiner ? false : true;
					}
					if (TimerMain("ConnectInputs", 20))
					{
						CleanInboundConnections(false);
					}	
					
					if (fMiner) return false;
					return fDebug ? error("ConnectInputs() : %s prev tx already used at %s", GetHash().ToString().c_str(), txindex.vSpent[prevout.n].ToString().c_str()) : false;
				}

			}

            // Skip ECDSA signature verification when connecting blocks (fBlock=true)
            // before the last blockchain checkpoint. This is safe because block merkle hashes are
            // still computed and checked, and any change will be caught at the next checkpoint.

            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))
            {
                // Verify signature
                if (!VerifySignature(txPrev, *this, i, 0))
                {
                    return DoS(100,error("ConnectInputs() : %s VerifySignature failed", GetHash().ToString().substr(0,10).c_str()));
                }
            }

            // Mark outpoints as spent
            txindex.vSpent[prevout.n] = posThisTx;

            // Write back
            if (fBlock || fMiner)
            {
                mapTestPool[prevout.hash] = txindex;
            }
        }

        if (!IsCoinStake())
        {
            if (nValueIn < GetValueOut())
			{
				printf("ConnectInputs(): VALUE IN < VALUEOUT \r\n");
                return DoS(100, error("ConnectInputs() : %s value in < value out", GetHash().ToString().substr(0,10).c_str()));
			}

            // Tally transaction fees
            int64_t nTxFee = nValueIn - GetValueOut();
            if (nTxFee < 0)
                return DoS(100, error("ConnectInputs() : %s nTxFee < 0", GetHash().ToString().substr(0,10).c_str()));

            // enforce transaction fees for every block
            if (nTxFee < GetMinFee())
                return fBlock? DoS(100, error("ConnectInputs() : %s not paying required fee=%s, paid=%s", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;

            nFees += nTxFee;
            if (!MoneyRange(nFees))
                return DoS(100, error("ConnectInputs() : nFees out of range"));
        }
    }

    return true;
}

bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)
{

	// Disconnect in reverse order
	bool bDiscTxFailed = false;
    for (int i = vtx.size()-1; i >= 0; i--)
	{
        if (!vtx[i].DisconnectInputs(txdb))
		{
            bDiscTxFailed = true;
		}
	}

    // Update block index on disk without changing it in memory.
    // The memory index structure will be changed after the db commits.
    if (pindex->pprev)
    {
        CDiskBlockIndex blockindexPrev(pindex->pprev);
        blockindexPrev.hashNext = 0;
        if (!txdb.WriteBlockIndex(blockindexPrev))
            return error("DisconnectBlock() : WriteBlockIndex failed");
    }

    // ppcoin: clean up wallet after disconnecting coinstake
    BOOST_FOREACH(CTransaction& tx, vtx)
        SyncWithWallets(tx, this, false, false);

	StructCPID stCPID = GetLifetimeCPID(pindex->sCPID,"DisconnectBlock()");
	// We normally fail to disconnect a block if we can't find the previous input due to "DisconnectInputs() : ReadTxIndex failed".  Imo, I believe we should let this call succeed, otherwise a chain can never be re-organized in this circumstance.
	if (bDiscTxFailed && fDebug3) printf("!DisconnectBlock()::Failed, recovering. ");
    return true;
}



double BlockVersion(std::string v)
{
	if (v.length() < 10) return 0;
	std::string vIn = v.substr(1,7);
	boost::replace_all(vIn, ".", "");
	double ver1 = cdbl(vIn,0);
	return ver1;
}


std::string PubKeyToAddress(const CScript& scriptPubKey)
{
	//Converts a script Public Key to a Gridcoin wallet address
	txnouttype type;
    vector<CTxDestination> addresses;
    int nRequired;
    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))
    {
        return "";
    }
	std::string address = "";
    BOOST_FOREACH(const CTxDestination& addr, addresses)
	{
		address = CBitcoinAddress(addr).ToString();
	}
	return address;
}

bool LoadSuperblock(std::string data, int64_t nTime, double height)
{
	 	WriteCache("superblock","magnitudes",ExtractXML(data,"<MAGNITUDES>","</MAGNITUDES>"),nTime);
		WriteCache("superblock","averages",ExtractXML(data,"<AVERAGES>","</AVERAGES>"),nTime);
		WriteCache("superblock","quotes",ExtractXML(data,"<QUOTES>","</QUOTES>"),nTime);
		WriteCache("superblock","all",data,nTime);
		WriteCache("superblock","block_number",RoundToString(height,0),nTime);
		return true;
}

std::string CharToString(char c)
{
	std::stringstream ss;
	std::string sOut = "";
	ss << c;
	ss >> sOut;
	return sOut;
}


template< typename T >
std::string int_to_hex( T i )
{
  std::stringstream stream;
  stream << "0x" 
         << std::setfill ('0') << std::setw(sizeof(T)*2) 
         << std::hex << i;
  return stream.str();
}

std::string DoubleToHexStr(double d, int iPlaces)
{
	int nMagnitude = atoi(RoundToString(d,0).c_str()); 
	std::string hex_string = int_to_hex(nMagnitude);
	std::string sOut = "00000000" + hex_string;
	std::string sHex = sOut.substr(sOut.length()-iPlaces,iPlaces);
    return sHex;
}

int HexToInt(std::string sHex)
{
	int x;   
    std::stringstream ss;
    ss << std::hex << sHex;
    ss >> x;
	return x;
}
std::string ConvertHexToBin(std::string a)
{
	if (a.empty()) return "";
	std::string sOut = "";
	for (unsigned int x = 1; x <= a.length(); x += 2)
	{
	   std::string sChunk = a.substr(x-1,2);
	   int i = HexToInt(sChunk);
	   char c = (char)i;
	   sOut.push_back(c);
    }
	return sOut;
}


double ConvertHexToDouble(std::string hex)
{
	int d = HexToInt(hex);
	double dOut = (double)d;
	return dOut;
}


std::string ConvertBinToHex(std::string a) 
{
      if (a.empty()) return "0";
	  std::string sOut = "";
	  for (unsigned int x = 1; x <= a.length(); x++)
	  {
    	   char c = a[x-1];
		   int i = (int)c; 
		   std::string sHex = DoubleToHexStr((double)i,2);
		   sOut += sHex;
      }
      return sOut;
}

std::string UnpackBinarySuperblock(std::string sBlock)
{
	// 12-21-2015: R HALFORD: If the block is not binary, return the legacy format for backward compatibility
	std::string sBinary = ExtractXML(sBlock,"<BINARY>","</BINARY>");
	if (sBinary.empty()) return sBlock;
	std::string sZero = ExtractXML(sBlock,"<ZERO>","</ZERO>");
	double dZero = cdbl(sZero,0);
	// Binary data support structure:
	// Each CPID consumes 16 bytes and 2 bytes for magnitude: (Except CPIDs with zero magnitude - the count of those is stored in XML node <ZERO> to save space)
	// 1234567890123456MM
	// MM = Magnitude stored as 2 bytes
	// No delimiter between CPIDs, Step Rate = 18
	std::string sReconstructedMagnitudes = "";
	for (unsigned int x = 0; x < sBinary.length(); x += 18)
	{
		if (sBinary.length() >= x+18)
		{
			std::string bCPID = sBinary.substr(x,16);
			std::string bMagnitude = sBinary.substr(x+16,2);
			std::string sCPID = ConvertBinToHex(bCPID);
			std::string sHexMagnitude = ConvertBinToHex(bMagnitude);
			double dMagnitude = ConvertHexToDouble("0x" + sHexMagnitude);
			std::string sRow = sCPID + "," + RoundToString(dMagnitude,0) + ";";
			sReconstructedMagnitudes += sRow;
			// if (fDebug3) printf("\r\n HEX CPID %s, HEX MAG %s, dMag %f, Row %s   ",sCPID.c_str(),sHexMagnitude.c_str(),dMagnitude,sRow.c_str());
		}
	}
	// Append zero magnitude researchers so the beacon count matches
	for (double d0 = 1; d0 <= dZero; d0++)
	{
			std::string sZeroCPID = "0";
			std::string sRow1 = sZeroCPID + ",15;";
			sReconstructedMagnitudes += sRow1;
	}
	std::string sAverages   = ExtractXML(sBlock,"<AVERAGES>","</AVERAGES>");
	std::string sQuotes     = ExtractXML(sBlock,"<QUOTES>","</QUOTES>");
	std::string sReconstructedBlock = "<AVERAGES>" + sAverages + "</AVERAGES><QUOTES>" + sQuotes + "</QUOTES><MAGNITUDES>" + sReconstructedMagnitudes + "</MAGNITUDES>";
	return sReconstructedBlock;
}

std::string PackBinarySuperblock(std::string sBlock)
{

	std::string sMagnitudes = ExtractXML(sBlock,"<MAGNITUDES>","</MAGNITUDES>");
	std::string sAverages   = ExtractXML(sBlock,"<AVERAGES>","</AVERAGES>");
	std::string sQuotes     = ExtractXML(sBlock,"<QUOTES>","</QUOTES>");
	// For each CPID in the superblock, convert data to binary
	std::vector<std::string> vSuperblock = split(sMagnitudes.c_str(),";");
	std::string sBinary = "";
	double dZeroMagCPIDCount = 0;
	for (unsigned int i = 0; i < vSuperblock.size(); i++)
	{
			if (vSuperblock[i].length() > 1)
			{
				std::string sPrefix = "00000000000000000000000000000000000" + ExtractValue(vSuperblock[i],",",0);
				std::string sCPID = sPrefix.substr(sPrefix.length()-32,32);
				double magnitude = cdbl(ExtractValue("0"+vSuperblock[i],",",1),0);
				if (magnitude < 0)     magnitude=0;
				if (magnitude > 32767) magnitude = 32767;  // Ensure we do not blow out the binary space (technically we can handle 0-65535)
				std::string sBinaryCPID   = ConvertHexToBin(sCPID);
				std::string sHexMagnitude = DoubleToHexStr(magnitude,4);
				std::string sBinaryMagnitude = ConvertHexToBin(sHexMagnitude);
				std::string sBinaryEntry  = sBinaryCPID+sBinaryMagnitude;
				// if (fDebug3) printf("\r\n PackBinarySuperblock: DecMag %f HEX MAG %s bin_cpid_len %f bm_len %f be_len %f,",	magnitude,sHexMagnitude.c_str(),(double)sBinaryCPID.length(),(double)sBinaryMagnitude.length(),(double)sBinaryEntry.length());
				if (sCPID=="00000000000000000000000000000000")
				{
					dZeroMagCPIDCount += 1;
				}
				else
				{
					sBinary += sBinaryEntry;
				}

			}
	}
	std::string sReconstructedBinarySuperblock = "<ZERO>" + RoundToString(dZeroMagCPIDCount,0) + "</ZERO><BINARY>" + sBinary + "</BINARY><AVERAGES>" + sAverages + "</AVERAGES><QUOTES>" + sQuotes + "</QUOTES>";
	return sReconstructedBinarySuperblock;
}




double ClientVersionNew()
{
	double cv = BlockVersion(FormatFullVersion());
	return cv;
}


int64_t ReturnCurrentMoneySupply(CBlockIndex* pindexcurrent)
{
	if (pindexcurrent->pprev)
	{
		// If previous exists, and previous money supply > Genesis, OK to use it:
		if (pindexcurrent->pprev->nHeight > 11 && pindexcurrent->pprev->nMoneySupply > nGenesisSupply)
		{
			return pindexcurrent->pprev->nMoneySupply;
		}
	}
	// Special case where block height < 12, use standard old logic:
	if (pindexcurrent->nHeight < 12)
	{
		return (pindexcurrent->pprev? pindexcurrent->pprev->nMoneySupply : 0);
	}
	// At this point, either the last block pointer was NULL, or the client erased the money supply previously, fix it:
	CBlockIndex* pblockIndex = pindexcurrent;
	CBlockIndex* pblockMemory = pindexcurrent;
	int nMinDepth = (pindexcurrent->nHeight)-140000;
	if (nMinDepth < 12) nMinDepth=12;
	while (pblockIndex->nHeight > nMinDepth)
	{
			pblockIndex = pblockIndex->pprev;
			if (pblockIndex == NULL || !pblockIndex->IsInMainChain()) continue;
			if (pblockIndex == pindexGenesisBlock)
			{
				return nGenesisSupply;
			}
	        if (pblockIndex->nMoneySupply > nGenesisSupply)
			{
				//Set index back to original pointer
				pindexcurrent = pblockMemory;
				//Return last valid money supply
				return pblockIndex->nMoneySupply;
			}
	}
	// At this point, we fall back to the old logic with a minimum of the genesis supply (should never happen - if it did, blockchain will need rebuilt anyway due to other fields being invalid):
	pindexcurrent = pblockMemory;
	return (pindexcurrent->pprev? pindexcurrent->pprev->nMoneySupply : nGenesisSupply);
}

bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck, bool fReorganizing)
{
    // Check it again in case a previous version let a bad block in, but skip BlockSig checking
    if (!CheckBlock("ConnectBlock",pindex->pprev->nHeight, 395*COIN, !fJustCheck, !fJustCheck, false,false))
	{
        printf("ConnectBlock::Failed - \r\n");
		return false;
	}
	//// issue here: it doesn't know the version
    unsigned int nTxPos;
    if (fJustCheck)
        // FetchInputs treats CDiskTxPos(1,1,1) as a special "refer to memorypool" indicator
        // Since we're just checking the block and not actually connecting it, it might not (and probably shouldn't) be on the disk to get the transaction from
        nTxPos = 1;
    else
        nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION) - (2 * GetSizeOfCompactSize(0)) + GetSizeOfCompactSize(vtx.size());

    map<uint256, CTxIndex> mapQueuedChanges;
    int64_t nFees = 0;
    int64_t nValueIn = 0;
    int64_t nValueOut = 0;
    int64_t nStakeReward = 0;
    unsigned int nSigOps = 0;
	double DPOR_Paid = 0;

	bool bIsDPOR = false;


    BOOST_FOREACH(CTransaction& tx, vtx)
    {
        uint256 hashTx = tx.GetHash();

        // Do not allow blocks that contain transactions which 'overwrite' older transactions,
        // unless those are already completely spent.
        // If such overwrites are allowed, coinbases and transactions depending upon those
        // can be duplicated to remove the ability to spend the first instance -- even after
        // being sent to another address.
        // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.
        // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool
        // already refuses previously-known transaction ids entirely.
        // This rule was originally applied all blocks whose timestamp was after March 15, 2012, 0:00 UTC.
        // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the
        // two in the chain that violate it. This prevents exploiting the issue against nodes in their
        // initial block download.
        CTxIndex txindexOld;
        if (txdb.ReadTxIndex(hashTx, txindexOld)) {
            BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)
                if (pos.IsNull())
                    return false;
        }

        nSigOps += tx.GetLegacySigOpCount();
        if (nSigOps > MAX_BLOCK_SIGOPS)
            return DoS(100, error("ConnectBlock[] : too many sigops"));

        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);
        if (!fJustCheck)
            nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);

        MapPrevTx mapInputs;
        if (tx.IsCoinBase())
		{
            nValueOut += tx.GetValueOut();
		}
        else
        {
            bool fInvalid;
            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))
                return false;

            // Add in sigops done by pay-to-script-hash inputs;
            // this is to prevent a "rogue miner" from creating
            // an incredibly-expensive-to-validate block.
            nSigOps += tx.GetP2SHSigOpCount(mapInputs);
            if (nSigOps > MAX_BLOCK_SIGOPS)
                return DoS(100, error("ConnectBlock[] : too many sigops"));

            int64_t nTxValueIn = tx.GetValueIn(mapInputs);
            int64_t nTxValueOut = tx.GetValueOut();
            nValueIn += nTxValueIn;
            nValueOut += nTxValueOut;
            if (!tx.IsCoinStake())
                nFees += nTxValueIn - nTxValueOut;
            if (tx.IsCoinStake())
			{
                nStakeReward = nTxValueOut - nTxValueIn;
				if (tx.vout.size() > 3 && pindex->nHeight > nGrandfather) bIsDPOR = true;
				// ResearchAge: Verify vouts cannot contain any other payments except coinstake: PASS (GetValueOut returns the sum of all spent coins in the coinstake)
				if (IsResearchAgeEnabled(pindex->nHeight) && fDebug10)
				{
					int64_t nTotalCoinstake = 0;
					for (unsigned int i = 0; i < tx.vout.size(); i++)
					{
						nTotalCoinstake += tx.vout[i].nValue;
					}
					if (fDebug10) 	printf(" nHeight %f; nTCS %f; nTxValueOut %f     ",
						(double)pindex->nHeight,CoinToDouble(nTotalCoinstake),CoinToDouble(nTxValueOut));
				}

				//Options Support
				if (bOptionPaymentsEnabled)
				{
					// Disabled
				}
				else
				{
					// Verify no recipients exist after coinstake (Recipients start at output position 3 (0=Coinstake flag, 1=coinstake amount, 2=splitstake amount)
					if (bIsDPOR && pindex->nHeight > nGrandfather)
					{
						for (unsigned int i = 3; i < tx.vout.size(); i++)
						{
							std::string Recipient = PubKeyToAddress(tx.vout[i].scriptPubKey);
							double      Amount    = CoinToDouble(tx.vout[i].nValue);
							if (fDebug10) printf("Iterating Recipient #%f  %s with Amount %f \r\n,",(double)i,Recipient.c_str(),Amount);
  			  				if (Amount > 0)
							{
									if (fDebug3) printf("Iterating Recipient #%f  %s with Amount %f \r\n,",(double)i,Recipient.c_str(),Amount);
									printf("POR Payment results in an overpayment; Recipient %s, Amount %f \r\n",Recipient.c_str(), Amount);
		        					return DoS(50,error("POR Payment results in an overpayment; Recipient %s, Amount %f \r\n",
											Recipient.c_str(), Amount));
							}
						}
					}
				}
			}

            if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))
                return false;
        }

        mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());
    }

    if (IsProofOfWork() && pindex->nHeight > nGrandfather)
    {
		int64_t nReward = GetProofOfWorkMaxReward(nFees,nTime,pindex->nHeight);
        // Check coinbase reward
        if (vtx[0].GetValueOut() > nReward)
            return DoS(50, error("ConnectBlock[] : coinbase reward exceeded (actual=%"PRId64" vs calculated=%"PRId64")",
                   vtx[0].GetValueOut(),
                   nReward));
    }

	MiningCPID bb = DeserializeBoincBlock(vtx[0].hashBoinc);
	uint64_t nCoinAge = 0;

	double dStakeReward = CoinToDouble(nStakeReward+nFees) - DPOR_Paid; //DPOR Recipients checked above already
	double dStakeRewardWithoutFees = CoinToDouble(nStakeReward) - DPOR_Paid;

	if (fDebug) printf("Stake Reward of %f , DPOR PAID %f    ",dStakeReward,DPOR_Paid);

    if (IsProofOfStake() && pindex->nHeight > nGrandfather)
    {
	    // ppcoin: coin stake tx earns reward instead of paying fee
        if (!vtx[1].GetCoinAge(txdb, nCoinAge))
            return error("ConnectBlock[] : %s unable to get coin age for coinstake", vtx[1].GetHash().ToString().substr(0,10).c_str());

		double dCalcStakeReward = CoinToDouble(GetProofOfStakeMaxReward(nCoinAge, nFees, nTime));

		if (dStakeReward > dCalcStakeReward+1 && !IsResearchAgeEnabled(pindex->nHeight))
            return DoS(1, error("ConnectBlock[] : coinstake pays above maximum (actual= %f, vs calculated=%f )", dStakeReward, dCalcStakeReward));

		//9-3-2015
		double dMaxResearchAgeReward = CoinToDouble(GetMaximumBoincSubsidy(nTime) * COIN * 255);

		if (bb.ResearchSubsidy > dMaxResearchAgeReward && IsResearchAgeEnabled(pindex->nHeight))
            return DoS(1, error("ConnectBlock[ResearchAge] : Coinstake pays above maximum (actual= %f, vs calculated=%f )", dStakeRewardWithoutFees, dMaxResearchAgeReward));

		if (bb.cpid=="INVESTOR" && dStakeReward > 1)
		{
			double OUT_POR = 0;
			double OUT_INTEREST_OWED = 0;

			double dAccrualAge = 0;
    		double dAccrualMagnitudeUnit = 0;
	    	double dAccrualMagnitude = 0;

			double dCalculatedResearchReward = CoinToDouble(GetProofOfStakeReward(nCoinAge, nFees, bb.cpid, true, 1, nTime,
				    pindex, "connectblock_investor",
					OUT_POR, OUT_INTEREST_OWED, dAccrualAge, dAccrualMagnitudeUnit, dAccrualMagnitude));
			if (dStakeReward > (OUT_INTEREST_OWED+1+nFees) )
			{
					return DoS(10, error("ConnectBlock[] : Investor Reward pays too much : cpid %s (actual %f vs calculated %f), dCalcResearchReward %f, Fees %f",
					bb.cpid.c_str(), dStakeReward, OUT_INTEREST_OWED, dCalculatedResearchReward, (double)nFees));
			}
		}

 	}


	AddCPIDBlockHash(bb.cpid,pindex->GetBlockHash().GetHex(),false);

    // Track money supply and mint amount info
    pindex->nMint = nValueOut - nValueIn + nFees;
	if (fDebug10) printf (".TMS.");

    pindex->nMoneySupply = ReturnCurrentMoneySupply(pindex) + nValueOut - nValueIn;

	// Gridcoin: Store verified magnitude and CPID in block index (7-11-2015)
	if (pindex->nHeight > nNewIndex)
	{
		pindex->sCPID  = bb.cpid;
		pindex->nMagnitude = bb.Magnitude;
		pindex->nResearchSubsidy = bb.ResearchSubsidy;
		pindex->nInterestSubsidy = bb.InterestSubsidy;
		pindex->nIsSuperBlock =  (bb.superblock.length() > 20) ? 1 : 0;
		// Must scan transactions after CoinStake to know if this is a contract.
		int iPos = 0;
		BOOST_FOREACH(const CTransaction &tx, vtx)
		{
			if (tx.hashBoinc.length() > 3 && iPos > 0)
			{
				pindex->nIsContract = 1;
				break;
			}
			iPos++;
		}
		pindex->sGRCAddress = bb.GRCAddress;
		pindex->sReserved = "";
	}

	double mint = CoinToDouble(pindex->nMint);
    double PORDiff = GetBlockDifficulty(nBits);

	if (pindex->nHeight > nGrandfather && !fReorganizing)
	{
		// Block Spamming
		if (mint < MintLimiter(PORDiff,bb.RSAWeight,bb.cpid,GetBlockTime()))
		{
			return error("CheckProofOfStake[] : Mint too Small, %f",(double)mint);
		}

		if (mint == 0) return error("CheckProofOfStake[] : Mint is ZERO! %f",(double)mint);

		double OUT_POR = 0;
		double OUT_INTEREST = 0;
		double dAccrualAge = 0;
		double dMagnitudeUnit = 0;
		double dAvgMagnitude = 0;

	    // ResearchAge 1: 
		GetProofOfStakeReward(nCoinAge, nFees, bb.cpid, true, 1, nTime,
			pindex, "connectblock_researcher", OUT_POR, OUT_INTEREST, dAccrualAge, dMagnitudeUnit, dAvgMagnitude);
		if (bb.cpid != "INVESTOR" && dStakeReward > 1)
		{
			
			    //ResearchAge: Since the best block may increment before the RA is connected but After the RA is computed, the ResearchSubsidy can sometimes be slightly smaller than we calculate here due to the RA timespan increasing.  So we will allow for time shift before rejecting the block.
			    double dDrift = IsResearchAgeEnabled(pindex->nHeight) ? bb.ResearchSubsidy*.15 : 1;
				if (IsResearchAgeEnabled(pindex->nHeight) && dDrift < 10) dDrift = 10;

				if ((bb.ResearchSubsidy + bb.InterestSubsidy + dDrift) < dStakeRewardWithoutFees)
				{
						return error("ConnectBlock[] : Researchers Interest %f + Research %f + TimeDrift %f and total Mint %f, [StakeReward] <> %f, with Out_Interest %f, OUT_POR %f, Fees %f, DPOR %f  for CPID %s does not match calculated research subsidy",
							(double)bb.InterestSubsidy,(double)bb.ResearchSubsidy,dDrift,CoinToDouble(mint),dStakeRewardWithoutFees,
							(double)OUT_INTEREST,(double)OUT_POR,CoinToDouble(nFees),(double)DPOR_Paid,bb.cpid.c_str());

				}
				if (IsResearchAgeEnabled(pindex->nHeight) && BlockNeedsChecked(nTime))
				{
						if (dStakeReward > ((OUT_POR*1.25)+OUT_INTEREST+1+CoinToDouble(nFees)))
						{
							StructCPID st1 = GetLifetimeCPID(pindex->sCPID,"ConnectBlock()");
							GetProofOfStakeReward(nCoinAge, nFees, bb.cpid, true, 2, nTime,
										pindex, "connectblock_researcher_doublecheck", OUT_POR, OUT_INTEREST, dAccrualAge, dMagnitudeUnit, dAvgMagnitude);
							if (dStakeReward > ((OUT_POR*1.25)+OUT_INTEREST+1+CoinToDouble(nFees)))
							{

								if (fDebug3) printf("ConnectBlockError[ResearchAge] : Researchers Reward Pays too much : Interest %f and Research %f and StakeReward %f, OUT_POR %f, with Out_Interest %f for CPID %s ",
									(double)bb.InterestSubsidy,(double)bb.ResearchSubsidy,dStakeReward,(double)OUT_POR,(double)OUT_INTEREST,bb.cpid.c_str());

								return DoS(10,error("ConnectBlock[ResearchAge] : Researchers Reward Pays too much : Interest %f and Research %f and StakeReward %f, OUT_POR %f, with Out_Interest %f for CPID %s ",
									(double)bb.InterestSubsidy,(double)bb.ResearchSubsidy,dStakeReward,(double)OUT_POR,(double)OUT_INTEREST,bb.cpid.c_str()));
							}
						}
				}
		}

		//Approve first coinstake in DPOR block
		if (bb.cpid != "INVESTOR" && IsLockTimeWithinMinutes(GetBlockTime(),15) && !IsResearchAgeEnabled(pindex->nHeight))
		{
			    if (bb.ResearchSubsidy > (GetOwedAmount(bb.cpid)+1))
				{
						bDoTally=true;
					    if (bb.ResearchSubsidy > (GetOwedAmount(bb.cpid)+1))
						{
							StructCPID strUntrustedHost = GetInitializedStructCPID2(bb.cpid,mvMagnitudes);
							if (bb.ResearchSubsidy > strUntrustedHost.totalowed)
							{
								double deficit = strUntrustedHost.totalowed - bb.ResearchSubsidy;
								if ( (deficit < -500 && strUntrustedHost.Accuracy > 10) || (deficit < -150 && strUntrustedHost.Accuracy > 5) || deficit < -50)
								{
										printf("ConnectBlock[] : Researchers Reward results in deficit of %f for CPID %s with trust level of %f - (Submitted Research Subsidy %f vs calculated=%f) Hash: %s",
										 deficit, bb.cpid.c_str(), (double)strUntrustedHost.Accuracy, bb.ResearchSubsidy,
										 OUT_POR, vtx[0].hashBoinc.c_str());
								}
								else
								{
									return error("ConnectBlock[] : Researchers Reward for CPID %s pays too much - (Submitted Research Subsidy %f vs calculated=%f) Hash: %s",
										bb.cpid.c_str(), bb.ResearchSubsidy,
										OUT_POR, vtx[0].hashBoinc.c_str());
								}
							}
					}
				}
		}

	}

	//Gridcoin: Maintain network consensus for Payments and Neural popularity:  (As of 7-5-2015 this is now done exactly every 30 blocks)

	//DPOR - 6/12/2015 - Reject superblocks not hashing to the supermajority:

	if (bb.superblock.length() > 20)
	{
		if (pindex->nHeight > nGrandfather && !fReorganizing)
		{
			// 12-20-2015 : Add support for Binary Superblocks
			std::string superblock = UnpackBinarySuperblock(bb.superblock);
			std::string neural_hash = GetQuorumHash(superblock);
			std::string legacy_neural_hash = RetrieveMd5(superblock);
			double popularity = 0;
			std::string consensus_hash = GetNeuralNetworkSupermajorityHash(popularity);
			// Only reject superblock when it is new And when QuorumHash of Block != the Popular Quorum Hash:
			if (IsLockTimeWithinMinutes(GetBlockTime(),15)  && !fColdBoot)
			{
				if (!VerifySuperblock(superblock,pindex->nHeight))
				{
					return error("ConnectBlock[] : Superblock avg mag below 10; SuperblockHash: %s, Consensus Hash: %s",
										neural_hash.c_str(), consensus_hash.c_str());
				}
				if (!IsResearchAgeEnabled(pindex->nHeight))
				{
					if (consensus_hash != neural_hash && consensus_hash != legacy_neural_hash)
					{
						return error("ConnectBlock[] : Superblock hash does not match consensus hash; SuperblockHash: %s, Consensus Hash: %s",
										neural_hash.c_str(), consensus_hash.c_str());
					}
				}
				else
				{
					if (consensus_hash != neural_hash)
					{
						return error("ConnectBlock[] : Superblock hash does not match consensus hash; SuperblockHash: %s, Consensus Hash: %s",
										neural_hash.c_str(), consensus_hash.c_str());
					}
				}

			}
		}


			//If we are out of sync, and research age is enabled, and the superblock is valid, load it now, so we can continue checking blocks accurately
			if ((OutOfSyncByAge() || fColdBoot || fReorganizing) && IsResearchAgeEnabled(pindex->nHeight) && pindex->nHeight > nGrandfather)
			{
				    if (bb.superblock.length() > 20)
					{
						    std::string superblock = UnpackBinarySuperblock(bb.superblock);
							if (VerifySuperblock(superblock,pindex->nHeight))
							{
										LoadSuperblock(superblock,pindex->nTime,pindex->nHeight);
										if (fDebug3) printf("ConnectBlock(): Superblock Loaded %f \r\n",(double)pindex->nHeight);
										/*  Reserved for future use:
											bNetAveragesLoaded=false;
											nLastTallied = 0;
											BsyWaitForTally();
										*/
										bDoTally = true;
							}
							else
							{
								if (fDebug3) printf("ConnectBlock(): Superblock Not Loaded %f\r\n",(double)pindex->nHeight);
							}
					}
			}



		/*
			-- Normal Superblocks are loaded 15 blocks later
		*/
	}

	//  End of Network Consensus

	// Gridcoin: Track payments to CPID, and last block paid
	if (!bb.cpid.empty() && bb.cpid != "INVESTOR" && pindex->nHeight > nNewIndex)
	{
		StructCPID stCPID = GetInitializedStructCPID2(bb.cpid,mvResearchAge);
		stCPID.InterestSubsidy += bb.InterestSubsidy;
		stCPID.ResearchSubsidy += bb.ResearchSubsidy;

		if (((double)pindex->nHeight) > stCPID.LastBlock && pindex->nResearchSubsidy > 0)
		{
				stCPID.LastBlock = (double)pindex->nHeight;
				stCPID.BlockHash = pindex->GetBlockHash().GetHex();
		}

		if (pindex->nMagnitude > 0)
		{
				stCPID.Accuracy++;
				stCPID.TotalMagnitude += pindex->nMagnitude;
				stCPID.ResearchAverageMagnitude = stCPID.TotalMagnitude/(stCPID.Accuracy+.01);
		}

		if (((double)pindex->nTime) < stCPID.LowLockTime)  stCPID.LowLockTime = (double)pindex->nTime;
		if (((double)pindex->nTime) > stCPID.HighLockTime) stCPID.HighLockTime = (double)pindex->nTime;

		mvResearchAge[bb.cpid]=stCPID;
	}

	if (!IsResearchAgeEnabled(pindex->nHeight))
	{
			MiningCPID myInit = GetInitializedMiningCPID(pindex->GetBlockHash().GetHex(), mvBlockIndex);
			mvBlockIndex[pindex->GetBlockHash().GetHex()] = bb;
	}

    if (!txdb.WriteBlockIndex(CDiskBlockIndex(pindex)))
        return error("Connect() : WriteBlockIndex for pindex failed");

	if (pindex->nHeight % 5 == 0 && pindex->nHeight > 100)
	{
		std::string errors1 = "";
		LoadAdminMessages(false,errors1);
	}

	// Slow down Retallying when in RA mode so we minimize disruption of the network
	if ( (pindex->nHeight % 60 == 0) && IsResearchAgeEnabled(pindex->nHeight) && BlockNeedsChecked(pindex->nTime))
	{
		if (fDebug3) printf("\r\n*BusyWaitForTally*\r\n");
		BusyWaitForTally();
	}


	if (IsResearchAgeEnabled(pindex->nHeight) && !OutOfSyncByAge()) fColdBoot = false;

    if (fJustCheck)
        return true;

    // Write queued txindex changes
    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)
    {
        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))
            return error("ConnectBlock[] : UpdateTxIndex failed");
    }

    // Update block index on disk without changing it in memory.
    // The memory index structure will be changed after the db commits.
    if (pindex->pprev)
    {
        CDiskBlockIndex blockindexPrev(pindex->pprev);
        blockindexPrev.hashNext = pindex->GetBlockHash();
        if (!txdb.WriteBlockIndex(blockindexPrev))
            return error("ConnectBlock[] : WriteBlockIndex failed");
    }

    // Watch for transactions paying to me
    BOOST_FOREACH(CTransaction& tx, vtx)
        SyncWithWallets(tx, this, true);

    return true;
}



bool CleanChainOld()
{
	CTxDB txdb;
    printf("\r\n** CLEAN CHAIN **\r\n");
    if (!txdb.TxnBegin())
        return error("SetBestChain() : TxnBegin failed");

	if (nBestHeight < 1000) return true;
	// Roll back a few blocks from best height
	printf(" Current best height %f ",(double)pindexBest->nHeight);
	CBlockIndex* pfork = pindexBest->pprev->pprev->pprev->pprev->pprev;
	CBlockIndex* pindexNew = pfork->pprev;
	printf(" Target height %f ",(double)pfork->nHeight);

    // List of what to disconnect
    vector<CBlockIndex*> vDisconnect;
    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)
        vDisconnect.push_back(pindex);

	if (pindexBest->pnext)
	{
		// The next block is on a fork... but its not the best block
        CBlock myBlock;
        if (myBlock.ReadFromDisk(pindexBest->pnext))
		{
			vDisconnect.push_back(pindexBest->pnext);
			printf(" PindexBest+1 is on a fork. ");
		}
	}

	// ToDo : add every block inside the orphan map to vDisconnect - if readable from disk.
	vector<CTransaction> vDelete;
    printf(" Clean Chain: Disconnect %"PRIszu" blocks; %s..%s\n", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());

    // Disconnect 
    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)
    {
        CBlock block;
        if (!block.ReadFromDisk(pindex))
            return error("CleanChain() : ReadFromDisk for disconnect failed");
        if (!block.DisconnectBlock(txdb, pindex))
            return error("CleanChain() : DisconnectBlock %s failed", pindex->GetBlockHash().ToString().substr(0,20).c_str());
        BOOST_FOREACH(const CTransaction& tx, block.vtx)
            vDelete.push_back(tx);
		printf(" Disc %f ",(double)pindex->nHeight);
    }

	printf("Writing HashBestChain");

    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))
        return error("CleanChain() : WriteHashBestChain failed");

    // Make sure it's successfully written to disk before changing memory structure
    if (!txdb.TxnCommit())
        return error("CleanChain() : TxnCommit failed");

	printf(" Chain committed ");
    // Disconnect shorter branch
    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)
	{
        if (pindex->pprev)
            pindex->pprev->pnext = NULL;
		if (IsResearchAgeEnabled(pindex->nHeight)) 	StructCPID st1 = GetLifetimeCPID(pindex->pprev->sCPID,"Reorganize()");

	}
    // Delete redundant memory transactions that are in the connected branch
    BOOST_FOREACH(CTransaction& tx, vDelete) 
	{
        mempool.remove(tx);
        mempool.removeConflicts(tx);
    }

	CBlock blockNew;
	if (!blockNew.ReadFromDisk(pindexNew))
	{
		printf("ShaveChain(): Fatal Error while reading new best block.\r\n");
		return false;
	}

	if (!blockNew.SetBestChain(txdb, pindexNew))
    {
		return error("CleanChain(): Fatal Error while setting best chain.\r\n");
	}


    printf("CleanChain: done\n");
	mapOrphanBlocks.clear();
	setStakeSeen.clear();
	setStakeSeenOrphan.clear();
	bool fResult = AskForOutstandingBlocks(uint256(0));
	bDoTally=true;
    return true;
	
}


bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)
{
    printf("REORGANIZE\n");
	// Find the fork
    CBlockIndex* pfork = pindexBest;
    CBlockIndex* plonger = pindexNew;
    while (pfork != plonger)
    {
        while (plonger->nHeight > pfork->nHeight)
            if (!(plonger = plonger->pprev))
                return error("Reorganize() : plonger->pprev is null");
        if (pfork == plonger)
            break;
        if (!(pfork = pfork->pprev))
            return error("Reorganize() : pfork->pprev is null");
    }

    // List of what to disconnect
	vector<CBlockIndex*> vDisconnect;
    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)
        vDisconnect.push_back(pindex);

    // List of what to connect
    vector<CBlockIndex*> vConnect;
    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)
        vConnect.push_back(pindex);
    reverse(vConnect.begin(), vConnect.end());

    printf("REORGANIZE: Disconnect %"PRIszu" blocks; %s..%s\n", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());
    printf("REORGANIZE: Connect %"PRIszu" blocks; %s..%s\n", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());

	if (vDisconnect.size() > 0)
	{
		//Block was disconnected - User is Re-eligibile for staking

		StructCPID sMag = GetInitializedStructCPID2(GlobalCPUMiningCPID.cpid,mvMagnitudes);

		if (sMag.initialized)
		{
			sMag.LastPaymentTime = 0;
			mvMagnitudes[GlobalCPUMiningCPID.cpid]=sMag;
		}
		nLastBlockSolved = 0;
	}
	printf("REORGANIZE Disc Size %f",(double)vDisconnect.size());

    // Disconnect shorter branch
    list<CTransaction> vResurrect;
    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)
    {
        CBlock block;
        if (!block.ReadFromDisk(pindex))
            return error("Reorganize() : ReadFromDisk for disconnect failed");
        if (!block.DisconnectBlock(txdb, pindex))
            return error("Reorganize() : DisconnectBlock %s failed", pindex->GetBlockHash().ToString().substr(0,20).c_str());

        // Queue memory transactions to resurrect.
        // We only do this for blocks after the last checkpoint (reorganisation before that
        // point should only happen with -reindex/-loadblock, or a misbehaving peer.
        BOOST_REVERSE_FOREACH(const CTransaction& tx, block.vtx)
            if (!(tx.IsCoinBase() || tx.IsCoinStake()) && pindex->nHeight > Checkpoints::GetTotalBlocksEstimate())
                vResurrect.push_front(tx);
    }

    // Connect longer branch
    vector<CTransaction> vDelete;
    for (unsigned int i = 0; i < vConnect.size(); i++)
    {
        CBlockIndex* pindex = vConnect[i];
        CBlock block;
        if (!block.ReadFromDisk(pindex))
            return error("Reorganize() : ReadFromDisk for connect failed");
        if (!block.ConnectBlock(txdb, pindex, false, true))
        {
            // Invalid block
            return error("Reorganize() : ConnectBlock %s failed", pindex->GetBlockHash().ToString().substr(0,20).c_str());
        }

        // Queue memory transactions to delete
        BOOST_FOREACH(const CTransaction& tx, block.vtx)
            vDelete.push_back(tx);

		if (!IsResearchAgeEnabled(pindex->nHeight))
		{
			MiningCPID bb = GetInitializedMiningCPID(pindex->GetBlockHash().GetHex(), mvBlockIndex);
	   		bb = DeserializeBoincBlock(block.vtx[0].hashBoinc);
			mvBlockIndex[pindex->GetBlockHash().GetHex()] = bb;
		}
    }

    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))
        return error("Reorganize() : WriteHashBestChain failed");

    // Make sure it's successfully written to disk before changing memory structure
    if (!txdb.TxnCommit())
        return error("Reorganize() : TxnCommit failed");

    // Disconnect shorter branch
    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)
	{
        if (pindex->pprev)
		{
            pindex->pprev->pnext = NULL;
			//if (IsResearchAgeEnabled(pindex->nHeight)) 	StructCPID st1 = GetLifetimeCPID(pindex->pprev->sCPID,"Reorganize()");
		}
	}

    // Connect longer branch
    BOOST_FOREACH(CBlockIndex* pindex, vConnect)
	{
        if (pindex->pprev)
		{
            pindex->pprev->pnext = pindex;
			//if (IsResearchAgeEnabled(pindex->nHeight)) 	StructCPID st2 = GetLifetimeCPID(pindex->pprev->sCPID,"Reorganize()::ConnectLongerBranch()");
		}
	}

    // Resurrect memory transactions that were in the disconnected branch
    BOOST_FOREACH(CTransaction& tx, vResurrect)
        AcceptToMemoryPool(mempool, tx, NULL);

    // Delete redundant memory transactions that are in the connected branch
    BOOST_FOREACH(CTransaction& tx, vDelete)
	{
        mempool.remove(tx);
        mempool.removeConflicts(tx);
    }

	// Gridcoin: Now that the chain is back in order, Fix the researchers who were disrupted:
	//BsyWaitForTally();
	//bDoTally=true;

    printf("REORGANIZE: done\n");
    return true;
}


bool CleanChain()
{
	CTxDB txdb;
   if (!txdb.TxnBegin())
        return error("CleanChain() : TxnBegin failed");

	if (nBestHeight < 1000) return true;

    printf("\r\n** CLEAN CHAIN **\r\n");
	// Roll back a few blocks from best height
	printf(" Current best height %f ",(double)pindexBest->nHeight);
	CBlockIndex* pfork = pindexBest->pprev;
	CBlockIndex* pindexNew = pfork->pprev;
	printf(" Target height %f ",(double)pfork->nHeight);

	if (!Reorganize(txdb, pfork))
	{
					printf("Failed to Reorganize during Attempt #%f \r\n",(double)1);
					txdb.TxnAbort();
					//InvalidChainFound(pindexNew);
					return false;
	}
	else
	{
			CBlock blockNew;
			if (!blockNew.ReadFromDisk(pindexNew))
			{
				printf("CleanChain(): Fatal Error while reading new best block.\r\n");
				return false;
			}

			if (!blockNew.SetBestChain(txdb, pindexNew))
			{
				return error("CleanChain(): Fatal Error while setting best chain.\r\n");
			}

			printf(" Clean Chain succeeded. ");
	}
	bool fResult = AskForOutstandingBlocks(uint256(0));
	return true;

}



void SetAdvisory()
{
	CheckpointsMode = Checkpoints::ADVISORY;

}

bool InAdvisory()
{
	return (CheckpointsMode == Checkpoints::ADVISORY);
}

// Called from inside SetBestChain: attaches a block to the new best chain being built
bool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew, bool fReorganizing)
{
    uint256 hash = GetHash();

    // Adding to current best branch
    if (!ConnectBlock(txdb, pindexNew, false, fReorganizing) || !txdb.WriteHashBestChain(hash))
    {
        txdb.TxnAbort();
		if (fDebug3) printf("Invalid Chain Found.  Invalid block %s\r\n",hash.GetHex().c_str());
        InvalidChainFound(pindexNew);
        return false;
    }
    if (!txdb.TxnCommit())
        return error("SetBestChain() : TxnCommit failed");

    // Add to current best branch
    pindexNew->pprev->pnext = pindexNew;

    // Delete redundant memory transactions
    BOOST_FOREACH(CTransaction& tx, vtx)
        mempool.remove(tx);

    return true;
}

bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)
{
    uint256 hash = GetHash();

    if (!txdb.TxnBegin())
        return error("SetBestChain() : TxnBegin failed");

    if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))
    {
        txdb.WriteHashBestChain(hash);
        if (!txdb.TxnCommit())
            return error("SetBestChain() : TxnCommit failed");
        pindexGenesisBlock = pindexNew;
    }
    else if (hashPrevBlock == hashBestChain)
    {
        if (!SetBestChainInner(txdb, pindexNew, false))
		{
			//int nResult = 0;
            return error("SetBestChain() : SetBestChainInner failed");
		}
    }
    else
    {
        // the first block in the new chain that will cause it to become the new best chain
        CBlockIndex *pindexIntermediate = pindexNew;
		// list of blocks that need to be connected afterwards
        std::vector<CBlockIndex*> vpindexSecondary;
		printf("\r\n**Reorganize**");

		//10-6-2015 Make Reorganize work more gracefully - try up to 5 times to reorganize, each with an intermediate further back
        for (int iRegression = 0; iRegression < 5; iRegression++)
		{
			int rollback = iRegression * 100;

		    // Reorganize is costly in terms of db load, as it works in a single db transaction.
			// Try to limit how much needs to be done inside
			int rolled_back = 1;
			while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust && rolled_back < rollback)
			{
				vpindexSecondary.push_back(pindexIntermediate);
				pindexIntermediate = pindexIntermediate->pprev;
				if (pindexIntermediate==pindexGenesisBlock) break;
				rolled_back++;
			}

			if (!vpindexSecondary.empty())
			printf("\r\nReorganizing Attempt #%f, regression to block #%f \r\n",(double)iRegression+1,(double)pindexIntermediate->nHeight);

            printf("Postponing %"PRIszu" reconnects\n", vpindexSecondary.size());
			if (iRegression==4 && !Reorganize(txdb, pindexIntermediate))
			{
					printf("Failed to Reorganize during Attempt #%f \r\n",(double)iRegression+1);
					txdb.TxnAbort();
					InvalidChainFound(pindexNew);
					printf("\r\nReorg BusyWait\r\n");
					BusyWaitForTally();
				 	REORGANIZE_FAILED++;
					return error("SetBestChain() : Reorganize failed");
			}
		}
		// Switch to new best branch
		REORGANIZE_FAILED=0;

        // Connect further blocks
        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)
        {
            CBlock block;
            if (!block.ReadFromDisk(pindex))
            {
                printf("SetBestChain() : ReadFromDisk failed\n");
                break;
            }
            if (!txdb.TxnBegin()) {
                printf("SetBestChain() : TxnBegin 2 failed\n");
                break;
            }
            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way
            if (!block.SetBestChainInner(txdb, pindex, true))
                break;
        }
    }

    // Update best block in wallet (so we can detect restored wallets)
    bool fIsInitialDownload = IsInitialBlockDownload();
    if (!fIsInitialDownload)
    {
        const CBlockLocator locator(pindexNew);
        ::SetBestChain(locator);
    }

    // New best block
    hashBestChain = hash;
    pindexBest = pindexNew;
    pblockindexFBBHLast = NULL;
    nBestHeight = pindexBest->nHeight;
    nBestChainTrust = pindexNew->nChainTrust;
    nTimeBestReceived =  GetAdjustedTime();
    nTransactionsUpdated++;

    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;

	if (fDebug)
	{
		printf("{SBC} SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%"PRId64"  date=%s\n",
		  hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,
		  CBigNum(nBestChainTrust).ToString().c_str(),
          nBestBlockTrust.Get64(),
          DateTimeStrFormat("%x %H:%M:%S", pindexBest->GetBlockTime()).c_str());
	}
	else
	{
		printf("{SBC} new best=%s  height=%d ; ",hashBestChain.ToString().c_str(), nBestHeight);
		nLastBestHeight = nBestHeight;
	}

    // Check the version of the last 100 blocks to see if we need to upgrade:
    if (!fIsInitialDownload)
    {
        int nUpgraded = 0;
        const CBlockIndex* pindex = pindexBest;
        for (int i = 0; i < 100 && pindex != NULL; i++)
        {
            if (pindex->nVersion > CBlock::CURRENT_VERSION)
                ++nUpgraded;
            pindex = pindex->pprev;
        }
        if (nUpgraded > 0)
            printf("SetBestChain: %d of last 100 blocks above version %d\n", nUpgraded, CBlock::CURRENT_VERSION);
        if (nUpgraded > 100/2)
            // strMiscWarning is read by GetWarnings(), called by Qt and the JSON-RPC code to warn the user:
            strMiscWarning = _("Warning: This version is obsolete, upgrade required!");
    }

    std::string strCmd = GetArg("-blocknotify", "");

    if (!fIsInitialDownload && !strCmd.empty())
    {
        boost::replace_all(strCmd, "%s", hashBestChain.GetHex());
        boost::thread t(runCommand, strCmd); // thread runs free
    }
	REORGANIZE_FAILED=0;

    return true;
}

// ppcoin: total coin age spent in transaction, in the unit of coin-days.
// Only those coins meeting minimum age requirement counts. As those
// transactions not in main chain are not currently indexed so we
// might not find out about their coin age. Older transactions are
// guaranteed to be in main chain by sync-checkpoint. This rule is
// introduced to help nodes establish a consistent view of the coin
// age (trust score) of competing branches.
bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const
{
    CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds
    nCoinAge = 0;

    if (IsCoinBase())
        return true;

    BOOST_FOREACH(const CTxIn& txin, vin)
    {
        // First try finding the previous transaction in database
        CTransaction txPrev;
        CTxIndex txindex;
        if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))
            continue;  // previous transaction not in main chain
        if (nTime < txPrev.nTime)
            return false;  // Transaction timestamp violation

        // Read block header
        CBlock block;
        if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))
            return false; // unable to read block of previous transaction
        if (block.GetBlockTime() + nStakeMinAge > nTime)
            continue; // only count coins meeting min age requirement

        int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;
        bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;

        if (fDebug && GetBoolArg("-printcoinage"))
            printf("coin age nValueIn=%"PRId64" nTimeDiff=%d bnCentSecond=%s\n", nValueIn, nTime - txPrev.nTime, bnCentSecond.ToString().c_str());
    }

    CBigNum bnCoinDay = bnCentSecond * CENT / COIN / (24 * 60 * 60);
    if (fDebug && GetBoolArg("-printcoinage"))
        printf("coin age bnCoinDay=%s\n", bnCoinDay.ToString().c_str());
    nCoinAge = bnCoinDay.getuint64();
    return true;
}

// ppcoin: total coin age spent in block, in the unit of coin-days.
bool CBlock::GetCoinAge(uint64_t& nCoinAge) const
{
    nCoinAge = 0;

    CTxDB txdb("r");
    BOOST_FOREACH(const CTransaction& tx, vtx)
    {
        uint64_t nTxCoinAge;
        if (tx.GetCoinAge(txdb, nTxCoinAge))
            nCoinAge += nTxCoinAge;
        else
            return false;
    }

    if (nCoinAge == 0) // block coin age minimum 1 coin-day
        nCoinAge = 1;
    if (fDebug && GetBoolArg("-printcoinage"))
        printf("block coin age total nCoinDays=%"PRId64"\n", nCoinAge);
    return true;
}

bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, const uint256& hashProof)
{
    // Check for duplicate
    uint256 hash = GetHash();
    if (mapBlockIndex.count(hash))
        return error("AddToBlockIndex() : %s already exists", hash.ToString().substr(0,20).c_str());

    // Construct new block index object
    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);
    if (!pindexNew)
        return error("AddToBlockIndex() : new CBlockIndex failed");
    pindexNew->phashBlock = &hash;
    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);
    if (miPrev != mapBlockIndex.end())
    {
        pindexNew->pprev = (*miPrev).second;
        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;
    }

    // ppcoin: compute chain trust score
    pindexNew->nChainTrust = (pindexNew->pprev ? pindexNew->pprev->nChainTrust : 0) + pindexNew->GetBlockTrust();

    // ppcoin: compute stake entropy bit for stake modifier
    if (!pindexNew->SetStakeEntropyBit(GetStakeEntropyBit()))
        return error("AddToBlockIndex() : SetStakeEntropyBit() failed");

    // Record proof hash value
    pindexNew->hashProof = hashProof;

    // ppcoin: compute stake modifier
    uint64_t nStakeModifier = 0;
    bool fGeneratedStakeModifier = false;
    if (!ComputeNextStakeModifier(pindexNew->pprev, nStakeModifier, fGeneratedStakeModifier))
	{
        printf("AddToBlockIndex() : ComputeNextStakeModifier() failed");
	}
    pindexNew->SetStakeModifier(nStakeModifier, fGeneratedStakeModifier);
    pindexNew->nStakeModifierChecksum = GetStakeModifierChecksum(pindexNew);

    // Add to mapBlockIndex
    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;
    if (pindexNew->IsProofOfStake())
        setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));
    pindexNew->phashBlock = &((*mi).first);

    // Write to disk block index
    CTxDB txdb;
    if (!txdb.TxnBegin())
        return false;
    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));
    if (!txdb.TxnCommit())
        return false;

    LOCK(cs_main);

    // New best
    if (pindexNew->nChainTrust > nBestChainTrust)
        if (!SetBestChain(txdb, pindexNew))
            return false;

    if (pindexNew == pindexBest)
    {
        // Notify UI to display prev block's coinbase if it was ours
        static uint256 hashPrevBestCoinBase;
        UpdatedTransaction(hashPrevBestCoinBase);
        hashPrevBestCoinBase = vtx[0].GetHash();
    }

    uiInterface.NotifyBlocksChanged();
    return true;
}



int BlockHeight(uint256 bh)
{
	int nGridHeight=0;
	map<uint256, CBlockIndex*>::iterator iMapIndex = mapBlockIndex.find(bh);
    if (iMapIndex != mapBlockIndex.end())
	{
		 CBlockIndex* pPrev = (*iMapIndex).second;
		 nGridHeight = pPrev->nHeight+1;
	}
	return nGridHeight;
}


bool CBlock::CheckBlock(std::string sCaller, int height1, int64_t Mint, bool fCheckPOW, bool fCheckMerkleRoot, bool fCheckSig, bool fLoadingIndex) const
{

	if (GetHash()==hashGenesisBlock || GetHash()==hashGenesisBlockTestNet) return true;
	// These are checks that are independent of context
    // that can be verified before saving an orphan block.

    // Size limits
    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)
        return DoS(100, error("CheckBlock[] : size limits failed"));

    // Check proof of work matches claimed amount
    if (fCheckPOW && IsProofOfWork() && !CheckProofOfWork(GetPoWHash(), nBits))
        return DoS(50, error("CheckBlock[] : proof of work failed"));

	//Reject blocks with diff that has grown to an extrordinary level (should never happen)
	double blockdiff = GetBlockDifficulty(nBits);
	if (height1 > nGrandfather && blockdiff > 10000000000000000)
	{
  	   return DoS(1, error("CheckBlock[] : Block Bits larger than 10000000000000000.\r\n"));
	}

    // First transaction must be coinbase, the rest must not be
    if (vtx.empty() || !vtx[0].IsCoinBase())
        return DoS(100, error("CheckBlock[] : first tx is not coinbase"));
    for (unsigned int i = 1; i < vtx.size(); i++)
        if (vtx[i].IsCoinBase())
            return DoS(100, error("CheckBlock[] : more than one coinbase"));

	//Research Age
	MiningCPID bb = DeserializeBoincBlock(vtx[0].hashBoinc);
	//For higher security, plus lets catch these bad blocks before adding them to the chain to prevent reorgs:
	double OUT_POR = 0;
	double OUT_INTEREST = 0;
	double dAccrualAge = 0;
	double dMagnitudeUnit = 0;
	double dAvgMagnitude = 0;
	int64_t nCoinAge = 0;
	int64_t nFees = 0;

	if (bb.cpid != "INVESTOR" && IsProofOfStake() && height1 > nGrandfather && IsResearchAgeEnabled(height1) && BlockNeedsChecked(nTime) && !fLoadingIndex)
	{
			int64_t nCalculatedResearch = GetProofOfStakeReward(nCoinAge, nFees, bb.cpid, true, 1, nTime,
				pindexBest, sCaller + "_checkblock_researcher", OUT_POR, OUT_INTEREST, dAccrualAge, dMagnitudeUnit, dAvgMagnitude);
			if (bb.ResearchSubsidy > ((OUT_POR*1.25)+1))
			{
				BusyWaitForTally();
				StructCPID st1 = GetLifetimeCPID(bb.cpid,"CheckBlock()");
				nCalculatedResearch = GetProofOfStakeReward(nCoinAge, nFees, bb.cpid, true, 2, nTime,
					pindexBest, sCaller + "_checkblock_researcher_doublecheck", OUT_POR, OUT_INTEREST, dAccrualAge, dMagnitudeUnit, dAvgMagnitude);

				if (bb.ResearchSubsidy > ((OUT_POR*1.25)+1))
				{

							if (fDebug3) printf("CheckBlock[ResearchAge] : Researchers Reward Pays too much : Interest %f and Research %f and StakeReward %f, OUT_POR %f, with Out_Interest %f for CPID %s ",
									(double)bb.InterestSubsidy,(double)bb.ResearchSubsidy,CoinToDouble(nCalculatedResearch),(double)OUT_POR,(double)OUT_INTEREST,bb.cpid.c_str());
							/*
							if (msPrimaryCPID == bb.cpid)
							{
								//bStakeMinerOutOfSyncWithNetwork=true;
								//return false;
							}
							*/

							return DoS(10,error("CheckBlock[ResearchAge] : Researchers Reward Pays too much : Interest %f and Research %f and StakeReward %f, OUT_POR %f, with Out_Interest %f for CPID %s ",
									(double)bb.InterestSubsidy,(double)bb.ResearchSubsidy,CoinToDouble(nCalculatedResearch),(double)OUT_POR,(double)OUT_INTEREST,bb.cpid.c_str()));
							// Reserved for future use.
				}
			}
	
	}


	//ProofOfResearch
	if (vtx.size() > 0)
	{
	//Orphan Flood Attack
			if (height1 > nGrandfather)
			{
					double bv = BlockVersion(bb.clientversion);
					double cvn = ClientVersionNew();
					if (fDebug10) printf("BV %f, CV %f   ",bv,cvn);
					//if (bv+10 < cvn) return error("ConnectBlock[]: Old client version after mandatory upgrade - block rejected\r\n");
					if (bv < 3517 && IsResearchAgeEnabled(height1) && !fTestNet) return error("CheckBlock[]:  Old client spamming new blocks after mandatory upgrade \r\n");
					if (bv < 3546 && fTestNet) return DoS(25, error("CheckBlock[]:  Old testnet client spamming new blocks after mandatory upgrade \r\n"));
			}

			if (bb.cpid != "INVESTOR" && height1 > nGrandfather)
			{
    			if (bb.projectname.empty() && !IsResearchAgeEnabled(height1)) 	return DoS(1,error("CheckBlock::PoR Project Name invalid"));
	    		if (!IsCPIDValidv2(bb,height1))
				{
						return error("Bad CPID : height %f, CPID %s, cpidv2 %s, LBH %s, Bad Hashboinc %s",(double)height1,
							bb.cpid.c_str(), bb.cpidv2.c_str(),
							bb.lastblockhash.c_str(), vtx[0].hashBoinc.c_str());
				}

			}

		    // Gridcoin: check proof-of-stake block signature
			if (IsProofOfStake() && height1 > nGrandfather)
			{
				//Mint limiter checks 1-20-2015
				double PORDiff = GetBlockDifficulty(nBits);
				double mint1 = CoinToDouble(Mint);
				double total_subsidy = bb.ResearchSubsidy + bb.InterestSubsidy;
				if (fDebug10) printf("CheckBlock[]: TotalSubsidy %f, Height %f, %s, %f, Res %f, Interest %f, hb: %s \r\n",
					    (double)total_subsidy,(double)height1, bb.cpid.c_str(),
						(double)mint1,bb.ResearchSubsidy,bb.InterestSubsidy,vtx[0].hashBoinc.c_str());
				if (total_subsidy < MintLimiter(PORDiff,bb.RSAWeight,bb.cpid,GetBlockTime()))
				{
					if (fDebug3) printf("****CheckBlock[]: Total Mint too Small %s, mint %f, Res %f, Interest %f, hash %s \r\n",bb.cpid.c_str(),
						(double)mint1,bb.ResearchSubsidy,bb.InterestSubsidy,vtx[0].hashBoinc.c_str());
					//1-21-2015 - Prevent Hackers from spamming the network with small blocks
					return error("****CheckBlock[]: Total Mint too Small %s, mint %f, Res %f, Interest %f, hash %s \r\n",bb.cpid.c_str(),
							(double)mint1,bb.ResearchSubsidy,bb.InterestSubsidy,vtx[0].hashBoinc.c_str());
				}

	    		if (fCheckSig && !CheckBlockSignature())
					return DoS(100, error("CheckBlock[] : bad proof-of-stake block signature"));
			}


		}
		else
		{
			return false;
		}

	// End of Proof Of Research

    if (IsProofOfStake())
    {
		//4-2-2015 Verify each POR recipient is owed > paid - CryptoLottery
        // Coinbase output should be empty if proof-of-stake block
        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())
            return DoS(100, error("CheckBlock[] : coinbase output not empty for proof-of-stake block"));

        // Second transaction must be coinstake, the rest must not be
        if (vtx.empty() || !vtx[1].IsCoinStake())
            return DoS(100, error("CheckBlock[] : second tx is not coinstake"));

	    for (unsigned int i = 2; i < vtx.size(); i++)
		{
            if (vtx[i].IsCoinStake())
			{
				printf("Found more than one coinstake in coinbase at location %f\r\n",(double)i);
                return DoS(100, error("CheckBlock[] : more than one coinstake"));
			}
		}

    }

    // Check transactions
    BOOST_FOREACH(const CTransaction& tx, vtx)
    {
        if (!tx.CheckTransaction())
            return DoS(tx.nDoS, error("CheckBlock[] : CheckTransaction failed"));

        // ppcoin: check transaction timestamp
        if (GetBlockTime() < (int64_t)tx.nTime)
            return DoS(50, error("CheckBlock[] : block timestamp earlier than transaction timestamp"));
    }

    // Check for duplicate txids. This is caught by ConnectInputs(),
    // but catching it earlier avoids a potential DoS attack:
    set<uint256> uniqueTx;
    BOOST_FOREACH(const CTransaction& tx, vtx)
    {
        uniqueTx.insert(tx.GetHash());
    }
    if (uniqueTx.size() != vtx.size())
        return DoS(100, error("CheckBlock[] : duplicate transaction"));

    unsigned int nSigOps = 0;
    BOOST_FOREACH(const CTransaction& tx, vtx)
    {
        nSigOps += tx.GetLegacySigOpCount();
    }
    if (nSigOps > MAX_BLOCK_SIGOPS)
        return DoS(100, error("CheckBlock[] : out-of-bounds SigOpCount"));

    // Check merkle root
    if (fCheckMerkleRoot && hashMerkleRoot != BuildMerkleTree())
        return DoS(100, error("CheckBlock[] : hashMerkleRoot mismatch"));

	//if (fDebug3) printf(".EOCB.");
    return true;
}

bool CBlock::AcceptBlock(bool generated_by_me)
{
    AssertLockHeld(cs_main);

    if (nVersion > CURRENT_VERSION)
        return DoS(100, error("AcceptBlock() : reject unknown block version %d", nVersion));

    // Check for duplicate
    uint256 hash = GetHash();
    if (mapBlockIndex.count(hash))
        return error("AcceptBlock() : block already in mapBlockIndex");

    // Get prev block index
    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);
    if (mi == mapBlockIndex.end())
        return DoS(10, error("AcceptBlock() : prev block not found"));
    CBlockIndex* pindexPrev = (*mi).second;
    int nHeight = pindexPrev->nHeight+1;

    if (IsProtocolV2(nHeight) && nVersion < 7)
        return DoS(100, error("AcceptBlock() : reject too old nVersion = %d", nVersion));
    else if (!IsProtocolV2(nHeight) && nVersion > 6)
        return DoS(100, error("AcceptBlock() : reject too new nVersion = %d", nVersion));

    if (IsProofOfWork() && nHeight > LAST_POW_BLOCK)
        return DoS(100, error("AcceptBlock() : reject proof-of-work at height %d", nHeight));

	if (nHeight > nGrandfather)
	{
			// Check coinbase timestamp
			if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime, nHeight))
			{
				return DoS(80, error("AcceptBlock() : coinbase timestamp is too early"));
			}
			// Check timestamp against prev
			if (GetBlockTime() <= pindexPrev->GetPastTimeLimit() || FutureDrift(GetBlockTime(), nHeight) < pindexPrev->GetBlockTime())
				return DoS(60, error("AcceptBlock() : block's timestamp is too early"));
    		// Check proof-of-work or proof-of-stake
	    	if (nBits != GetNextTargetRequired(pindexPrev, IsProofOfStake()))
				return DoS(100, error("AcceptBlock() : incorrect %s", IsProofOfWork() ? "proof-of-work" : "proof-of-stake"));
	}


    // Check that all transactions are finalized
    BOOST_FOREACH(const CTransaction& tx, vtx)
        if (!IsFinalTx(tx, nHeight, GetBlockTime()))
            return DoS(10, error("AcceptBlock() : contains a non-final transaction"));

    // Check that the block chain matches the known block chain up to a checkpoint
    if (!Checkpoints::CheckHardened(nHeight, hash))
        return DoS(100, error("AcceptBlock() : rejected by hardened checkpoint lock-in at %d", nHeight));

    uint256 hashProof;

    // Verify hash target and signature of coinstake tx
	if (nHeight > nGrandfather)
	{
				if (IsProofOfStake())
				{
					uint256 targetProofOfStake;
					if (!CheckProofOfStake(pindexPrev, vtx[1], nBits, hashProof, targetProofOfStake, vtx[0].hashBoinc, generated_by_me, nNonce) && IsLockTimeWithinMinutes(GetBlockTime(),600))
					{
						return error("WARNING: AcceptBlock(): check proof-of-stake failed for block %s, nonce %f    \n", hash.ToString().c_str(),(double)nNonce);
					}

				}
	}


    // PoW is checked in CheckBlock[]
    if (IsProofOfWork())
    {
        hashProof = GetPoWHash();
    }

	//Grandfather
	if (nHeight > nGrandfather)
	{
		 bool cpSatisfies = Checkpoints::CheckSync(hash, pindexPrev);
 		 // Check that the block satisfies synchronized checkpoint
		 if (CheckpointsMode == Checkpoints::STRICT && !cpSatisfies)
		 {
			if (CHECKPOINT_DISTRIBUTED_MODE==1)
			{
				CHECKPOINT_VIOLATIONS++;
				if (CHECKPOINT_VIOLATIONS > 3)
				{
					//For stability, move the client into ADVISORY MODE:
					printf("Moving Gridcoin into Checkpoint ADVISORY mode.\r\n");
					CheckpointsMode = Checkpoints::ADVISORY;
				}
			}
			return error("AcceptBlock() : rejected by synchronized checkpoint");
		 }

		if (CheckpointsMode == Checkpoints::ADVISORY && !cpSatisfies)
			strMiscWarning = _("WARNING: synchronized checkpoint violation detected, but skipped!");

		if (CheckpointsMode == Checkpoints::ADVISORY && cpSatisfies && CHECKPOINT_DISTRIBUTED_MODE==1)
		{
			///Move the client back into STRICT mode
			CHECKPOINT_VIOLATIONS = 0;
			printf("Moving Gridcoin into Checkpoint STRICT mode.\r\n");
			strMiscWarning = "";
			CheckpointsMode = Checkpoints::STRICT;
		}

		// Enforce rule that the coinbase starts with serialized block height
		CScript expect = CScript() << nHeight;
		if (vtx[0].vin[0].scriptSig.size() < expect.size() ||
			!std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))
			return DoS(100, error("AcceptBlock() : block height mismatch in coinbase"));
	}

    // Write block to history file
    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))
        return error("AcceptBlock() : out of disk space");
    unsigned int nFile = -1;
    unsigned int nBlockPos = 0;
    if (!WriteToDisk(nFile, nBlockPos))
        return error("AcceptBlock() : WriteToDisk failed");
    if (!AddToBlockIndex(nFile, nBlockPos, hashProof))
        return error("AcceptBlock() : AddToBlockIndex failed");

    // Relay inventory, but don't relay old inventory during initial block download
    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();
    if (hashBestChain == hash)
    {
        LOCK(cs_vNodes);
        BOOST_FOREACH(CNode* pnode, vNodes)
            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))
                pnode->PushInventory(CInv(MSG_BLOCK, hash));
    }

    // ppcoin: check pending sync-checkpoint
    Checkpoints::AcceptPendingSyncCheckpoint();
	if (fDebug) printf("{ACC}");
	nLastAskedForBlocks=GetAdjustedTime();
	ResetTimerMain("OrphanBarrage");
    return true;
}


uint256 CBlockIndex::GetBlockTrust() const
{
    CBigNum bnTarget;
    bnTarget.SetCompact(nBits);
    if (bnTarget <= 0) return 0;
	int64_t block_mag = 0;
	uint256 chaintrust = (((CBigNum(1)<<256) / (bnTarget+1)) - (block_mag)).getuint256();
	return chaintrust;
}

bool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned int nRequired, unsigned int nToCheck)
{
    unsigned int nFound = 0;
    for (unsigned int i = 0; i < nToCheck && nFound < nRequired && pstart != NULL; i++)
    {
        if (pstart->nVersion >= minVersion)
            ++nFound;
        pstart = pstart->pprev;
    }
    return (nFound >= nRequired);
}

/*
bool static ReserealizeBlockSignature(CBlock* pblock)
{
    if (pblock->IsProofOfWork()) {
        pblock->vchBlockSig.clear();
        return true;
    }

    return CKey::ReserealizeSignature(pblock->vchBlockSig);
}
*/


bool ServicesIncludesNN(CNode* pNode)
{
	return (Contains(pNode->strSubVer,"1999")) ? true : false;
}

bool VerifySuperblock(std::string superblock, int nHeight)
{
	    bool bPassed = false;
		double out_avg = 0;
		double out_beacon_count=0;
		double out_participant_count=0;
		double avg_mag = 0;
		if (superblock.length() > 20)
		{
			avg_mag = GetSuperblockAvgMag(superblock,out_beacon_count,out_participant_count,out_avg,false);
			bPassed=true;
			if (!IsResearchAgeEnabled(nHeight))
			{
				return (avg_mag < 10 ? false : true);
			}
			// New rules added here:
			if (out_avg < 10 && fTestNet)  bPassed = false;
			if (out_avg < 70 && !fTestNet) bPassed = false;
			if (avg_mag < 10)              bPassed = false;
		}
		if (fDebug3 && !bPassed)
		{
			if (fDebug) printf(" Verification of Superblock Failed ");
			//			printf("\r\n Verification of Superblock Failed outavg: %f, avg_mag %f, Height %f, Out_Beacon_count %f, Out_participant_count %f, block %s",	(double)out_avg,(double)avg_mag,(double)nHeight,(double)out_beacon_count,(double)out_participant_count,superblock.c_str());
		}
		return bPassed;
}

bool NeedASuperblock()
{
		bool bDireNeedOfSuperblock = false;
		std::string superblock = ReadCache("superblock","all");
		if (superblock.length() > 20 && !OutOfSyncByAge())
		{
			if (!VerifySuperblock(superblock,pindexBest->nHeight)) bDireNeedOfSuperblock = true;
		}
		int64_t superblock_age = GetAdjustedTime() - mvApplicationCacheTimestamp["superblock;magnitudes"];
		if ((double)superblock_age > (double)(GetSuperblockAgeSpacing(nBestHeight))) bDireNeedOfSuperblock = true;
		return bDireNeedOfSuperblock;
}




void GridcoinServices()
{

	//Dont do this on headless - SeP
	#if defined(QT_GUI)
	   if ((nBestHeight % 100) == 0)
	   {
			GetGlobalStatus();
			bForceUpdate=true;
			uiInterface.NotifyBlocksChanged();
	   }
    #endif
	// Services thread activity
    if (fDebug10) printf(" {SVC} ");

	//This is Gridcoins Service thread; called once per block
	if (nBestHeight > 100 && nBestHeight < 200)
	{
		if (GetArg("-suppressdownloadblocks", "true") == "false")
		{
			std::string email = GetArgument("email", "NA");
			if (email.length() > 5 && !mbBlocksDownloaded)
			{
				#if defined(WIN32) && defined(QT_GUI)
					mbBlocksDownloaded=true;
					DownloadBlocks();
				#endif
			}
		}
	}
	//Dont perform the following functions if out of sync
	if (pindexBest->nHeight < nGrandfather) return;
    if (OutOfSyncByAge()) return;

	//Backup the wallet once per 900 blocks:
	double dWBI = cdbl(GetArgument("walletbackupinterval", "900"),0);
	
	if (TimerMain("backupwallet", dWBI))
	{
		std::string backup_results = BackupGridcoinWallet();
		printf("Daily backup results: %s\r\n",backup_results.c_str());
	}

	if (TimerMain("ResetVars",30))
	{
		bTallyStarted = false;
	}
	
	if (TimerMain("OutOfSyncDaily",900))
	{
		if (WalletOutOfSync())
		{
			printf("Restarting Gridcoin...");
			#if defined(WIN32) && defined(QT_GUI)
				int iResult = RestartClient();
			#endif
		}
	}

	if (false && TimerMain("FixSpentCoins",60))
	{
			int nMismatchSpent;
			int64_t nBalanceInQuestion;
			pwalletMain->FixSpentCoins(nMismatchSpent, nBalanceInQuestion);
    }

	if (TimerMain("MyNeuralMagnitudeReport",30))
	{
		try
		{
			if (msNeuralResponse.length() < 25 && msPrimaryCPID != "INVESTOR" && !msPrimaryCPID.empty())
			{
				AsyncNeuralRequest("explainmag",msPrimaryCPID,5);
				if (fDebug3) printf("Async explainmag sent for %s.",msPrimaryCPID.c_str());
			}
			// Run the RSA report for the overview page:
		    if (!msPrimaryCPID.empty() && msPrimaryCPID != "INVESTOR")
			{
				if (fDebug3) printf("updating rsa\r\n");
				MagnitudeReport(msPrimaryCPID);
				if (fDebug3) printf("updated rsa\r\n");
			}
			if (fDebug3) printf("\r\n MR Complete \r\n");
		}
		catch (std::exception &e)
		{
			printf("Error in MyNeuralMagnitudeReport1.");
		}
		catch(...)
		{
			printf("Error in MyNeuralMagnitudeReport.");
		}
	}

	int64_t superblock_age = GetAdjustedTime() - mvApplicationCacheTimestamp["superblock;magnitudes"];
	bool bNeedSuperblock = ((double)superblock_age > (double)(GetSuperblockAgeSpacing(nBestHeight)));
	if ( nBestHeight % 3 == 0 && NeedASuperblock() ) bNeedSuperblock=true;

	if (fDebug10) 
	{
			printf (" MRSA %f, BH %f ",(double)superblock_age,(double)nBestHeight);
	}

	if (bNeedSuperblock)
	{
		if ((nBestHeight % 3) == 0)
		{
			if (fDebug3) printf("#CNNSH# ");
			ComputeNeuralNetworkSupermajorityHashes();
			UpdateNeuralNetworkQuorumData();
		}
		if ((nBestHeight % 20) == 0)
		{
			if (fDebug3) printf("#TIB# ");
			bDoTally = true;
		}
	}
	else
	{
		// When superblock is not old, Tally every N mins:
		int nTallyGranularity = fTestNet ? 60 : 20;
		if ((nBestHeight % nTallyGranularity) == 0)
		{
			    if (fDebug3) printf("TIB1 ");
			    bDoTally = true;
				if (fDebug3) printf("CNNSH2 ");
				ComputeNeuralNetworkSupermajorityHashes();
		}

		if ((nBestHeight % 5)==0)
		{
				UpdateNeuralNetworkQuorumData();
		}

	}

	// Keep Local Neural Network in Sync once every 1/2 day
	if (TimerMain("SyncNeuralNetwork",500))
	{
		FullSyncWithDPORNodes();
	}


	// Every N blocks as a Synchronized TEAM:
	if ((nBestHeight % 30) == 0)
	{
		//Sync RAC with neural network IF superblock is over 24 hours Old, Or if we have No superblock (in case of the latter, age will be 45 years old)
		// Note that nodes will NOT accept superblocks without a supermajority hash, so the last block will not be in memory unless it is a good superblock.
		// Let's start syncing the neural network as soon as the LAST superblock is over 12 hours old.
		// Also, lets do this as a TEAM exactly every 30 blocks (~30 minutes) to try to reach an EXACT consensus every half hour:
		// For effeciency, the network sleeps for 20 hours after a good superblock is accepted
		if (NeedASuperblock() && NeuralNodeParticipates())
		{
			if (fDebug3) printf("FSWDPOR ");
			FullSyncWithDPORNodes();
		}
	}

	if (( (nBestHeight-10) % 30 ) == 0)
	{
			// 10 Blocks after the network started syncing the neural network as a team, ask the neural network to come to a quorum
			if (NeedASuperblock() && NeuralNodeParticipates())
			{
				// First verify my node has a synced contract
				std::string contract = "";
				#if defined(WIN32) && defined(QT_GUI)
					contract = qtGetNeuralContract("");
				#endif
				if (VerifySuperblock(contract,nBestHeight))
				{
						AsyncNeuralRequest("quorum","gridcoin",25);
				}
			}
	}


	if (TimerMain("send_beacon",180))
	{
		std::string sOutPubKey = "";
		std::string sOutPrivKey = "";
		std::string sError = "";
		std::string sMessage = "";
		bool fResult = AdvertiseBeacon(true,sOutPrivKey,sOutPubKey,sError,sMessage);
		if (!fResult)
		{
			printf("BEACON ERROR!  Unable to send beacon %s \r\n",sError.c_str());
			printf("BEACON ERROR!  Unable to send beacon %s \r\n",sMessage.c_str());
			msMiningErrors6 = "Unable To Send Beacon! Unlock Wallet!";
		}
	}

	if (false && TimerMain("GridcoinPersistedDataSystem",5))
	{
		std::string errors1 = "";
		LoadAdminMessages(false,errors1);
	}

	if (KeyEnabled("exportmagnitude"))
	{
		if (TimerMain("export_magnitude",900))
		{
			json_spirit::Array results;
		    results = MagnitudeReportCSV(true);

		}
	}

	if (TimerMain("gather_cpids",480))
	{
			//if (fDebug10) printf("\r\nReharvesting cpids in background thread...\r\n");
			//LoadCPIDsInBackground();
			//printf(" {CPIDs Re-Loaded} ");
			msNeuralResponse="";
	}

	if (TimerMain("clearcache",1000))
	{
		ClearCache("neural_data");
	}

	if (TimerMain("check_for_autoupgrade",240))
	{
		if (fDebug3) printf("Checking for upgrade...");
		bCheckedForUpgradeLive = true;
	}

	#if defined(WIN32) && defined(QT_GUI)
		if (bCheckedForUpgradeLive && !fTestNet && bProjectsInitialized && bGlobalcomInitialized)
		{
			bCheckedForUpgradeLive=false;
			printf("{Checking for Upgrade} ");
			CheckForUpgrade();
			printf("{Done checking for upgrade} ");
		}
	#endif
    if (fDebug10) printf(" {/SVC} ");

}



bool AskForOutstandingBlocks(uint256 hashStart)
{
	if (IsLockTimeWithinMinutes(nLastAskedForBlocks,2)) return true;
	nLastAskedForBlocks = GetAdjustedTime();

	int iAsked = 0;
	LOCK(cs_vNodes);
	BOOST_FOREACH(CNode* pNode, vNodes) 
	{
				pNode->ClearBanned();
    			if (!pNode->fClient && !pNode->fOneShot && (pNode->nStartingHeight > (nBestHeight - 144)) && (pNode->nVersion < NOBLKS_VERSION_START || pNode->nVersion >= NOBLKS_VERSION_END) )
				{
					    if (hashStart==uint256(0))
						{
							pNode->PushGetBlocks(pindexBest, uint256(0), true);
						}
						else
						{
							CBlockIndex* pblockindex = mapBlockIndex[hashStart];
							if (pblockindex)
							{
	    						pNode->PushGetBlocks(pblockindex, uint256(0), true);
							}
							else
							{
								return error("Unable to find block index %s",hashStart.ToString().c_str());
							}
						}
						printf(".B.");
						iAsked++;
						if (iAsked > 10) break;
				}
	}
	return true;
}


void SyncChain()
{
     	if (IsLockTimeWithinMinutes(nLastResync,10))
	    {
			printf("Resync too soon or already in progress. \r\n");
			return;
	    }
		nLastResync = GetAdjustedTime();
		printf("\r\n * Sync Chain * \r\n");
		CleanChain();
		//std::string sOut = "";
		printf("\r\n * Finished * \r\n");
}




void CheckForLatestBlocks()
{
	if (WalletOutOfSync())
	{
			mapOrphanBlocks.clear();
			setStakeSeen.clear();
			setStakeSeenOrphan.clear();
			bool fResult = AskForOutstandingBlocks(uint256(0));
			printf("\r\n ** Clearing Orphan Blocks... ** \r\n");
	}
	
}

void CleanInboundConnections(bool bClearAll)
{
		if (IsLockTimeWithinMinutes(nLastCleaned,10)) return;
     	nLastCleaned = GetAdjustedTime();
	 	LOCK(cs_vNodes);
		BOOST_FOREACH(CNode* pNode, vNodes) 
		{
				pNode->ClearBanned();
				if (pNode->nStartingHeight < (nBestHeight-1000) || bClearAll)
				{
						pNode->fDisconnect=true;
				}
		}
		CheckForLatestBlocks();	
		printf("\r\n Cleaning inbound connections \r\n");
}

void ReloadBlockIndexHot()
{
		printf("\r\n * Recovering Node * \r\n");
	    AssertLockHeld(cs_main);
		{
			// clear vectors, clear orphans, clear mapindex
			mapOrphanBlocks.clear();
			mapBlockIndex.clear();
			setStakeSeen.clear();
			setStakeSeenOrphan.clear();
			mvResearchAge.clear();
			mapOrphanBlocks.clear();
			mapOrphanBlocksByPrev.clear();
			mvApplicationCache.clear();
			mvApplicationCacheTimestamp.clear();
			mvNeuralVersion.clear();
			mvDPOR.clear();
			mvDPORCopy.clear();
			mvBlockIndex.clear();
			mvCPIDBlockHashes.clear();
			LoadBlockIndex(true);
		}
		LOCK(cs_vNodes);
		BOOST_FOREACH(CNode* pNode, vNodes) 
		{
				pNode->ClearBanned();
	    		// Ask for some more blocks
				if (true)
				{
					if (!pNode->fClient && !pNode->fOneShot && (pNode->nStartingHeight > (nBestHeight - 144)) && (pNode->nVersion < NOBLKS_VERSION_START || pNode->nVersion >= NOBLKS_VERSION_END) )
					{
						pNode->PushGetBlocks(pindexBest, uint256(0), true);
					}
				}
				else
				{
					pNode->fDisconnect=true;
				}
		}
		printf("\r\n * Node Recovered * \r\n");
}

bool WalletOutOfSync()
{
	// Only trigger an out of sync condition if the node has synced near the best block prior to going out of sync.
	bool fOut = OutOfSyncByMoreThan(30);
	double PORDiff = GetDifficulty(GetLastBlockIndex(pindexBest, true));
	bool fGhostChain = (!fTestNet && PORDiff < .75);
	int iPeerBlocks = GetNumBlocksOfPeers();
	bool bSyncedCloseToTop = nBestHeight > iPeerBlocks-1000;
	if ((fOut || fGhostChain) && bSyncedCloseToTop) return true;
	return false;
}


bool WalletOutOfSyncByMoreThan2000Blocks()
{
	if (nBestHeight < GetNumBlocksOfPeers()-2000) return true;
	return false;
}



void CheckForFutileSync()
{
	// If we stay out of sync for more than 8 iterations of 25 orphans and never recover without accepting a block - attempt to recover the node- if we recover, reset the counters.
	// We reset these counters every time a block is accepted successfully in AcceptBlock().
	// Note: This code will never actually be exercised unless the wallet stays out of sync for a very long time - approx. 24 hours - the wallet normally recovers on its own without this code.
	// I'm leaving this in for people who may be on vacation for a long time - it may keep an external node running when everything else fails.
	if (WalletOutOfSync())
	{
		if (TimerMain("CheckForFutileSync", 25))
		{
			if (TimerMain("OrphansAndNotRecovering",8))									
			{
				printf("\r\nGridcoin has not recovered after clearing orphans; Restarting node...\r\n");
				#if defined(WIN32) && defined(QT_GUI)
					int iResult = RestartClient();
				#endif
			}
			else
			{
				mapAlreadyAskedFor.clear();
				printf("\r\nClearing mapAlreadyAskedFor.\r\n");
				mapOrphanBlocks.clear(); 
				setStakeSeen.clear();  
				setStakeSeenOrphan.clear();
				AskForOutstandingBlocks(uint256(0));
			}
		}
		else
		{
			ResetTimerMain("OrphansAndNotRecovering");
		}
	}
}

bool ProcessBlock(CNode* pfrom, CBlock* pblock, bool generated_by_me)
{
    AssertLockHeld(cs_main);

    // Check for duplicate
    uint256 hash = pblock->GetHash();
    if (mapBlockIndex.count(hash))
        return error("ProcessBlock() : already have block %d %s", mapBlockIndex[hash]->nHeight, hash.ToString().c_str());
    if (mapOrphanBlocks.count(hash))
        return error("ProcessBlock() : already have block (orphan) %s", hash.ToString().c_str());

    // ppcoin: check proof-of-stake
    // Limited duplicity on stake: prevents block flood attack
    // Duplicate stake allowed only when there is orphan child block
    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))
        return error("ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s", pblock->GetProofOfStake().first.ToString().c_str(),
		pblock->GetProofOfStake().second, 
		hash.ToString().c_str());

    CBlockIndex* pcheckpoint = Checkpoints::GetLastSyncCheckpoint();
    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain && !Checkpoints::WantedByPendingSyncCheckpoint(hash))
    {
        // Extra checks to prevent "fill up memory by spamming with bogus blocks"
        int64_t deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;
        if (deltaTime < -10*60)
        {
            if (pfrom)
                pfrom->Misbehaving(1);
            return error("ProcessBlock() : block with timestamp before last checkpoint");
        }


    }

    // Preliminary checks
    if (!pblock->CheckBlock("ProcessBlock", pindexBest->nHeight, 100*COIN))
        return error("ProcessBlock() : CheckBlock FAILED");

    // ppcoin: ask for pending sync-checkpoint if any
    if (!IsInitialBlockDownload())
        Checkpoints::AskForPendingSyncCheckpoint(pfrom);


    // If don't already have its previous block, shunt it off to holding area until we get it
    if (!mapBlockIndex.count(pblock->hashPrevBlock))
    {
		// *****      This area covers Gridcoin Orphan Handling      ***** 
		if (WalletOutOfSync())
		{
			if (TimerMain("OrphanBarrage",100))
			{
				mapAlreadyAskedFor.clear();
				printf("\r\nClearing mapAlreadyAskedFor.\r\n");
				AskForOutstandingBlocks(uint256(0));
				CheckForFutileSync();
			}
		}
		
		CBlock* pblock2 = new CBlock(*pblock);
		if (WalletOutOfSyncByMoreThan2000Blocks())
		{
			printf("ProcessBlock: ORPHAN BLOCK, prev=%s\n", pblock->hashPrevBlock.ToString().c_str());
			// ppcoin: check proof-of-stake
			if (pblock->IsProofOfStake())
			{
					// Limited duplicity on stake: prevents block flood attack
					// Duplicate stake allowed only when there is orphan child block
    				if (setStakeSeenOrphan.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))
							return error("ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());
						else
							setStakeSeenOrphan.insert(pblock->GetProofOfStake());
			}
			mapOrphanBlocks.insert(make_pair(hash, pblock2));
			mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));
		}

		// Ask this guy to fill in what we're missing
        if (pfrom)
        {
            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2), true);
            // ppcoin: getblocks may not obtain the ancestor block rejected
            // earlier by duplicate-stake check so we ask for it again directly
            if (!IsInitialBlockDownload())
                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));
			// Ask a few other nodes for the missing block

        }
        return true;
    }

    // Store to disk
    if (!pblock->AcceptBlock(generated_by_me))
        return error("ProcessBlock() : AcceptBlock FAILED");

    // Recursively process any orphan blocks that depended on this one
    vector<uint256> vWorkQueue;
    vWorkQueue.push_back(hash);
    for (unsigned int i = 0; i < vWorkQueue.size(); i++)
    {
        uint256 hashPrev = vWorkQueue[i];
        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);
             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);
             ++mi)
        {
            CBlock* pblockOrphan = (*mi).second;
            if (pblockOrphan->AcceptBlock(generated_by_me))
                vWorkQueue.push_back(pblockOrphan->GetHash());
            mapOrphanBlocks.erase(pblockOrphan->GetHash());
            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());
            delete pblockOrphan;
        }
        mapOrphanBlocksByPrev.erase(hashPrev);
    }

   
    // if responsible for sync-checkpoint send it
    if (false && pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());
	printf("{PB}: ACC; \r\n");
	GridcoinServices();
    return true;
}



// Gridcoin: (previously NovaCoin) : Attempt to generate suitable proof-of-stake
bool CBlock::SignBlock(CWallet& wallet, int64_t nFees)
{
    // if we are trying to sign
    //    something except proof-of-stake block template
    if (!vtx[0].vout[0].IsEmpty())
        return false;

    // if we are trying to sign
    //    a complete proof-of-stake block
    if (IsProofOfStake())
        return true;

    static int64_t nLastCoinStakeSearchTime = GetAdjustedTime(); // startup timestamp

    CKey key;
    CTransaction txCoinStake;
    if (IsProtocolV2(nBestHeight+1))
        txCoinStake.nTime &= ~STAKE_TIMESTAMP_MASK;

    int64_t nSearchTime = txCoinStake.nTime; // search to current time
	int64_t out_gridreward = 0;

    if (nSearchTime > nLastCoinStakeSearchTime)
    {
        int64_t nSearchInterval = IsProtocolV2(nBestHeight+1) ? 1 : nSearchTime - nLastCoinStakeSearchTime;
		std::string out_hashboinc = "";
        if (wallet.CreateCoinStake(wallet, nBits, nSearchInterval, nFees, txCoinStake, key, out_gridreward, out_hashboinc))
        {
			//1-8-2015 Extract solved Key
			double solvedNonce = cdbl(AppCache(pindexBest->GetBlockHash().GetHex()),0);
			nNonce=solvedNonce;
			if (fDebug3) printf(".17. Nonce %f, SNonce %f, StakeTime %f, MaxHistTD %f, BBPTL %f, PDBTm %f \r\n",
				(double)nNonce,(double)solvedNonce,(double)txCoinStake.nTime,
				(double)max(pindexBest->GetPastTimeLimit()+1, PastDrift(pindexBest->GetBlockTime(), pindexBest->nHeight+1)),
				(double)pindexBest->GetPastTimeLimit(), (double)PastDrift(pindexBest->GetBlockTime(), pindexBest->nHeight+1)	);
		    if (txCoinStake.nTime >= max(pindexBest->GetPastTimeLimit()+1, PastDrift(pindexBest->GetBlockTime(), pindexBest->nHeight+1)))
			{
                // make sure coinstake would meet timestamp protocol
                //    as it would be the same as the block timestamp
                vtx[0].nTime = nTime = txCoinStake.nTime;
                nTime = max(pindexBest->GetPastTimeLimit()+1, GetMaxTransactionTime());
                nTime = max(GetBlockTime(), PastDrift(pindexBest->GetBlockTime(), pindexBest->nHeight+1));


                // we have to make sure that we have no future timestamps in
                //    our transactions set
                for (vector<CTransaction>::iterator it = vtx.begin(); it != vtx.end();)
                    if (it->nTime > nTime) { it = vtx.erase(it); } else { ++it; }
                vtx.insert(vtx.begin() + 1, txCoinStake);
				vtx[0].hashBoinc= out_hashboinc;

                hashMerkleRoot = BuildMerkleTree();
				return key.Sign(GetHash(), vchBlockSig);
			}
        }
        nLastCoinStakeSearchInterval = nSearchTime - nLastCoinStakeSearchTime;
        nLastCoinStakeSearchTime = nSearchTime;
    }

    return false;
}

bool CBlock::CheckBlockSignature() const
{
    if (IsProofOfWork())
        return vchBlockSig.empty();

    vector<valtype> vSolutions;
    txnouttype whichType;

    const CTxOut& txout = vtx[1].vout[1];

    if (!Solver(txout.scriptPubKey, whichType, vSolutions))
        return false;

    if (whichType == TX_PUBKEY)
    {
        valtype& vchPubKey = vSolutions[0];
        CKey key;
        if (!key.SetPubKey(vchPubKey))
            return false;
        if (vchBlockSig.empty())
            return false;
        return key.Verify(GetHash(), vchBlockSig);
    }

    return false;
}

bool CheckDiskSpace(uint64_t nAdditionalBytes)
{
    uint64_t nFreeBytesAvailable = filesystem::space(GetDataDir()).available;

    // Check for nMinDiskSpace bytes (currently 50MB)
    if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)
    {
        fShutdown = true;
        string strMessage = _("Warning: Disk space is low!");
        strMiscWarning = strMessage;
        printf("*** %s\n", strMessage.c_str());
        uiInterface.ThreadSafeMessageBox(strMessage, "Gridcoin", CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);
        StartShutdown();
        return false;
    }
    return true;
}

static filesystem::path BlockFilePath(unsigned int nFile)
{
    string strBlockFn = strprintf("blk%04u.dat", nFile);
    return GetDataDir() / strBlockFn;
}

FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)
{
    if ((nFile < 1) || (nFile == (unsigned int) -1))
        return NULL;
    FILE* file = fopen(BlockFilePath(nFile).string().c_str(), pszMode);
    if (!file)
        return NULL;
    if (nBlockPos != 0 && !strchr(pszMode, 'a') && !strchr(pszMode, 'w'))
    {
        if (fseek(file, nBlockPos, SEEK_SET) != 0)
        {
            fclose(file);
            return NULL;
        }
    }
    return file;
}

static unsigned int nCurrentBlockFile = 1;

FILE* AppendBlockFile(unsigned int& nFileRet)
{
    nFileRet = 0;
    while (true)
    {
        FILE* file = OpenBlockFile(nCurrentBlockFile, 0, "ab");
        if (!file)
            return NULL;
        if (fseek(file, 0, SEEK_END) != 0)
            return NULL;
        // FAT32 file size max 4GB, fseek and ftell max 2GB, so we must stay under 2GB
        if (ftell(file) < (long)(0x7F000000 - MAX_SIZE))
        {
            nFileRet = nCurrentBlockFile;
            return file;
        }
        fclose(file);
        nCurrentBlockFile++;
    }
}

bool LoadBlockIndex(bool fAllowNew)
{
    LOCK(cs_main);

    CBigNum bnTrustedModulus;

    if (fTestNet)
    {
		// GLOBAL TESTNET SETTINGS - R HALFORD
        pchMessageStart[0] = 0xcd;
        pchMessageStart[1] = 0xf2;
        pchMessageStart[2] = 0xc0;
        pchMessageStart[3] = 0xef;
        bnProofOfWorkLimit = bnProofOfWorkLimitTestNet; // 16 bits PoW target limit for testnet
        nStakeMinAge = 1 * 60 * 60; // test net min age is 1 hour
        nCoinbaseMaturity = 10; // test maturity is 10 blocks
		nGrandfather = 103307;
		nNewIndex = 10;
		nNewIndex2 = 36500;
		bRemotePaymentsEnabled = false;
		bNewbieFeatureEnabled = true;
		bOPReturnEnabled = false;
		bOptionPaymentsEnabled = false;
		//1-24-2016
		MAX_OUTBOUND_CONNECTIONS = (int)GetArg("-maxoutboundconnections", 8);
    }


	std::string mode = fTestNet ? "TestNet" : "Prod";
	printf("Mode=%s\r\n",mode.c_str());


    //
    // Load block index
    //
    CTxDB txdb("cr+");
    if (!txdb.LoadBlockIndex())
        return false;

    //
    // Init with genesis block
    //
    if (mapBlockIndex.empty())
    {
        if (!fAllowNew)
            return false;

        // Genesis block - Genesis2
        // MainNet - Official New Genesis Block:
		////////////////////////////////////////
		/*
	 21:58:24 block.nTime = 1413149999
	10/12/14 21:58:24 block.nNonce = 1572771
	10/12/14 21:58:24 block.GetHash = 00000f762f698b5962aa81e38926c3a3f1f03e0b384850caed34cd9164b7f990
	10/12/14 21:58:24 CBlock(hash=00000f762f698b5962aa81e38926c3a3f1f03e0b384850caed34cd9164b7f990, ver=1,
	hashPrevBlock=0000000000000000000000000000000000000000000000000000000000000000,
	hashMerkleRoot=0bd65ac9501e8079a38b5c6f558a99aea0c1bcff478b8b3023d09451948fe841, nTime=1413149999, nBits=1e0fffff, nNonce=1572771, vtx=1, vchBlockSig=)
	10/12/14 21:58:24   Coinbase(hash=0bd65ac950, nTime=1413149999, ver=1, vin.size=1, vout.size=1, nLockTime=0)
    CTxIn(COutPoint(0000000000, 4294967295), coinbase 00012a4531302f31312f313420416e6472656120526f73736920496e647573747269616c20486561742076696e646963617465642077697468204c454e522076616c69646174696f6e)
    CTxOut(empty)
	vMerkleTree: 0bd65ac950

		*/

		const char* pszTimestamp = "10/11/14 Andrea Rossi Industrial Heat vindicated with LENR validation";

        CTransaction txNew;
		//GENESIS TIME
		txNew.nTime = 1413033777;
        txNew.vin.resize(1);
        txNew.vout.resize(1);
        txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));
        txNew.vout[0].SetEmpty();
        CBlock block;
        block.vtx.push_back(txNew);
        block.hashPrevBlock = 0;
        block.hashMerkleRoot = block.BuildMerkleTree();
        block.nVersion = 1;
		//R&D - Testers Wanted Thread:
		block.nTime    = !fTestNet ? 1413033777 : 1406674534;
		//Official Launch time:
        block.nBits    = bnProofOfWorkLimit.GetCompact();
		block.nNonce = !fTestNet ? 130208 : 22436;
    	printf("starting Genesis Check...");
	    // If genesis block hash does not match, then generate new genesis hash.
        if (block.GetHash() != hashGenesisBlock)
        {
            printf("Searching for genesis block...\n");
            // This will figure out a valid hash and Nonce if you're
            // creating a different genesis block: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000xFFF
			uint256 hashTarget = CBigNum().SetCompact(block.nBits).getuint256();
            uint256 thash;
            while (true)
            {
            	thash = block.GetHash();
				if (thash <= hashTarget)
                    break;
                if ((block.nNonce & 0xFFF) == 0)
                {
                    printf("nonce %08X: hash = %s (target = %s)\n", block.nNonce, thash.ToString().c_str(), hashTarget.ToString().c_str());
                }
                ++block.nNonce;
                if (block.nNonce == 0)
                {
                    printf("NONCE WRAPPED, incrementing time\n");
                    ++block.nTime;
                }
            }
            printf("block.nTime = %u \n", block.nTime);
            printf("block.nNonce = %u \n", block.nNonce);
            printf("block.GetHash = %s\n", block.GetHash().ToString().c_str());
        }


        block.print();

	    //// debug print

		//GENESIS3: Official Merkle Root
		uint256 merkle_root = uint256("0x5109d5782a26e6a5a5eb76c7867f3e8ddae2bff026632c36afec5dc32ed8ce9f");
		assert(block.hashMerkleRoot == merkle_root);
        assert(block.GetHash() == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet));
        assert(block.CheckBlock("LoadBlockIndex",1,10*COIN));

        // Start new block file
        unsigned int nFile;
        unsigned int nBlockPos;
        if (!block.WriteToDisk(nFile, nBlockPos))
            return error("LoadBlockIndex() : writing genesis block to disk failed");
        if (!block.AddToBlockIndex(nFile, nBlockPos, hashGenesisBlock))
            return error("LoadBlockIndex() : genesis block not accepted");

        // ppcoin: initialize synchronized checkpoint
        if (!Checkpoints::WriteSyncCheckpoint((!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet)))
            return error("LoadBlockIndex() : failed to init sync checkpoint");
    }

    string strPubKey = "";

    // if checkpoint master key changed must reset sync-checkpoint
    if (!txdb.ReadCheckpointPubKey(strPubKey) || strPubKey != CSyncCheckpoint::strMasterPubKey)
    {
        // write checkpoint master key to db
        txdb.TxnBegin();
        if (!txdb.WriteCheckpointPubKey(CSyncCheckpoint::strMasterPubKey))
            return error("LoadBlockIndex() : failed to write new checkpoint master key to db");
        if (!txdb.TxnCommit())
            return error("LoadBlockIndex() : failed to commit new checkpoint master key to db");
        if ((!fTestNet) && !Checkpoints::ResetSyncCheckpoint())
            return error("LoadBlockIndex() : failed to reset sync-checkpoint");
    }

    return true;
}


vector<unsigned char> StringToVector(std::string sData)
{
        vector<unsigned char> v(sData.begin(), sData.end());
		return v;
}

std::string VectorToString(vector<unsigned char> v)
{
        std::string s(v.begin(), v.end());
        return s;
}


std::string ExtractXML(std::string XMLdata, std::string key, std::string key_end)
{

	std::string extraction = "";
	string::size_type loc = XMLdata.find( key, 0 );
	if( loc != string::npos )
	{
		string::size_type loc_end = XMLdata.find( key_end, loc+3);
		if (loc_end != string::npos )
		{
			extraction = XMLdata.substr(loc+(key.length()),loc_end-loc-(key.length()));

		}
	}
	return extraction;
}

std::string ExtractHTML(std::string HTMLdata, std::string tagstartprefix,  std::string tagstart_suffix, std::string tag_end)
{

	std::string extraction = "";
	string::size_type loc = HTMLdata.find( tagstartprefix, 0 );
	if( loc != string::npos )
	{
		//Find the end of the start tag
		string::size_type loc_EOStartTag = HTMLdata.find( tagstart_suffix, loc+tagstartprefix.length());
		if (loc_EOStartTag != string::npos )
		{

			string::size_type loc_end = HTMLdata.find( tag_end, loc_EOStartTag+tagstart_suffix.length());
			if (loc_end != string::npos )
			{
				extraction = HTMLdata.substr(loc_EOStartTag+(tagstart_suffix.length()), loc_end-loc_EOStartTag-(tagstart_suffix.length()));
				extraction = strReplace(extraction,",","");
				if (Contains(extraction,"\r\n"))
				{
					std::vector<std::string> vExtract = split(extraction,"\r\n");
					if (vExtract.size() >= 2)
					{
						extraction = vExtract[2];
						return extraction;
					}
				}
			}
		}
	}
	return extraction;
}


std::string RetrieveMd5(std::string s1)
{
	try
	{
		const char* chIn = s1.c_str();
		unsigned char digest2[16];
		MD5((unsigned char*)chIn, strlen(chIn), (unsigned char*)&digest2);
		char mdString2[33];
		for(int i = 0; i < 16; i++) sprintf(&mdString2[i*2], "%02x", (unsigned int)digest2[i]);
 		std::string xmd5(mdString2);
		return xmd5;
	}
    catch (std::exception &e)
	{
		printf("MD5 INVALID!");
		return "";
	}
}



double Round(double d, int place)
{
    std::ostringstream ss;
    ss << std::fixed << std::setprecision(place) << d ;
	double r = lexical_cast<double>(ss.str());
	return r;
}

double cdbl(std::string s, int place)
{
	if (s=="") s="0";
	s = strReplace(s,"\r","");
	s = strReplace(s,"\n","");
	s = strReplace(s,"a","");
	s = strReplace(s,"a","");
	s = strReplace(s,"b","");
	s = strReplace(s,"c","");
	s = strReplace(s,"d","");
	s = strReplace(s,"e","");
	s = strReplace(s,"f","");
    double r = lexical_cast<double>(s);
	double d = Round(r,place);
	return d;
}


std::string get_file_contents(const char *filename)
{
  std::ifstream in(filename, std::ios::in | std::ios::binary);
  if (in)
  {
	  if (fDebug)  printf("loading file to string %s","test");

    std::string contents;
    in.seekg(0, std::ios::end);
    contents.resize(in.tellg());
    in.seekg(0, std::ios::beg);
    in.read(&contents[0], contents.size());
    in.close();
    return(contents);
  }
  throw(errno);
}

std::ifstream::pos_type filesize2(const char* filename)
{
    std::ifstream in(filename, std::ifstream::in | std::ifstream::binary);
    in.seekg(0, std::ifstream::end);
    return in.tellg();
}


std::string deletefile(std::string filename)
{
	std::string buffer;
	std::string line;
	ifstream myfile;
    if (fDebug10) printf("loading file to string %s",filename.c_str());
	filesystem::path path = filename;
	if (!filesystem::exists(path)) {
		printf("the file does not exist %s",path.string().c_str());
		return "-1";
	}
	int deleted = remove(filename.c_str());
	if (deleted != 0) return "Error deleting.";
	return "";
}


int GetFilesize(FILE* file)
{
    int nSavePos = ftell(file);
    int nFilesize = -1;
    if (fseek(file, 0, SEEK_END) == 0)
        nFilesize = ftell(file);
    fseek(file, nSavePos, SEEK_SET);
    return nFilesize;
}




bool WriteKey(std::string sKey, std::string sValue)
{
	// Allows Gridcoin to store the key value in the config file.
	boost::filesystem::path pathConfigFile(GetArg("-conf", "gridcoinresearch.conf"));
    if (!pathConfigFile.is_complete()) pathConfigFile = GetDataDir(false) / pathConfigFile;
	if (!filesystem::exists(pathConfigFile))  return false; 
	boost::to_lower(sKey);
	std::string sLine = "";
	ifstream streamConfigFile;
	streamConfigFile.open(pathConfigFile.string().c_str());
	std::string sConfig = "";
	bool fWritten = false;
    if(streamConfigFile)
	{
	   while(getline(streamConfigFile, sLine))
	   {
		   	std::vector<std::string> vEntry = split(sLine,"=");
			if (vEntry.size() == 2)
			{
				std::string sSourceKey = vEntry[0];
				std::string sSourceValue = vEntry[1];
				boost::to_lower(sSourceKey);

				if (sSourceKey==sKey) 
				{
					sSourceValue = sValue;
					sLine = sSourceKey + "=" + sSourceValue;
					fWritten=true;
				}
			}
			sLine =	strReplace(sLine,"\r","");
			sLine =	strReplace(sLine,"\n","");
			sLine += "\r\n";
			sConfig += sLine;
	   }
	}
	if (!fWritten) 
	{
		sLine = sKey + "=" + sValue + "\r\n";
		sConfig += sLine;
	}
	
	streamConfigFile.close();

	FILE *outFile = fopen(pathConfigFile.string().c_str(),"w");
	fputs(sConfig.c_str(), outFile);
	fclose(outFile);

	ReadConfigFile(mapArgs, mapMultiArgs);
	return true;
}




std::string getfilecontents(std::string filename)
{
	std::string buffer;
	std::string line;
	ifstream myfile;
    if (fDebug10) printf("loading file to string %s",filename.c_str());

	filesystem::path path = filename;

	if (!filesystem::exists(path)) {
		printf("the file does not exist %s",path.string().c_str());
		return "-1";
	}

	 FILE *file = fopen(filename.c_str(), "rb");
     CAutoFile filein = CAutoFile(file, SER_DISK, CLIENT_VERSION);
	 int fileSize = GetFilesize(filein);
     filein.fclose();

	 myfile.open(filename.c_str());

    buffer.reserve(fileSize);
    if (fDebug10) printf("opening file %s",filename.c_str());

	if(myfile)
	{
	  while(getline(myfile, line))
	  {
			buffer = buffer + line + "\r\n";
	  }
	}
	myfile.close();
	return buffer;
}


bool IsCPIDValidv3(std::string cpidv2, bool allow_investor)
{
	bool result=false;
	if (allow_investor) if (cpidv2 == "INVESTOR" || cpidv2=="investor") return true;
	if (cpidv2.length() < 34) return false;
	result = CPID_IsCPIDValid(cpidv2.substr(0,32),cpidv2,0);
	return result;
}

bool IsCPIDValidv2(MiningCPID& mc, int height)
{
	//12-24-2014 Halford - Transition to CPIDV2
	if (height < nGrandfather) return true;
	bool result = false;
	int cpidV2CutOverHeight = fTestNet ? 0 : 97000;
	if (height < cpidV2CutOverHeight)
	{
			result = IsCPIDValid_Retired(mc.cpid,mc.enccpid);
	}
	else
	{
		    if (mc.cpid == "INVESTOR" || mc.cpid=="investor") return true;
	        result = CPID_IsCPIDValid(mc.cpid, mc.cpidv2, (uint256)mc.lastblockhash);
	}

	return result;
}


bool IsLocalCPIDValid(StructCPID& structcpid)
{

	bool new_result = IsCPIDValidv3(structcpid.cpidv2,true);
	return new_result;

}



bool IsCPIDValid_Retired(std::string cpid, std::string ENCboincpubkey)
{

	try
	{
			if(cpid=="" || cpid.length() < 5)
			{
				printf("CPID length empty.");
				return false;
			}
			if (cpid=="INVESTOR") return true;
			if (ENCboincpubkey == "" || ENCboincpubkey.length() < 5)
			{
					if (fDebug10) printf("ENCBpk length empty.");
					return false;
			}
			std::string bpk = AdvancedDecrypt(ENCboincpubkey);
			std::string bpmd5 = RetrieveMd5(bpk);
			if (bpmd5==cpid) return true;
			if (fDebug10) printf("Md5<>cpid, md5 %s cpid %s  root bpk %s \r\n     ",bpmd5.c_str(), cpid.c_str(),bpk.c_str());

			return false;
	}
	catch (std::exception &e)
	{
				printf("Error while resolving IsCpidValid\r\n");
				return false;
	}
	catch(...)
	{
				printf("Error while Resolving IsCpidValid 2.\r\n");
				return false;
	}
	return false;

}

double Cap(double dAmt, double Ceiling)
{
	if (dAmt > Ceiling) dAmt = Ceiling;
	return dAmt;
}

double Lowest(double dAmt1, double dAmt2)
{
	if (dAmt1 < dAmt2)
	{
		return dAmt1;
	}
	else
	{
		return dAmt2;
	}
}

int64_t Floor(int64_t iAmt1, int64_t iAmt2)
{
	int64_t iOut = 0;
	if (iAmt1 <= iAmt2)
	{
		iOut = iAmt1;
	}
	else
	{
		iOut = iAmt2;
	}
	return iOut;

}

double coalesce(double mag1, double mag2)
{
	if (mag1 > 0) return mag1;
	return mag2;
}

double GetTotalOwedAmount(std::string cpid)
{
	StructCPID o = GetInitializedStructCPID2(cpid,mvMagnitudes);
	return o.totalowed;
}

double GetOwedAmount(std::string cpid)
{
	if (mvMagnitudes.size() > 1)
	{
		StructCPID m = GetInitializedStructCPID2(cpid,mvMagnitudes);
		if (m.initialized) return m.owed;
		return 0;
	}
	return 0;
}


double GetOutstandingAmountOwed(StructCPID &mag, std::string cpid, int64_t locktime,
	double& total_owed, double block_magnitude)
{
	// Gridcoin Payment Magnitude Unit in RSA Owed calculation ensures rewards are capped at MaxBlockSubsidy*BLOCKS_PER_DAY
	// Payment date range is stored in HighLockTime-LowLockTime
	// If newbie has not participated for 14 days, use earliest payment in chain to assess payment window
	// (Important to prevent e-mail change attacks) - Calculate payment timespan window in days
	try
	{
		double payment_timespan = (GetAdjustedTime() - mag.EarliestPaymentTime)/38400;
		if (payment_timespan < 2) payment_timespan =  2;
		if (payment_timespan > 10) payment_timespan = 14;
		mag.PaymentTimespan = Round(payment_timespan,0);
		double research_magnitude = 0;
		// Get neural network magnitude:
		StructCPID stDPOR = GetInitializedStructCPID2(cpid,mvDPOR);
		research_magnitude = LederstrumpfMagnitude2(stDPOR.Magnitude,locktime);
		double owed_standard = payment_timespan * Cap(research_magnitude*GetMagnitudeMultiplier(locktime),
			GetMaximumBoincSubsidy(locktime)*5);
		double owed_network_cap = payment_timespan * GRCMagnitudeUnit(locktime) * research_magnitude;
		double owed = Lowest(owed_standard,owed_network_cap);
		double paid = mag.payments;
		double outstanding = Lowest(owed-paid, GetMaximumBoincSubsidy(locktime)*5);
		total_owed = owed;
		//if (outstanding < 0) outstanding=0;
		return outstanding;
	}
	catch (std::exception &e)
	{
			printf("Error while Getting outstanding amount owed.");
			return 0;
	}
    catch(...)
	{
			printf("Error while Getting outstanding amount owed.");
			return 0;
	}
}

bool BlockNeedsChecked(int64_t BlockTime)
{
	if (IsLockTimeWithin14days((double)BlockTime))
	{
		if (fColdBoot) return false;
		bool fOut = OutOfSyncByMoreThan(30);
		return !fOut;
	}
	else
	{
		return false;
	}
}

bool IsLockTimeWithin14days(double locktime)
{
	//Within 14 days
	double nCutoff =  GetAdjustedTime() - (60*60*24*14);
	if (locktime < nCutoff) return false;
	return true;
}

bool LockTimeRecent(double locktime)
{
	//Returns true if adjusted time is within 45 minutes
	double nCutoff =  GetAdjustedTime() - (60*45);
	if (locktime < nCutoff) return false;
	return true;
}

bool IsLockTimeWithinMinutes(double locktime, int minutes)
{
	double nCutoff = GetAdjustedTime() - (60*minutes);
	if (locktime < nCutoff) return false;
	return true;
}

bool IsLockTimeWithinMinutes(int64_t locktime, int minutes)
{
	double nCutoff = GetAdjustedTime() - (60*minutes);
	if (locktime < nCutoff) return false;
	return true;
}


double GetMagnitudeWeight(double LockTime)
{
	double age = ( GetAdjustedTime() - LockTime)/86400;
	double inverse = 14-age;
	if (inverse < 1) inverse=1;
	return inverse*inverse;
}




void RemoveNetworkMagnitude(double LockTime, std::string cpid, MiningCPID bb, double mint, bool IsStake)
{
        if (!IsLockTimeWithin14days(LockTime)) return;
		StructCPID structMagnitude = GetInitializedStructCPID2(cpid,mvMagnitudes);
		structMagnitude.projectname = bb.projectname;
		structMagnitude.entries--;
		if (IsStake)
		{
			double interest = (double)mint - (double)bb.ResearchSubsidy;
			structMagnitude.payments -= bb.ResearchSubsidy;
			structMagnitude.interestPayments = structMagnitude.interestPayments - interest;
		    structMagnitude.LastPaymentTime = 0;
		}
		structMagnitude.cpid = cpid;
		double total_owed = 0;
		mvMagnitudes[cpid] = structMagnitude;
		structMagnitude.owed = GetOutstandingAmountOwed(structMagnitude,cpid,LockTime,total_owed,bb.Magnitude);
		structMagnitude.totalowed = total_owed;
		mvMagnitudes[cpid] = structMagnitude;
}






void AdjustTimestamps(StructCPID& strCPID, double timestamp, double subsidy)
{
		if (timestamp > strCPID.LastPaymentTime && subsidy > 0) strCPID.LastPaymentTime = timestamp;
		if (timestamp < strCPID.EarliestPaymentTime) strCPID.EarliestPaymentTime = timestamp;
}




void AddResearchMagnitude(CBlockIndex* pIndex)
{
	    // Headless critical section
		if (pIndex->nResearchSubsidy > 0)
		{
			try
			{
				StructCPID stMag = GetInitializedStructCPID2(pIndex->sCPID,mvMagnitudesCopy);
				stMag.cpid = pIndex->sCPID;
				stMag.GRCAddress = pIndex->sGRCAddress;
				if ((double)pIndex->nHeight > stMag.LastBlock)
				{
					stMag.LastBlock = (double)pIndex->nHeight;
				}
				stMag.entries++;
				stMag.payments += pIndex->nResearchSubsidy;
				stMag.interestPayments += pIndex->nInterestSubsidy;

				AdjustTimestamps(stMag,(double)pIndex->nTime,pIndex->nResearchSubsidy);
				// Track detailed payments made to each CPID
				stMag.PaymentTimestamps         += RoundToString((double)pIndex->nTime,0) + ",";
				stMag.PaymentAmountsResearch    += RoundToString(pIndex->nResearchSubsidy,2) + ",";
				stMag.PaymentAmountsInterest    += RoundToString(pIndex->nInterestSubsidy,2) + ",";
				stMag.PaymentAmountsBlocks      += RoundToString((double)pIndex->nHeight,0) + ",";
     			stMag.Accuracy++;
				stMag.AverageRAC = stMag.rac / (stMag.entries+.01);
				double total_owed = 0;
				stMag.owed = GetOutstandingAmountOwed(stMag,
					pIndex->sCPID,(double)pIndex->nTime,total_owed,pIndex->nMagnitude);

				stMag.totalowed = total_owed;
				mvMagnitudesCopy[pIndex->sCPID] = stMag;
			}
			catch (bad_alloc ba)
			{
				printf("\r\nBad Allocation in AddResearchMagnitude() \r\n");
			}
			catch(...)
			{
				printf("Exception in AddResearchMagnitude() \r\n");
			}
		}
}




void AddNMRetired(double height, double LockTime, std::string cpid, MiningCPID bb)
{
	try
	{
	    StructCPID stMag = GetInitializedStructCPID2(cpid,mvMagnitudes);
		stMag.cpid = cpid;
		stMag.GRCAddress = bb.GRCAddress;
		if (height > stMag.LastBlock)
		{
			stMag.LastBlock = height;
		}
		stMag.projectname = bb.projectname;
		stMag.rac += bb.rac;
		stMag.entries++;
		stMag.payments += bb.ResearchSubsidy;
		stMag.interestPayments += bb.InterestSubsidy;
		AdjustTimestamps(stMag,LockTime,bb.ResearchSubsidy);
		// Per RTM 6-27-2015 - Track detailed payments made to each CPID
		stMag.PaymentTimestamps         += RoundToString(LockTime,0) + ",";
		stMag.PaymentAmountsResearch    += RoundToString(bb.ResearchSubsidy,2) + ",";
		stMag.PaymentAmountsInterest    += RoundToString(bb.InterestSubsidy,2) + ",";
		stMag.PaymentAmountsBlocks      += RoundToString((double)height,0) + ",";
     	stMag.Accuracy++;
	    stMag.AverageRAC = stMag.rac / (stMag.entries+.01);
	    double total_owed = 0;
	    stMag.owed = GetOutstandingAmountOwed(stMag,cpid,LockTime,total_owed,bb.Magnitude);
	    stMag.totalowed = total_owed;
	    mvMagnitudes[cpid] = stMag;
	}
	catch (std::exception &e)
	{
			printf("Error while Adding Network Magnitude.");
	}
    catch(...)
	{
			printf("Error while Adding Network Magnitude.");
	}
}




bool GetEarliestStakeTime(std::string grcaddress, std::string cpid)
{
    if (nBestHeight < 15)
	{
		mvApplicationCacheTimestamp["nGRCTime"] = GetAdjustedTime();
		mvApplicationCacheTimestamp["nCPIDTime"] = GetAdjustedTime();
		return true;
	}
	if (IsLockTimeWithinMinutes(nLastGRCtallied,100)) return true;
	nLastGRCtallied = GetAdjustedTime();
	int64_t nGRCTime = 0;
	int64_t nCPIDTime = 0;
	CBlock block;
	int64_t nStart = GetTimeMillis();
	LOCK(cs_main);
	{
		    int nMaxDepth = nBestHeight;
			int nLookback = BLOCKS_PER_DAY*6*30;  //6 months back for performance
			int nMinDepth = nMaxDepth - nLookback;
			if (nMinDepth < 2) nMinDepth = 2;
			// Start at the earliest block index:
			CBlockIndex* pblockindex = FindBlockByHeight(nMinDepth);
		    while (pblockindex->nHeight < nMaxDepth-1)
			{
						pblockindex = pblockindex->pnext;
						if (pblockindex == pindexBest) break;
						if (pblockindex == NULL || !pblockindex->IsInMainChain()) continue;
						std::string myCPID = "";
						if (pblockindex->nHeight < nNewIndex)
						{
							//Between block 1 and nNewIndex, unfortunately, we have to read from disk.
							block.ReadFromDisk(pblockindex);
							std::string hashboinc = "";
							if (block.vtx.size() > 0) hashboinc = block.vtx[0].hashBoinc;
							MiningCPID bb = DeserializeBoincBlock(hashboinc);
							myCPID = bb.cpid;
						}
						else
						{
							myCPID = pblockindex->sCPID;
						}
						if (cpid == myCPID && nCPIDTime==0)
						{
							nCPIDTime = pblockindex->nTime;
							nGRCTime = pblockindex->nTime;
							break;
						}
			}
	}
	int64_t EarliestStakedWalletTx = GetEarliestWalletTransaction();
	if (EarliestStakedWalletTx > 0 && EarliestStakedWalletTx < nGRCTime) nGRCTime = EarliestStakedWalletTx;
	if (fTestNet) nGRCTime -= (86400*30);
	if (nGRCTime <= 0)  nGRCTime = GetAdjustedTime();
	if (nCPIDTime <= 0) nCPIDTime = GetAdjustedTime();

	printf("Loaded staketime from index in %f", (double)(GetTimeMillis() - nStart));
	printf("CPIDTime %f, GRCTime %f, WalletTime %f \r\n",(double)nCPIDTime,(double)nGRCTime,(double)EarliestStakedWalletTx);
	mvApplicationCacheTimestamp["nGRCTime"] = nGRCTime;
	mvApplicationCacheTimestamp["nCPIDTime"] = nCPIDTime;
	return true;
}

std::string GetCPIDBlockHashes(std::string cpid)
{
	return mvCPIDBlockHashes[cpid];
}

void AddCPIDBlockHash(std::string cpid, std::string blockhash, bool fInsert)
{
	std::string blockhashes = mvCPIDBlockHashes[cpid];
	if (blockhashes.empty())
	{
			mvCPIDBlockHashes.insert(map<std::string,std::string>::value_type(cpid,""));
	}

	if (fInsert || !Contains(blockhashes,blockhash) )
	{
		blockhashes += ";" + blockhash;
		mvCPIDBlockHashes[cpid] = blockhashes;
	}
}

StructCPID GetLifetimeCPID(std::string cpid, std::string sCalledFrom)
{
	//Eliminates issues with reorgs, disconnects, double counting, etc.. 
	if (cpid.empty() || cpid=="INVESTOR")
	{
		StructCPID stDummy = GetInitializedStructCPID2("INVESTOR",mvResearchAge);
		return stDummy;
	}
	if (fDebug10) printf(" {GLC %s} ",sCalledFrom.c_str());


	std::string hashes = GetCPIDBlockHashes(cpid);
	std::vector<std::string> vHashes = split(hashes,";");
    ZeroOutResearcherTotals(cpid);

	for (unsigned int i=0; i < vHashes.size(); i++)
	{
		std::string myBlockHash = vHashes[i];
		if (myBlockHash.length() > 5)
		{
		    uint256 uHash(myBlockHash);
			if (!(mapBlockIndex.count(uHash) == 0))
			{
				CBlockIndex* pblockindex = mapBlockIndex[uHash];
				if (pblockindex)
				{
					if (pblockindex->IsInMainChain())
					{
						if (pblockindex->sCPID == cpid)
						{

							StructCPID stCPID = GetInitializedStructCPID2(pblockindex->sCPID,mvResearchAge);
							if (((double)pblockindex->nHeight) > stCPID.LastBlock && pblockindex->nResearchSubsidy > 0)
							{
								stCPID.LastBlock = (double)pblockindex->nHeight;
								stCPID.BlockHash = pblockindex->GetBlockHash().GetHex();
							}
							stCPID.InterestSubsidy += pblockindex->nInterestSubsidy;
							stCPID.ResearchSubsidy += pblockindex->nResearchSubsidy;
							stCPID.Accuracy++;
							if (pblockindex->nMagnitude > 0)
							{
								stCPID.TotalMagnitude += pblockindex->nMagnitude;
								stCPID.ResearchAverageMagnitude = stCPID.TotalMagnitude/(stCPID.Accuracy+.01);
							}

							if (((double)pblockindex->nTime) < stCPID.LowLockTime)  stCPID.LowLockTime  = (double)pblockindex->nTime;
							if (((double)pblockindex->nTime) > stCPID.HighLockTime) stCPID.HighLockTime = (double)pblockindex->nTime;
							mvResearchAge[pblockindex->sCPID]=stCPID;

						}
					}
				}
			}
		}
	}
	StructCPID st1 = GetInitializedStructCPID2(cpid,mvResearchAge);
	return st1;
}

MiningCPID GetInitializedMiningCPID(std::string name,std::map<std::string, MiningCPID> vRef)
{
	MiningCPID cpid = vRef[name];
	if (!cpid.initialized)
	{
			    cpid = GetMiningCPID();
				cpid.initialized=true;
				cpid.LastPaymentTime = 0;
				vRef.insert(map<string,MiningCPID>::value_type(name,cpid));
				vRef[name]=cpid;
				return cpid;
	}
	else
	{
			return cpid;
	}

}


StructCPID GetInitializedStructCPID2(std::string name,std::map<std::string, StructCPID> vRef)
{
	try
	{
		StructCPID cpid = vRef[name];
		if (!cpid.initialized)
		{
				cpid = GetStructCPID();
				cpid.initialized=true;
				cpid.LowLockTime = 99999999999;
				cpid.HighLockTime = 0;
				cpid.LastPaymentTime = 0;
				cpid.EarliestPaymentTime = 99999999999;
				vRef.insert(map<string,StructCPID>::value_type(name,cpid));
				cpid.Accuracy = 0;
				vRef[name]=cpid;
				return cpid;
		}
		else
		{
				return cpid;
		}
	}
	catch (bad_alloc ba)
	{
		printf("Bad alloc caught in GetInitializedStructCpid2 for %s",name.c_str());
		StructCPID cpid = GetStructCPID();
		return cpid;
	}
	catch(...)
	{
		printf("Exception caught in GetInitializedStructCpid2 for %s",name.c_str());
		StructCPID cpid = GetStructCPID();
		return cpid;
	}
}




bool RetiredTN(bool Forcefully)
{
	//Iterate throught last 14 days, tally network averages
    if (nBestHeight < 15)
	{
		bNetAveragesLoaded = true;
		return true;
	}

	if (Forcefully) nLastTallied = 0;
	int timespan = fTestNet ? 1 : 5;
	if (IsLockTimeWithinMinutes(nLastTallied,timespan))
	{
		bNetAveragesLoaded=true;
		return true;
	}

	printf("Gathering network avgs (begin)");
	nLastTallied = GetAdjustedTime();
	bNetAveragesLoaded = false;
	bool superblockloaded = false;
	double NetworkPayments = 0;
	double NetworkInterest = 0;
					//7-5-2015 - R Halford - Start block and End block must be an exact range agreed by the network:
					int nMaxDepth = (nBestHeight-CONSENSUS_LOOKBACK) - ( (nBestHeight-CONSENSUS_LOOKBACK) % BLOCK_GRANULARITY);
					int nLookback = BLOCKS_PER_DAY*14; //Daily block count * Lookback in days = 14 days
					int nMinDepth = (nMaxDepth - nLookback) - ( (nMaxDepth-nLookback) % BLOCK_GRANULARITY);
					if (fDebug3) printf("START BLOCK %f, END BLOCK %f ",(double)nMaxDepth,(double)nMinDepth);
					if (nMinDepth < 2)              nMinDepth = 2;
					if (mvMagnitudes.size() > 0) 	mvMagnitudes.clear();
					CBlock block;
					CBlockIndex* pblockindex = pindexBest;

					while (pblockindex->nHeight > nMaxDepth)
					{
						if (!pblockindex || !pblockindex->pprev) return false;
						pblockindex = pblockindex->pprev;
						if (pblockindex == pindexGenesisBlock) return false;
					}

					if (fDebug3) printf("Max block %f",(double)pblockindex->nHeight);

		    		while (pblockindex->nHeight > nMinDepth)
					{
						if (!pblockindex || !pblockindex->pprev) return false;   //Avoid segfault
						pblockindex = pblockindex->pprev;
						if (pblockindex == pindexGenesisBlock) return false;
						if (pblockindex == NULL || !pblockindex->IsInMainChain()) continue;
						MiningCPID bb;

							if (!block.ReadFromDisk(pblockindex)) continue;
							if (block.vtx.size() > 0)
							{
								if (block.vtx[0].hashBoinc.empty()) continue;
								bb = DeserializeBoincBlock(block.vtx[0].hashBoinc);
							}
							else continue;

							NetworkPayments += bb.ResearchSubsidy;
							NetworkInterest += bb.InterestSubsidy;
							// Insert CPID, Magnitude, Payments
							AddNMRetired((double)pblockindex->nHeight,pblockindex->nTime,bb.cpid,bb);
							if (!superblockloaded && bb.superblock.length() > 20)
							{
								    std::string superblock = UnpackBinarySuperblock(bb.superblock);
									if (VerifySuperblock(superblock,pblockindex->nHeight))
									{
	    									LoadSuperblock(superblock,pblockindex->nTime,pblockindex->nHeight);
											superblockloaded=true;
											if (fDebug3) printf(" Superblock Loaded %f \r\n",(double)pblockindex->nHeight);
									}
							}

					}
					if (pblockindex && fDebug10)	printf("Min block %f \r\n",(double)pblockindex->nHeight);
					StructCPID network = GetInitializedStructCPID2("NETWORK",mvNetwork);
					network.projectname="NETWORK";
					network.payments = NetworkPayments;
					network.InterestSubsidy = NetworkInterest;
					mvNetwork["NETWORK"] = network;
					TallyMagnitudesInSuperblock();
					GetNextProject(false);
					if (fDebug3) printf(".Done.\r\n %f",(double)0);
					bTallyStarted = false;
					bNetAveragesLoaded = true;
					return true;

	bNetAveragesLoaded=true;
	return false;
}



bool ComputeNeuralNetworkSupermajorityHashes()
{
    if (nBestHeight < 15)  return true;
	if (IsLockTimeWithinMinutes(nLastTalliedNeural,5))
	{
		return true;
	}
	nLastTalliedNeural = GetAdjustedTime();
	//Clear the neural network hash buffer
	if (mvNeuralNetworkHash.size() > 0)  mvNeuralNetworkHash.clear();
	if (mvNeuralVersion.size() > 0)  mvNeuralVersion.clear();
	if (mvCurrentNeuralNetworkHash.size() > 0) mvCurrentNeuralNetworkHash.clear();

	//Clear the votes
	WriteCache("neuralsecurity","pending","0",GetAdjustedTime());
	ClearCache("neuralsecurity");
	try
	{
		int nMaxDepth = nBestHeight;
		int nLookback = 100;
		int nMinDepth = (nMaxDepth - nLookback);
		if (nMinDepth < 2)   nMinDepth = 2;
		CBlock block;
		CBlockIndex* pblockindex = pindexBest;
		while (pblockindex->nHeight > nMinDepth)
		{
			if (!pblockindex || !pblockindex->pprev) return false;
			pblockindex = pblockindex->pprev;
            if (pblockindex == pindexGenesisBlock) return false;
			if (!pblockindex->IsInMainChain()) continue;
			block.ReadFromDisk(pblockindex);
			std::string hashboinc = "";
			if (block.vtx.size() > 0) hashboinc = block.vtx[0].hashBoinc;
			if (!hashboinc.empty())
			{
				MiningCPID bb = DeserializeBoincBlock(hashboinc);
				//If block is pending: 7-25-2015
				if (bb.superblock.length() > 20)
				{
					std::string superblock = UnpackBinarySuperblock(bb.superblock);
					if (VerifySuperblock(superblock,pblockindex->nHeight))
					{
						WriteCache("neuralsecurity","pending",RoundToString((double)pblockindex->nHeight,0),GetAdjustedTime());
					}
				}
				if (!bb.clientversion.empty())
				{
					IncrementVersionCount(bb.clientversion);
				}
				//Increment Neural Network Hashes Supermajority (over the last N blocks)
				IncrementNeuralNetworkSupermajority(bb.NeuralHash,bb.GRCAddress,(nMaxDepth-pblockindex->nHeight)+10);
				IncrementCurrentNeuralNetworkSupermajority(bb.CurrentNeuralHash,bb.GRCAddress,(nMaxDepth-pblockindex->nHeight)+10);

			}
		}

		if (fDebug3) printf(".11.");
	}
	catch (std::exception &e)
	{
			printf("Neural Error while memorizing hashes.\r\n");
	}
    catch(...)
	{
		printf("Neural error While Memorizing Hashes! [1]\r\n");
	}
	return true;

}

MiningCPID GetBoincBlockByHeight(int ii, double& mint, int64_t& nTime)
{
	CBlock block;
	MiningCPID bb;
	CBlockIndex* pblockindex = FindBlockByHeight(ii);
	bb.initialized=false;
	if (pblockindex == NULL) return bb;
	if (pblockindex->pnext == NULL) return bb;
	if (!pblockindex || !pblockindex->IsInMainChain()) return bb;


	if (block.ReadFromDisk(pblockindex))
	{
		nTime = block.nTime;
		std::string hashboinc = "";
		mint = CoinToDouble(pblockindex->nMint);
		if (block.vtx.size() > 0) hashboinc = block.vtx[0].hashBoinc;
		bb = DeserializeBoincBlock(hashboinc);
		bb.initialized=true;
		return bb;
	}
	return bb;
}



void AddProjectRAC(MiningCPID bb,double& NetworkRAC, double& NetworkMagnitude)
{
	//RETIRE
	StructCPID network = GetInitializedStructCPID2(bb.projectname,mvNetwork);
	network.projectname = bb.projectname;
	network.rac += bb.rac;
	NetworkRAC += bb.rac;
	network.TotalRAC = NetworkRAC;
	NetworkMagnitude += bb.Magnitude;
	network.entries++;
	mvNetwork[bb.projectname] = network;
}


bool TallyResearchAverages(bool Forcefully)
{
	//Iterate throught last 14 days, tally network averages
    if (nBestHeight < 15)
	{
		bNetAveragesLoaded = true;
		return true;
	}

	//if (Forcefully) nLastTallied = 0;
	int timespan = fTestNet ? 2 : 6;
	if (IsLockTimeWithinMinutes(nLastTallied,timespan))
	{
		bNetAveragesLoaded=true;
		return true;
	}

	//8-27-2016
	 int64_t nStart = GetTimeMillis();


	if (fDebug3) printf("Tallying Research Averages (begin) ");
	nLastTallied = GetAdjustedTime();
	bNetAveragesLoaded = false;
	bool superblockloaded = false;
	double NetworkPayments = 0;
	double NetworkInterest = 0;
	
 						//Consensus Start/End block:
						int nMaxDepth = (nBestHeight-CONSENSUS_LOOKBACK) - ( (nBestHeight-CONSENSUS_LOOKBACK) % BLOCK_GRANULARITY);
						int nLookback = BLOCKS_PER_DAY * 14; //Daily block count * Lookback in days
						int nMinDepth = (nMaxDepth - nLookback) - ( (nMaxDepth-nLookback) % BLOCK_GRANULARITY);
						if (fDebug3) printf("START BLOCK %f, END BLOCK %f ",(double)nMaxDepth,(double)nMinDepth);
						if (nMinDepth < 2)              nMinDepth = 2;
						mvMagnitudesCopy.clear();
						int iRow = 0;
						//CBlock block;
						CBlockIndex* pblockindex = pindexBest;
						if (!pblockindex)
						{
								bTallyStarted = false;
								bNetAveragesLoaded = true;
								return true;
						}
						while (pblockindex->nHeight > nMaxDepth)
						{
							if (!pblockindex || !pblockindex->pprev || pblockindex == pindexGenesisBlock) return false;
							pblockindex = pblockindex->pprev;
						}

						if (fDebug3) printf("Max block %f, seektime %f",(double)pblockindex->nHeight,(double)GetTimeMillis()-nStart);
						nStart=GetTimeMillis();

   
						// Headless critical section ()
		try
		{
						while (pblockindex->nHeight > nMinDepth)
						{
							if (!pblockindex || !pblockindex->pprev) return false;
							pblockindex = pblockindex->pprev;
							if (pblockindex == pindexGenesisBlock) return false;
							if (!pblockindex->IsInMainChain()) continue;
							NetworkPayments += pblockindex->nResearchSubsidy;
							NetworkInterest += pblockindex->nInterestSubsidy;
							AddResearchMagnitude(pblockindex);

							iRow++;
							if (IsSuperBlock(pblockindex) && !superblockloaded)
							{
								MiningCPID bb = GetBoincBlockByIndex(pblockindex);
								if (bb.superblock.length() > 20)
								{
										std::string superblock = UnpackBinarySuperblock(bb.superblock);
										if (VerifySuperblock(superblock,pblockindex->nHeight))
										{
												LoadSuperblock(superblock,pblockindex->nTime,pblockindex->nHeight);
												superblockloaded=true;
												if (fDebug3) printf(" Superblock Loaded %f \r\n",(double)pblockindex->nHeight);
										}
								}
							}

						}
						// End of critical section
						if (fDebug3) printf("TNA loaded in %f",(double)GetTimeMillis()-nStart);
						nStart=GetTimeMillis();


						if (pblockindex)
						{
							if (fDebug3) printf("Min block %f, Rows %f \r\n",(double)pblockindex->nHeight,(double)iRow);
							StructCPID network = GetInitializedStructCPID2("NETWORK",mvNetworkCopy);
							network.projectname="NETWORK";
							network.payments = NetworkPayments;
							network.InterestSubsidy = NetworkInterest;
							mvNetworkCopy["NETWORK"] = network;
							if(fDebug3) printf(" TMIS1 ");
							TallyMagnitudesInSuperblock();
						}
						// 11-19-2015 Copy dictionaries to live RAM
						mvDPOR = mvDPORCopy;
						mvMagnitudes = mvMagnitudesCopy;
						mvNetwork = mvNetworkCopy;
						bTallyStarted = false;
						bNetAveragesLoaded = true;
						return true;
		}
		catch (bad_alloc ba)
		{
			printf("Bad Alloc while tallying network averages. [1]\r\n");
			bNetAveragesLoaded=true;
            nLastTallied = 0;
		}
		catch(...)
		{
			printf("Error while tallying network averages. [1]\r\n");
			bNetAveragesLoaded=true;
            nLastTallied = 0;
		}

		if (fDebug3) printf("NA loaded in %f",(double)GetTimeMillis()-nStart);
						
	    bNetAveragesLoaded=true;
	    return false;
}



bool TallyNetworkAverages(bool Forcefully)
{
	if (IsResearchAgeEnabled(pindexBest->nHeight))
	{
		return TallyResearchAverages(Forcefully);
	}
	else
	{
		return RetiredTN(Forcefully);
	}
}


void PrintBlockTree()
{
    AssertLockHeld(cs_main);
    // pre-compute tree structure
    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;
    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)
    {
        CBlockIndex* pindex = (*mi).second;
        mapNext[pindex->pprev].push_back(pindex);
    }

    vector<pair<int, CBlockIndex*> > vStack;
    vStack.push_back(make_pair(0, pindexGenesisBlock));

    int nPrevCol = 0;
    while (!vStack.empty())
    {
        int nCol = vStack.back().first;
        CBlockIndex* pindex = vStack.back().second;
        vStack.pop_back();

        // print split or gap
        if (nCol > nPrevCol)
        {
            for (int i = 0; i < nCol-1; i++)
                printf("| ");
            printf("|\\\n");
        }
        else if (nCol < nPrevCol)
        {
            for (int i = 0; i < nCol; i++)
                printf("| ");
            printf("|\n");
       }
        nPrevCol = nCol;

        // print columns
        for (int i = 0; i < nCol; i++)
            printf("| ");

        // print item
        CBlock block;
        block.ReadFromDisk(pindex);
        printf("%d (%u,%u) %s  %08x  %s  mint %7s  tx %"PRIszu"",
            pindex->nHeight,
            pindex->nFile,
            pindex->nBlockPos,
            block.GetHash().ToString().c_str(),
            block.nBits,
            DateTimeStrFormat("%x %H:%M:%S", block.GetBlockTime()).c_str(),
            FormatMoney(pindex->nMint).c_str(),
            block.vtx.size());

        PrintWallets(block);

        // put the main time-chain first
        vector<CBlockIndex*>& vNext = mapNext[pindex];
        for (unsigned int i = 0; i < vNext.size(); i++)
        {
            if (vNext[i]->pnext)
            {
                swap(vNext[0], vNext[i]);
                break;
            }
        }

        // iterate children
        for (unsigned int i = 0; i < vNext.size(); i++)
            vStack.push_back(make_pair(nCol+i, vNext[i]));
    }
}

bool LoadExternalBlockFile(FILE* fileIn)
{
    int64_t nStart = GetTimeMillis();

    int nLoaded = 0;
    {
        LOCK(cs_main);
        try {
            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);
            unsigned int nPos = 0;
            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)
            {
                unsigned char pchData[65536];
                do {
                    fseek(blkdat, nPos, SEEK_SET);
                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);
                    if (nRead <= 8)
                    {
                        nPos = (unsigned int)-1;
                        break;
                    }
                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));
                    if (nFind)
                    {
                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)
                        {
                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);
                            break;
                        }
                        nPos += ((unsigned char*)nFind - pchData) + 1;
                    }
                    else
                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;
                } while(!fRequestShutdown);
                if (nPos == (unsigned int)-1)
                    break;
                fseek(blkdat, nPos, SEEK_SET);
                unsigned int nSize;
                blkdat >> nSize;
                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)
                {
                    CBlock block;
                    blkdat >> block;
                    if (ProcessBlock(NULL,&block,false))
                    {
                        nLoaded++;
                        nPos += 4 + nSize;
                    }
                }
            }
        }
        catch (std::exception &e) {
            printf("%s() : Deserialize or I/O error caught during load\n",
                   __PRETTY_FUNCTION__);
        }
    }
    printf("Loaded %i blocks from external file in %"PRId64"ms\n", nLoaded, GetTimeMillis() - nStart);
    return nLoaded > 0;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAlert
//

extern map<uint256, CAlert> mapAlerts;
extern CCriticalSection cs_mapAlerts;

string GetWarnings(string strFor)
{
    int nPriority = 0;
    string strStatusBar;
    string strRPC;

    if (GetBoolArg("-testsafemode"))
        strRPC = "test";

    // Misc warnings like out of disk space and clock is wrong
    if (strMiscWarning != "")
    {
        nPriority = 1000;
        strStatusBar = strMiscWarning;
    }

    // if detected invalid checkpoint enter safe mode
    if (Checkpoints::hashInvalidCheckpoint != 0)
    {

		if (CHECKPOINT_DISTRIBUTED_MODE==1)
		{
			//10-18-2014-Halford- If invalid checkpoint found, reboot the node:
			printf("Moving Gridcoin into Checkpoint ADVISORY mode.\r\n");
			CheckpointsMode = Checkpoints::ADVISORY;
		}
		else
		{
			#if defined(WIN32) && defined(QT_GUI)
				int nResult = 0;
	    		std::string rebootme = "";
				if (mapArgs.count("-reboot"))
				{
					rebootme = GetArg("-reboot", "false");
				}
				if (rebootme == "true")
				{
					nResult = RebootClient();
					printf("Rebooting %u",nResult);
				}
			#endif

			nPriority = 3000;
			strStatusBar = strRPC = _("WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.");
			printf("WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.");
		}


    }

    // Alerts
    {
        LOCK(cs_mapAlerts);
        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)
        {
            const CAlert& alert = item.second;
            if (alert.AppliesToMe() && alert.nPriority > nPriority)
            {
                nPriority = alert.nPriority;
                strStatusBar = alert.strStatusBar;
                if (nPriority > 1000)
                    strRPC = strStatusBar;
            }
        }
    }

    if (strFor == "statusbar")
        return strStatusBar;
    else if (strFor == "rpc")
        return strRPC;
    assert(!"GetWarnings() : invalid parameter");
    return "error";
}








//////////////////////////////////////////////////////////////////////////////
//
// Messages
//


bool static AlreadyHave(CTxDB& txdb, const CInv& inv)
{
    switch (inv.type)
    {
    case MSG_TX:
        {
        bool txInMap = false;
        txInMap = mempool.exists(inv.hash);
        return txInMap ||
               mapOrphanTransactions.count(inv.hash) ||
               txdb.ContainsTx(inv.hash);
        }

    case MSG_BLOCK:
        return mapBlockIndex.count(inv.hash) ||
               mapOrphanBlocks.count(inv.hash);
    }
    // Don't know what it is, just say we already got one
    return true;
}



std::string GetLastBlockGRCAddress()
{
    CBlock block;
    const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexBest, true);
	block.ReadFromDisk(pindexPrev);
	std::string hb = "";
	if (block.vtx.size() > 0) hb = block.vtx[0].hashBoinc;
	MiningCPID bb = DeserializeBoincBlock(hb);
	return bb.GRCAddress;
}

bool AcidTest(std::string precommand, std::string acid, CNode* pfrom)
{
	std::vector<std::string> vCommand = split(acid,",");
	if (vCommand.size() >= 6)
	{
		std::string sboinchashargs = DefaultOrgKey(12);  //Use 12 characters for inter-client communication
		std::string nonce =          vCommand[0];
		std::string command =        vCommand[1];
		std::string hash =           vCommand[2];
		std::string org =            vCommand[3];
		std::string pub_key_prefix = vCommand[4];
		std::string bhrn =           vCommand[5];
		std::string grid_pass =      vCommand[6];
		std::string grid_pass_decrypted = AdvancedDecryptWithSalt(grid_pass,sboinchashargs);

		if (grid_pass_decrypted != bhrn+nonce+org+pub_key_prefix)
		{
			if (fDebug10) printf("Decrypted gridpass %s <> hashed message",grid_pass_decrypted.c_str());
			nonce="";
			command="";
		}

		std::string pw1 = RetrieveMd5(nonce+","+command+","+org+","+pub_key_prefix+","+sboinchashargs);

		if (precommand=="aries")
		{
			//pfrom->securityversion = pw1;
		}
		if (fDebug10) printf(" Nonce %s,comm %s,hash %s,pw1 %s \r\n",nonce.c_str(),command.c_str(),hash.c_str(),pw1.c_str());
		//If timestamp too old; disconnect
		double timediff = std::abs(GetAdjustedTime() - cdbl(nonce,0));
		if (timediff > 12*60 && GetAdjustedTime() > 1410913403)
		{
			//printf("Network time attack [2] timediff %f  nonce %f    localtime %f",timediff,(double)cdbl(nonce,0),(double)GetAdjustedTime());
			//pfrom->Misbehaving(25);
			//pfrom->fDisconnect = true;
		}

		if (hash != pw1)
		{
			if (fDebug2) printf("Acid test failed for %s %s.",NodeAddress(pfrom).c_str(),acid.c_str());
			double punishment = GetArg("-punishment", 10);
			pfrom->Misbehaving(punishment);
			return false;
		}
		return true;
	}
	else
	{
		if (fDebug2) printf("Message corrupted. Node %s partially banned.",NodeAddress(pfrom).c_str());
		pfrom->Misbehaving(1);
		return false;
	}
	return true;
}




// The message start string is designed to be unlikely to occur in normal data.
// The characters are rarely used upper ASCII, not valid as UTF-8, and produce
// a large 4-byte int at any alignment.
unsigned char pchMessageStart[4] = { 0x70, 0x35, 0x22, 0x05 };


std::string NodeAddress(CNode* pfrom)
{
	std::string ip = pfrom->addr.ToString();
	return ip;
}

double ExtractMagnitudeFromExplainMagnitude()
{
	    if (msNeuralResponse.empty()) return 0;
		try
		{
			std::vector<std::string> vMag = split(msNeuralResponse.c_str(),"<ROW>");
			for (unsigned int i = 0; i < vMag.size(); i++)
			{
				if (Contains(vMag[i],"Total Mag:"))
				{
					std::vector<std::string> vMyMag = split(vMag[i].c_str(),":");
					if (vMyMag.size() > 0)
					{
						std::string sSubMag = vMyMag[1];
						sSubMag = strReplace(sSubMag," ","");
						double dMag = cdbl("0"+sSubMag,0);
						return dMag;
					}
				}
			}
			return 0;
		}
		catch(...)
		{
			return 0;
		}
		return 0;
}

bool VerifyExplainMagnitudeResponse()
{
		if (msNeuralResponse.empty()) return false;
		try
		{
			double dMag = ExtractMagnitudeFromExplainMagnitude();
			if (dMag==0)
			{
					WriteCache("maginvalid","invalid",RoundToString(cdbl("0"+ReadCache("maginvalid","invalid"),0),0),GetAdjustedTime());
					double failures = cdbl("0"+ReadCache("maginvalid","invalid"),0);
					if (failures < 10)
					{
						msNeuralResponse = "";
					}
			}
			else
			{
				return true;
			}
		}
		catch(...)
		{
			return false;
		}
		return false;
}


bool SecurityTest(CNode* pfrom, bool acid_test)
{
	if (pfrom->nStartingHeight > (nBestHeight*.5) && acid_test) return true;
	return false;
}


bool PreventCommandAbuse(std::string sNeuralRequestID, std::string sCommandName)
{
				bool bIgnore = false;
				if (cdbl("0"+ReadCache(sCommandName,sNeuralRequestID),0) > 10)
				{
					if (fDebug10) printf("Ignoring %s request for %s",sCommandName.c_str(),sNeuralRequestID.c_str());
					bIgnore = true;
				}
				if (!bIgnore)
				{
					WriteCache(sCommandName,sNeuralRequestID,RoundToString(cdbl("0"+ReadCache(sCommandName,sNeuralRequestID),0),0),GetAdjustedTime());
				}
				return bIgnore;
}

bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv, int64_t nTimeReceived)
{
    static map<CService, CPubKey> mapReuseKey;
    RandAddSeedPerfmon();
    if (fDebug10)
        printf("received: %s (%"PRIszu" bytes)\n", strCommand.c_str(), vRecv.size());
    if (mapArgs.count("-dropmessagestest") && GetRand(atoi(mapArgs["-dropmessagestest"])) == 0)
    {
        printf("dropmessagestest DROPPING RECV MESSAGE\n");
        return true;
    }

	// Stay in Sync - 8-9-2016
	if (!IsLockTimeWithinMinutes(nLastAskedForBlocks,5) && WalletOutOfSync())
	{
		AskForOutstandingBlocks(uint256(0));
	}

	// Message Attacks ////////////////////////////////////////////////////////
	std::string precommand = strCommand;
	///////////////////////////////////////////////////////////////////////////

    if (strCommand == "aries")
    {
        // Each connection can only send one version message
        if (pfrom->nVersion != 0)
        {
            pfrom->Misbehaving(10);
            return false;
        }

        int64_t nTime;
        CAddress addrMe;
        CAddress addrFrom;
        uint64_t nNonce = 1;
		std::string acid = "";
		vRecv >> pfrom->nVersion >> pfrom->boinchashnonce >> pfrom->boinchashpw >> pfrom->cpid >> pfrom->enccpid >> acid >> pfrom->nServices >> nTime >> addrMe;

		
		//Halford - 12-26-2014 - Thwart Hackers
		bool ver_valid = AcidTest(strCommand,acid,pfrom);
        if (fDebug10) printf("Ver Acid %s, Validity %s ",acid.c_str(),YesNo(ver_valid).c_str());
		if (!ver_valid)
		{
		    pfrom->Misbehaving(100);
		    pfrom->fDisconnect = true;
            return false;
		}

		bool unauthorized = false;
		double timedrift = std::abs(GetAdjustedTime() - nTime);

		if (true)
		{
			if (timedrift > (8*60))
			{
				if (fDebug10) printf("Disconnecting unauthorized peer with Network Time so far off by %f seconds!\r\n",(double)timedrift);
				unauthorized = true;
			}
		}
		else
		{
			if (timedrift > (10*60) && LessVerbose(500))
			{
				if (fDebug10) printf("Disconnecting authorized peer with Network Time so far off by %f seconds!\r\n",(double)timedrift);
				unauthorized = true;
			}
		}

		if (unauthorized)
		{
			if (fDebug10) printf("  Disconnected unauthorized peer.         ");
            pfrom->Misbehaving(100);
		    pfrom->fDisconnect = true;
            return false;
        }


		// Ensure testnet users are running latest version as of 12-3-2015 (works in conjunction with block spamming)
		if (pfrom->nVersion < 180318 && fTestNet)
		{
		    // disconnect from peers older than this proto version
            if (fDebug10) printf("Testnet partner %s using obsolete version %i; disconnecting\n", pfrom->addr.ToString().c_str(), pfrom->nVersion);
            pfrom->fDisconnect = true;
            return false;
        }

        if (pfrom->nVersion < MIN_PEER_PROTO_VERSION)
        {
            // disconnect from peers older than this proto version
            if (fDebug10) printf("partner %s using obsolete version %i; disconnecting\n", pfrom->addr.ToString().c_str(), pfrom->nVersion);
            pfrom->fDisconnect = true;
            return false;
        }

		if (pfrom->nVersion < MIN_PEER_PROTO_VERSION)
        {
            // disconnect from peers older than this proto version
            if (fDebug10) printf("partner %s using obsolete version %i; disconnecting\n", pfrom->addr.ToString().c_str(), pfrom->nVersion);
            pfrom->fDisconnect = true;
            return false;
        }

		if (!fTestNet && pfrom->nVersion < 180314 && IsResearchAgeEnabled(pindexBest->nHeight))
		{
		    // disconnect from peers older than this proto version
            if (fDebug10) printf("ResearchAge: partner %s using obsolete version %i; disconnecting\n", pfrom->addr.ToString().c_str(), pfrom->nVersion);
            pfrom->fDisconnect = true;
            return false;
       }

        if (pfrom->nVersion == 10300)
            pfrom->nVersion = 300;
        if (!vRecv.empty())
            vRecv >> addrFrom >> nNonce;
        if (!vRecv.empty())
            vRecv >> pfrom->strSubVer;

        if (!vRecv.empty())
            vRecv >> pfrom->nStartingHeight;
		// 12-5-2015 - Append Trust fields
		pfrom->nTrust = 0;
		
		if (!vRecv.empty())			vRecv >> pfrom->sGRCAddress;
		
		
		// Allow newbies to connect easily with 0 blocks
		if (GetArgument("autoban","true") == "true")
		{
				
				// Note: Hacking attempts start in this area 3-26-2016
				if (false && pfrom->nStartingHeight < (nBestHeight/2) && LessVerbose(1) && !fTestNet)
				{
					if (fDebug3) printf("Node with low height");
					pfrom->fDisconnect=true;
					return false;
				}
				/*
				
				if (pfrom->nStartingHeight < 1 && LessVerbose(980) && !fTestNet)
				{
					pfrom->Misbehaving(100);
					if (fDebug3) printf("Disconnecting possible hacker node.  Banned for 24 hours.\r\n");
			    	pfrom->fDisconnect=true;
					return false;
				}
				*/


				// End of critical Section

				if (pfrom->nStartingHeight < 1 && pfrom->nServices == 0 )
				{
					pfrom->Misbehaving(100);
					if (fDebug3) printf("Disconnecting possible hacker node with no services.  Banned for 24 hours.\r\n");
			    	pfrom->fDisconnect=true;
					return false;
				}
		}

	

		if (pfrom->fInbound && addrMe.IsRoutable())
        {
            pfrom->addrLocal = addrMe;
            SeenLocal(addrMe);
        }

        // Disconnect if we connected to ourself
        if (nNonce == nLocalHostNonce && nNonce > 1)
        {
            if (fDebug3) printf("connected to self at %s, disconnecting\n", pfrom->addr.ToString().c_str());
            pfrom->fDisconnect = true;
            return true;
        }

        // record my external IP reported by peer
        if (addrFrom.IsRoutable() && addrMe.IsRoutable())
            addrSeenByPeer = addrMe;

        // Be shy and don't send version until we hear
        if (pfrom->fInbound)
            pfrom->PushVersion();

        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);

        if (GetBoolArg("-synctime", true))
            AddTimeData(pfrom->addr, nTime);

        // Change version
        pfrom->PushMessage("verack");
        pfrom->ssSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));

			
        if (!pfrom->fInbound)
        {
            // Advertise our address
            if (!fNoListen && !IsInitialBlockDownload())
            {
                CAddress addr = GetLocalAddress(&pfrom->addr);
                if (addr.IsRoutable())
                    pfrom->PushAddress(addr);
            }

            // Get recent addresses
            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)
            {
                pfrom->PushMessage("getaddr");
                pfrom->fGetAddr = true;
            }
            addrman.Good(pfrom->addr);
        }
		else
		{
            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)
            {
				if (SecurityTest(pfrom,ver_valid))
				{
					//Dont store the peer unless it passes the test
					addrman.Add(addrFrom, addrFrom);
	                addrman.Good(addrFrom);
				}
            }
        }

    
 	    // Ask the first connected node for block updates
        static int nAskedForBlocks = 0;
        if (!pfrom->fClient && !pfrom->fOneShot &&
            (pfrom->nStartingHeight > (nBestHeight - 144)) &&
            (pfrom->nVersion < NOBLKS_VERSION_START ||
             pfrom->nVersion >= NOBLKS_VERSION_END) &&
             (nAskedForBlocks < 1 || vNodes.size() <= 1))
        {
            nAskedForBlocks++;
            pfrom->PushGetBlocks(pindexBest, uint256(0), true);
        }

        // Relay alerts
        {
            LOCK(cs_mapAlerts);
            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)
                item.second.RelayTo(pfrom);
        }

        // Relay sync-checkpoint
        {
            LOCK(Checkpoints::cs_hashSyncCheckpoint);
            if (!Checkpoints::checkpointMessage.IsNull())
                Checkpoints::checkpointMessage.RelayTo(pfrom);
        }

        pfrom->fSuccessfullyConnected = true;

        if (fDebug10) printf("receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\n", pfrom->nVersion,
			pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());

        cPeerBlockCounts.input(pfrom->nStartingHeight);

        // ppcoin: ask for pending sync-checkpoint if any
        if (!IsInitialBlockDownload())
            Checkpoints::AskForPendingSyncCheckpoint(pfrom);
    }
    else if (pfrom->nVersion == 0)
    {
        // Must have a version message before anything else 1-10-2015 Halford
		printf("Hack attempt from %s - %s (banned) \r\n",pfrom->addrName.c_str(),NodeAddress(pfrom).c_str());
        pfrom->Misbehaving(100);
		pfrom->fDisconnect=true;
        return false;
    }
    else if (strCommand == "verack")
    {
        pfrom->SetRecvVersion(min(pfrom->nVersion, PROTOCOL_VERSION));
    }
    else if (strCommand == "gridaddr")
    {
		//addr->gridaddr
        vector<CAddress> vAddr;
        vRecv >> vAddr;

        // Don't want addr from older versions unless seeding
        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)
            return true;
        if (vAddr.size() > 1000)
        {
            pfrom->Misbehaving(10);
            return error("message addr size() = %"PRIszu"", vAddr.size());
        }

		// Don't store the node address unless they have block height > 50%
		if (pfrom->nStartingHeight < (nBestHeight*.5) && LessVerbose(975)) return true;

        // Store the new addresses
        vector<CAddress> vAddrOk;
        int64_t nNow = GetAdjustedTime();
        int64_t nSince = nNow - 10 * 60;
        BOOST_FOREACH(CAddress& addr, vAddr)
        {
            if (fShutdown)
                return true;
            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)
                addr.nTime = nNow - 5 * 24 * 60 * 60;
            pfrom->AddAddressKnown(addr);
            bool fReachable = IsReachable(addr);

			bool bad_node = (pfrom->nStartingHeight < 1 && LessVerbose(700));


            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable() && !bad_node)
            {
                // Relay to a limited number of other nodes
                {
                    LOCK(cs_vNodes);
                    // Use deterministic randomness to send to the same nodes for 24 hours
                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats
                    static uint256 hashSalt;
                    if (hashSalt == 0)
                        hashSalt = GetRandHash();
                    uint64_t hashAddr = addr.GetHash();
                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ (( GetAdjustedTime() +hashAddr)/(24*60*60));
                    hashRand = Hash(BEGIN(hashRand), END(hashRand));
                    multimap<uint256, CNode*> mapMix;
                    BOOST_FOREACH(CNode* pnode, vNodes)
                    {
                        if (pnode->nVersion < CADDR_TIME_VERSION)
                            continue;
                        unsigned int nPointer;
                        memcpy(&nPointer, &pnode, sizeof(nPointer));
                        uint256 hashKey = hashRand ^ nPointer;
                        hashKey = Hash(BEGIN(hashKey), END(hashKey));
                        mapMix.insert(make_pair(hashKey, pnode));
                    }
                    int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)
                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)
                        ((*mi).second)->PushAddress(addr);
                }
            }
            // Do not store addresses outside our network
            if (fReachable)
                vAddrOk.push_back(addr);
        }
        addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);
        if (vAddr.size() < 1000)
            pfrom->fGetAddr = false;
        if (pfrom->fOneShot)
            pfrom->fDisconnect = true;
    }

    else if (strCommand == "inv")
    {
        vector<CInv> vInv;
        vRecv >> vInv;
        if (vInv.size() > MAX_INV_SZ)
        {
            pfrom->Misbehaving(50);
			printf("\r\n **Hacker tried to send inventory > MAX_INV_SZ **\r\n");
            return error("message inv size() = %"PRIszu"", vInv.size());
        }

        // find last block in inv vector
        unsigned int nLastBlock = (unsigned int)(-1);
        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {
            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {
                nLastBlock = vInv.size() - 1 - nInv;
                break;
            }
        }
        CTxDB txdb("r");
        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)
        {
            const CInv &inv = vInv[nInv];

            if (fShutdown)
                return true;
            pfrom->AddInventoryKnown(inv);

            bool fAlreadyHave = AlreadyHave(txdb, inv);
            if (fDebug10)
                printf("  got inventory: %s  %s\n", inv.ToString().c_str(), fAlreadyHave ? "have" : "new");

            if (!fAlreadyHave)
                pfrom->AskFor(inv);
            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {
                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]), true);
            } else if (nInv == nLastBlock) {
                // In case we are on a very long side-chain, it is possible that we already have
                // the last block in an inv bundle sent in response to getblocks. Try to detect
                // this situation and push another getblocks to continue.
                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0), true);
                if (fDebug10)
                    printf("force getblock request: %s\n", inv.ToString().c_str());
            }

            // Track requests for our stuff
            Inventory(inv.hash);
        }
    }


    else if (strCommand == "getdata")
    {
        vector<CInv> vInv;
        vRecv >> vInv;
        if (vInv.size() > MAX_INV_SZ)
        {
            pfrom->Misbehaving(10);
            return error("message getdata size() = %"PRIszu"", vInv.size());
        }

        if (fDebugNet || (vInv.size() != 1))
		{
            if (fDebug10)  printf("received getdata (%"PRIszu" invsz)\n", vInv.size());
		}

        BOOST_FOREACH(const CInv& inv, vInv)
        {
            if (fShutdown)
                return true;
            if (fDebugNet || (vInv.size() == 1))
			{
              if (fDebug10)   printf("received getdata for: %s\n", inv.ToString().c_str());
			}

            if (inv.type == MSG_BLOCK)
            {
                // Send block from disk
                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);
                if (mi != mapBlockIndex.end())
                {
                    CBlock block;
                    block.ReadFromDisk((*mi).second);
					//HALFORD 12-26-2014
					std::string acid = GetCommandNonce("encrypt");
                    pfrom->PushMessage("encrypt", block, acid);

                    // Trigger them to send a getblocks request for the next batch of inventory
                    if (inv.hash == pfrom->hashContinue)
                    {
                        // ppcoin: send latest proof-of-work block to allow the
                        // download node to accept as orphan (proof-of-stake
                        // block might be rejected by stake connection check)
                        vector<CInv> vInv;
                        vInv.push_back(CInv(MSG_BLOCK, GetLastBlockIndex(pindexBest, false)->GetBlockHash()));
                        pfrom->PushMessage("inv", vInv);
                        pfrom->hashContinue = 0;
                    }
                }
            }
             else if (inv.IsKnownType())
            {
                // Send stream from relay memory
                bool pushed = false;
                {
                    LOCK(cs_mapRelay);
                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);
                    if (mi != mapRelay.end()) {
                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);
                        pushed = true;
                    }
                }
                if (!pushed && inv.type == MSG_TX) {
                    CTransaction tx;
                    if (mempool.lookup(inv.hash, tx)) {
                        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
                        ss.reserve(1000);
                        ss << tx;
                        pfrom->PushMessage("tx", ss);
                    }
                }
            }

            // Track requests for our stuff
            Inventory(inv.hash);
        }
    }

	else if (strCommand == "getblocks")
    {
        CBlockLocator locator;
        uint256 hashStop;
        vRecv >> locator >> hashStop;

        // Find the last block the caller has in the main chain
        CBlockIndex* pindex = locator.GetBlockIndex();

        // Send the rest of the chain
        if (pindex)
            pindex = pindex->pnext;
        int nLimit = 100;
        if (fDebug10) printf("getblocks %d to %s limit %d\n", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);
        for (; pindex; pindex = pindex->pnext)
        {
            if (pindex->GetBlockHash() == hashStop)
            {
                if (fDebug10) printf("  getblocks stopping at %d %s\n", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());
                // ppcoin: tell downloading node about the latest block if it's
                // without risk being rejected due to stake connection check
                if (hashStop != hashBestChain && pindex->GetBlockTime() + nStakeMinAge > pindexBest->GetBlockTime())
                    pfrom->PushInventory(CInv(MSG_BLOCK, hashBestChain));
                break;
            }
            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));
            if (--nLimit <= 0)
            {
                // When this block is requested, we'll send an inv that'll make them
                // getblocks the next batch of inventory.
                if (fDebug10) printf("  getblocks stopping at limit %d %s\n", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());
                pfrom->hashContinue = pindex->GetBlockHash();
                break;
            }
        }
    }
    else if (strCommand == "checkpoint")
    {
        CSyncCheckpoint checkpoint;
        vRecv >> checkpoint;
		//Checkpoint received from node with more than 1 Million GRC:
		if (CHECKPOINT_DISTRIBUTED_MODE==0 || CHECKPOINT_DISTRIBUTED_MODE==1)
		{
			if (checkpoint.ProcessSyncCheckpoint(pfrom))
			{
				// Relay
				pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;
				LOCK(cs_vNodes);
				BOOST_FOREACH(CNode* pnode, vNodes)
					checkpoint.RelayTo(pnode);
			}
		}
		else if (CHECKPOINT_DISTRIBUTED_MODE == 2)
		{
			// R HALFORD: One of our global GRC nodes solved a PoR block, store the last blockhash in memory
			muGlobalCheckpointHash = checkpoint.hashCheckpointGlobal;
			muGlobalCheckpointHashCounter=0;
			// Relay
			pfrom->hashCheckpointKnown = checkpoint.hashCheckpointGlobal;
			//Prevent broadcast storm: If not broadcast yet, relay the checkpoint globally:
			if (muGlobalCheckpointHashRelayed != checkpoint.hashCheckpointGlobal && checkpoint.hashCheckpointGlobal != 0)
			{
				LOCK(cs_vNodes);
				BOOST_FOREACH(CNode* pnode, vNodes)
				{
					checkpoint.RelayTo(pnode);
				}
			}
		}
    }

    else if (strCommand == "getheaders")
    {
        CBlockLocator locator;
        uint256 hashStop;
        vRecv >> locator >> hashStop;

        CBlockIndex* pindex = NULL;
        if (locator.IsNull())
        {
            // If locator is null, return the hashStop block
            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);
            if (mi == mapBlockIndex.end())
                return true;
            pindex = (*mi).second;
        }
        else
        {
            // Find the last block the caller has in the main chain
            pindex = locator.GetBlockIndex();
            if (pindex)
                pindex = pindex->pnext;
        }

        vector<CBlock> vHeaders;
        int nLimit = 1000;
        printf("getheaders %d to %s\n", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());
        for (; pindex; pindex = pindex->pnext)
        {
            vHeaders.push_back(pindex->GetBlockHeader());
            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)
                break;
        }
        pfrom->PushMessage("headers", vHeaders);
    }
    else if (strCommand == "tx")
    {
        vector<uint256> vWorkQueue;
        vector<uint256> vEraseQueue;
        CTransaction tx;
        vRecv >> tx;

        CInv inv(MSG_TX, tx.GetHash());
        pfrom->AddInventoryKnown(inv);

        bool fMissingInputs = false;
        if (AcceptToMemoryPool(mempool, tx, &fMissingInputs))
        {
            RelayTransaction(tx, inv.hash);
            mapAlreadyAskedFor.erase(inv);
            vWorkQueue.push_back(inv.hash);
            vEraseQueue.push_back(inv.hash);
         
			// Recursively process any orphan transactions that depended on this one
            for (unsigned int i = 0; i < vWorkQueue.size(); i++)
            {
                uint256 hashPrev = vWorkQueue[i];
                for (set<uint256>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();
                     mi != mapOrphanTransactionsByPrev[hashPrev].end();
                     ++mi)
                {
                    const uint256& orphanTxHash = *mi;
                    CTransaction& orphanTx = mapOrphanTransactions[orphanTxHash];
                    bool fMissingInputs2 = false;

                    if (AcceptToMemoryPool(mempool, orphanTx, &fMissingInputs2))
                    {
                        printf("   accepted orphan tx %s\n", orphanTxHash.ToString().substr(0,10).c_str());
                        RelayTransaction(orphanTx, orphanTxHash);
                        mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanTxHash));
                        vWorkQueue.push_back(orphanTxHash);
                        vEraseQueue.push_back(orphanTxHash);
						pfrom->nTrust++;
                    }
                    else if (!fMissingInputs2)
                    {
                        // invalid orphan
                        vEraseQueue.push_back(orphanTxHash);
                        printf("   removed invalid orphan tx %s\n", orphanTxHash.ToString().substr(0,10).c_str());
                    }
                }
            }

            BOOST_FOREACH(uint256 hash, vEraseQueue)
                EraseOrphanTx(hash);
        }
        else if (fMissingInputs)
        {
            AddOrphanTx(tx);

            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded
            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);
            if (nEvicted > 0)
                printf("mapOrphan overflow, removed %u tx\n", nEvicted);
        }
        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);
    }


    else if (strCommand == "encrypt")
    {
		//Response from getblocks, message = block

        CBlock block;
		std::string acid = "";
        vRecv >> block >> acid;
        uint256 hashBlock = block.GetHash();

		bool block_valid = AcidTest(strCommand,acid,pfrom);
		if (!block_valid) 
		{	
			if (fDebug) printf("\r\n Acid test failed for block %s \r\n",hashBlock.ToString().c_str());
			return false;
		}

		if (fDebug10) printf("Acid %s, Validity %s ",acid.c_str(),YesNo(block_valid).c_str());

        printf(" Received block %s; ", hashBlock.ToString().c_str());
        if (fDebug10) block.print();

        CInv inv(MSG_BLOCK, hashBlock);
        pfrom->AddInventoryKnown(inv);

        if (ProcessBlock(pfrom, &block, false))
		{
	        mapAlreadyAskedFor.erase(inv);
			pfrom->nTrust++;
		}
        if (block.nDoS) 
		{
				pfrom->Misbehaving(block.nDoS);
				pfrom->nTrust--;
		}

    }


    else if (strCommand == "getaddr")
    {
        // Don't return addresses older than nCutOff timestamp
        int64_t nCutOff =  GetAdjustedTime() - (nNodeLifespan * 24 * 60 * 60);
        pfrom->vAddrToSend.clear();
        vector<CAddress> vAddr = addrman.GetAddr();
        BOOST_FOREACH(const CAddress &addr, vAddr)
            if(addr.nTime > nCutOff)
                pfrom->PushAddress(addr);
    }


    else if (strCommand == "mempool")
    {
        std::vector<uint256> vtxid;
        mempool.queryHashes(vtxid);
        vector<CInv> vInv;
        for (unsigned int i = 0; i < vtxid.size(); i++) {
            CInv inv(MSG_TX, vtxid[i]);
            vInv.push_back(inv);
            if (i == (MAX_INV_SZ - 1))
                    break;
        }
        if (vInv.size() > 0)
            pfrom->PushMessage("inv", vInv);
    }

    else if (strCommand == "reply")
    {
        uint256 hashReply;
        vRecv >> hashReply;

        CRequestTracker tracker;
        {
            LOCK(pfrom->cs_mapRequests);
            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);
            if (mi != pfrom->mapRequests.end())
            {
                tracker = (*mi).second;
                pfrom->mapRequests.erase(mi);
            }
        }
        if (!tracker.IsNull())
            tracker.fn(tracker.param1, vRecv);
    }
	else if (strCommand == "neural")
	{
 	 	    //printf("Received Neural Request \r\n");

			std::string neural_request = "";
			std::string neural_request_id = "";
	        vRecv >> neural_request >> neural_request_id;  // foreign node issued neural request with request ID:
			//printf("neural request %s \r\n",neural_request.c_str());
			std::string neural_response = "generic_response";

			if (neural_request=="neural_data")
			{
				if (!PreventCommandAbuse("neural_data",NodeAddress(pfrom)))
				{
					std::string contract = "";
					#if defined(WIN32) && defined(QT_GUI)
							std::string testnet_flag = fTestNet ? "TESTNET" : "MAINNET";
							qtExecuteGenericFunction("SetTestNetFlag",testnet_flag);
							contract = qtGetNeuralContract("");
					#endif
					pfrom->PushMessage("ndata_nresp", contract);
				}
			}
			else if (neural_request=="neural_hash")
			{
				#if defined(WIN32) && defined(QT_GUI)
					neural_response = qtGetNeuralHash("");
				#endif
				//printf("Neural response %s",neural_response.c_str());
	            pfrom->PushMessage("hash_nresp", neural_response);
			}
			else if (neural_request=="explainmag")
			{
				// To prevent abuse, only respond to a certain amount of explainmag requests per day per cpid
				bool bIgnore = false;
				if (cdbl("0"+ReadCache("explainmag",neural_request_id),0) > 10)
				{
					if (fDebug10) printf("Ignoring explainmag request for %s",neural_request_id.c_str());
		 			pfrom->Misbehaving(1);
					bIgnore = true;
				}
				if (!bIgnore)
				{
					WriteCache("explainmag",neural_request_id,RoundToString(cdbl("0"+ReadCache("explainmag",neural_request_id),0),0),GetAdjustedTime());
					// 7/11/2015 - Allow linux/mac to make neural requests
					#if defined(WIN32) && defined(QT_GUI)
						neural_response = qtExecuteDotNetStringFunction("ExplainMag",neural_request_id);
					#endif
				    pfrom->PushMessage("expmag_nresp", neural_response);
				}
			}
			else if (neural_request=="addbeacon")
			{
				    std::string sBeacon_Sponsorship_Enabled = GetArgument("sponsor", "false");
					if (sBeacon_Sponsorship_Enabled=="true")
					{

						std::vector<std::string> s = split(neural_request_id,"|");
						std::string result = "Malformed Beacon";
						bool bIgnore = false;

						if (s.size() > 1)
						{
								std::string cpid = s[0];
								std::string myBeacon = MyBeaconExists(cpid);
								if (myBeacon.length() > 10)
								{
									bIgnore=true;
									result = "Beacon already exists; ignoring request.";
									if (fDebug10) printf("Add neural beacon: %s ",result.c_str());
		  							pfrom->Misbehaving(10);
								}
								if (s.size() >= 3)
								{
									std::string cpidv2 = s[2];
									std::string hashRand = s[3];
									uint256 uHash(hashRand);
									bool IsCPIDValid2 = CPID_IsCPIDValid(cpid,cpidv2,uHash);
									if (!IsCPIDValid2)
									{
										result = "Unable to sponsor beacon for invalid CPID " + cpid;
										if (fDebug10) printf("Add Neural Beacon: %s",result.c_str());
		  								pfrom->Misbehaving(10);
     									bIgnore = true;
									}
								}
								// Have we already sponsored beacon before?
								if (ReadCache("sponsored",cpid)=="true")
								{
									result = "Unable to sponsor beacon for CPID " + cpid + ": already sponsored previously.";
									if (fDebug10) printf("Add neural beacon : %s",result.c_str());
		 							pfrom->Misbehaving(10);
									bIgnore = true;
								}
								if (!bIgnore)
								{
										result = AddContract("beacon",cpid,s[1]);
										WriteCache("sponsored",cpid,"true",GetAdjustedTime());
								}
								if (fDebug3) printf("Acting as Sponsor for CPID %s : adding beacon %s; result %s", cpid.c_str(), s[1].c_str(), result.c_str());
						}
						pfrom->PushMessage("addbeac_nresp", result);
					}
			}
			else if (neural_request=="quorum")
			{
				// 7-12-2015 Resolve discrepencies in the neural network intelligently - allow nodes to speak to each other
				std::string contract = "";
				#if defined(WIN32) && defined(QT_GUI)
						std::string testnet_flag = fTestNet ? "TESTNET" : "MAINNET";
						qtExecuteGenericFunction("SetTestNetFlag",testnet_flag);
						contract = qtGetNeuralContract("");
				#endif
				//if (fDebug10) printf("Quorum response %f \r\n",(double)contract.length());
	            pfrom->PushMessage("quorum_nresp", contract);
			}
			else
			{
				neural_response="generic_response";
			}

	}
    else if (strCommand == "ping")
    {


		std::string acid = "";
        if (pfrom->nVersion > BIP0031_VERSION)
        {
            uint64_t nonce = 0;
            vRecv >> nonce >> acid;
			bool pong_valid = AcidTest(strCommand,acid,pfrom);
			if (!pong_valid) return false;
			//if (fDebug10) printf("pong valid %s",YesNo(pong_valid).c_str());

            // Echo the message back with the nonce. This allows for two useful features:
            //
            // 1) A remote node can quickly check if the connection is operational
            // 2) Remote nodes can measure the latency of the network thread. If this node
            //    is overloaded it won't respond to pings quickly and the remote node can
            //    avoid sending us more work, like chain download requests.
            //
            // The nonce stops the remote getting confused between different pings: without
            // it, if the remote node sends a ping once per second and this node takes 5
            // seconds to respond to each, the 5th ping the remote sends would appear to
            // return very quickly.
			pfrom->PushMessage("pong", nonce);
        }
	}
	else if (strCommand == "pong")
    {
        int64_t pingUsecEnd = GetTimeMicros();
        uint64_t nonce = 0;
        size_t nAvail = vRecv.in_avail();
        bool bPingFinished = false;
        std::string sProblem;

        if (nAvail >= sizeof(nonce)) {
            vRecv >> nonce;

            // Only process pong message if there is an outstanding ping (old ping without nonce should never pong)
            if (pfrom->nPingNonceSent != 0) 
			{
                if (nonce == pfrom->nPingNonceSent) 
				{
                    // Matching pong received, this ping is no longer outstanding
                    bPingFinished = true;
                    int64_t pingUsecTime = pingUsecEnd - pfrom->nPingUsecStart;
                    if (pingUsecTime > 0) {
                        // Successful ping time measurement, replace previous
                        pfrom->nPingUsecTime = pingUsecTime;
                    } else {
                        // This should never happen
                        sProblem = "Timing mishap";
                    }
                } else {
                    // Nonce mismatches are normal when pings are overlapping
                    sProblem = "Nonce mismatch";
                    if (nonce == 0) {
                        // This is most likely a bug in another implementation somewhere, cancel this ping
                        bPingFinished = true;
                        sProblem = "Nonce zero";
                    }
                }
            } else {
                sProblem = "Unsolicited pong without ping";
            }
        } else {
            // This is most likely a bug in another implementation somewhere, cancel this ping
            bPingFinished = true;
            sProblem = "Short payload";
        }

        if (!(sProblem.empty())) {
            printf("pong %s %s: %s, %"PRIx64" expected, %"PRIx64" received, %f bytes\n"
                , pfrom->addr.ToString().c_str()
                , pfrom->strSubVer.c_str()
                , sProblem.c_str()                , pfrom->nPingNonceSent                , nonce                , (double)nAvail);
        }
        if (bPingFinished) {
            pfrom->nPingNonceSent = 0;
        }
    }
	else if (strCommand=="addbeac_nresp")
	{
			std::string neural_response = "?";
	        vRecv >> neural_response;
			pfrom->NeuralHash = neural_response;
			if (fDebug3) printf("Add Beacon Neural Response %s \r\n",neural_response.c_str());
			msMiningErrors7=neural_response;
	}
	else if (strCommand == "hash_nresp")
	{
			std::string neural_response = "";
	        vRecv >> neural_response;
			// if (pfrom->nNeuralRequestSent != 0)
			// nNeuralNonce must match request ID
			pfrom->NeuralHash = neural_response;
			if (fDebug10) printf("hash_Neural Response %s \r\n",neural_response.c_str());
	}
	else if (strCommand == "expmag_nresp")
	{
			std::string neural_response = "";
	        vRecv >> neural_response;
			if (neural_response.length() > 10)
			{
				msNeuralResponse=neural_response;
				//If invalid, try again 10-20-2015
				VerifyExplainMagnitudeResponse();
			}
			if (fDebug10) printf("expmag_Neural Response %s \r\n",neural_response.c_str());
	}
	else if (strCommand == "quorum_nresp")
	{
			std::string neural_contract = "";
	        vRecv >> neural_contract;
			if (fDebug && neural_contract.length() > 100) printf("Quorum contract received %s",neural_contract.substr(0,80).c_str());
			if (neural_contract.length() > 10)
			{
				 std::string results = "";
				 //Resolve discrepancies
		 		 #if defined(WIN32) && defined(QT_GUI)
	 	 		 	std::string testnet_flag = fTestNet ? "TESTNET" : "MAINNET";
					qtExecuteGenericFunction("SetTestNetFlag",testnet_flag);
					results = qtExecuteDotNetStringFunction("ResolveDiscrepancies",neural_contract);
				 #endif
	  			 if (fDebug && !results.empty()) printf("Quorum Resolution: %s \r\n",results.c_str());
			}
	}
	else if (strCommand == "ndata_nresp")
	{
			std::string neural_contract = "";
	        vRecv >> neural_contract;
			if (fDebug3 && neural_contract.length() > 100) printf("Quorum contract received %s",neural_contract.substr(0,80).c_str());
			if (neural_contract.length() > 10)
			{
				 std::string results = "";
				 //Resolve discrepancies
		 		 #if defined(WIN32) && defined(QT_GUI)
	 	 		 	std::string testnet_flag = fTestNet ? "TESTNET" : "MAINNET";
					qtExecuteGenericFunction("SetTestNetFlag",testnet_flag);
					printf("\r\n** Sync neural network data from supermajority **\r\n");
					results = qtExecuteDotNetStringFunction("ResolveCurrentDiscrepancies",neural_contract);
				 #endif
	  			 if (fDebug && !results.empty()) printf("Quorum Resolution: %s \r\n",results.c_str());
				 // Resume the full DPOR sync at this point now that we have the supermajority data
				 if (results=="SUCCESS")  FullSyncWithDPORNodes();
			}
	}

    else if (strCommand == "pong_old")
    {
        int64_t pingUsecEnd = nTimeReceived;
        uint64_t nonce = 0;
        size_t nAvail = vRecv.in_avail();
        bool bPingFinished = false;
        std::string sProblem;
	    if (nAvail >= sizeof(nonce)) {
            vRecv >> nonce;

            // Only process pong message if there is an outstanding ping (old ping without nonce should never pong)
            if (pfrom->nPingNonceSent != 0) {
                if (nonce == pfrom->nPingNonceSent) {
                    // Matching pong received, this ping is no longer outstanding
                    bPingFinished = true;
                    int64_t pingUsecTime = pingUsecEnd - pfrom->nPingUsecStart;
                    if (pingUsecTime >= -1) {
                        // Successful ping time measurement, replace previous
                        pfrom->nPingUsecTime = pingUsecTime;
                    } else {
                        // This should never happen
                        sProblem = "Timing mishap";
                    }
                } else {
                    // Nonce mismatches are normal when pings are overlapping
                    sProblem = "Nonce mismatch";
                    if (nonce == 0) {
                        // This is most likely a bug in another implementation somewhere, cancel this ping
                        bPingFinished = true;
                        sProblem = "Nonce zero";
                    }
                }
            } else {
                sProblem = "Unsolicited pong without ping";
            }
        } else {
            // This is most likely a bug in another implementation somewhere, cancel this ping
            bPingFinished = true;
            sProblem = "Short payload";
        }

        if (!(sProblem.empty())) {
            printf("pong %s %s: %s, %"PRIx64" expected, %"PRIx64" received, %f bytes\n"
                , pfrom->addr.ToString().c_str()
                , pfrom->strSubVer.c_str()
                , sProblem.c_str()
                , pfrom->nPingNonceSent
                , nonce
                , (double)nAvail);
        }
        if (bPingFinished) {
            pfrom->nPingNonceSent = 0;
        }
    }


    else if (strCommand == "alert")
    {
        CAlert alert;
        vRecv >> alert;

        uint256 alertHash = alert.GetHash();
        if (pfrom->setKnown.count(alertHash) == 0)
        {
            if (alert.ProcessAlert())
            {
                // Relay
                pfrom->setKnown.insert(alertHash);
                {
                    LOCK(cs_vNodes);
                    BOOST_FOREACH(CNode* pnode, vNodes)
                        alert.RelayTo(pnode);
                }
            }
            else {
                // Small DoS penalty so peers that send us lots of
                // duplicate/expired/invalid-signature/whatever alerts
                // eventually get banned.
                // This isn't a Misbehaving(100) (immediate ban) because the
                // peer might be an older or different implementation with
                // a different signature key, etc.
                pfrom->Misbehaving(10);
            }
        }
    }


    else
    {
        // Ignore unknown commands for extensibility
        // Let the peer know that we didn't find what it asked for, so it doesn't
        // have to wait around forever. Currently only SPV clients actually care
        // about this message: it's needed when they are recursively walking the
        // dependencies of relevant unconfirmed transactions. SPV clients want to
        // do that because they want to know about (and store and rebroadcast and
        // risk analyze) the dependencies of transactions relevant to them, without
        // having to download the entire memory pool.


    }

    // Update the last seen time for this node's address
    if (pfrom->fNetworkNode)
        if (strCommand == "aries" || strCommand == "gridaddr" || strCommand == "inv" || strCommand == "getdata" || strCommand == "ping")
            AddressCurrentlyConnected(pfrom->addr);

    return true;
}


void AddPeek(std::string data)
{
	std::string buffer = RoundToString((double)GetAdjustedTime(),0) + ":" + data + "<CR>";
	msPeek += buffer;
	if (msPeek.length() > 60000) msPeek = "";
	if ((GetAdjustedTime() - nLastPeek) > 60)
	{
		printf("\r\nLong Duration : %s\r\n",buffer.c_str());
	}
	nLastPeek = GetAdjustedTime();
}


// requires LOCK(cs_vRecvMsg)
bool ProcessMessages(CNode* pfrom)
{
    //
    // Message format
    //  (4) message start
    //  (12) command
    //  (4) size
    //  (4) checksum
    //  (x) data
    //
    bool fOk = true;

    std::deque<CNetMessage>::iterator it = pfrom->vRecvMsg.begin();
    while (!pfrom->fDisconnect && it != pfrom->vRecvMsg.end()) {
        // Don't bother if send buffer is too full to respond anyway
        if (pfrom->nSendSize >= SendBufferSize())
            break;

        // get next message
        CNetMessage& msg = *it;

        //if (fDebug10)
        //    printf("ProcessMessages(message %u msgsz, %zu bytes, complete:%s)\n",
        //            msg.hdr.nMessageSize, msg.vRecv.size(),
        //            msg.complete() ? "Y" : "N");

        // end, if an incomplete message is found
        if (!msg.complete())
            break;

        // at this point, any failure means we can delete the current message
        it++;

        // Scan for message start
        if (memcmp(msg.hdr.pchMessageStart, pchMessageStart, sizeof(pchMessageStart)) != 0) {
            if (fDebug10) printf("\n\nPROCESSMESSAGE: INVALID MESSAGESTART\n\n");
            fOk = false;
            break;
        }

        // Read header
        CMessageHeader& hdr = msg.hdr;
        if (!hdr.IsValid())
        {
            printf("\n\nPROCESSMESSAGE: ERRORS IN HEADER %s\n\n\n", hdr.GetCommand().c_str());
            continue;
        }
        string strCommand = hdr.GetCommand();


        // Message size
        unsigned int nMessageSize = hdr.nMessageSize;

		// Have a peek into what this node is doing
		if (LessVerbose(100))
		{
			std::string Peek = strCommand + ":" + RoundToString((double)nMessageSize,0) + " [" + NodeAddress(pfrom) + "]";
			AddPeek(Peek);
			std::string sCurrentCommand = RoundToString((double)GetAdjustedTime(),0) + Peek;
			std::string msLastNodeCommand = ReadCache("node_command",NodeAddress(pfrom));
			WriteCache("node_command",NodeAddress(pfrom),sCurrentCommand,GetAdjustedTime());
			if (msLastCommand == sCurrentCommand || (msLastNodeCommand == sCurrentCommand && !sCurrentCommand.empty()))
			{
   				  //Node Duplicates
				  double node_duplicates = cdbl(ReadCache("duplicates",NodeAddress(pfrom)),0) + 1;
				  WriteCache("duplicates",NodeAddress(pfrom),RoundToString(node_duplicates,0),GetAdjustedTime());
				  if ((node_duplicates > 350 && !fTestNet && !OutOfSyncByAge()))
				  {
						printf(" Dupe (misbehaving) %s %s ",NodeAddress(pfrom).c_str(),Peek.c_str());
			     		pfrom->fDisconnect = true;
						WriteCache("duplicates",NodeAddress(pfrom),"0",GetAdjustedTime());
						return false;
				  }
     		}
			else
			{
				  double node_duplicates = cdbl(ReadCache("duplicates",NodeAddress(pfrom)),0) - 15;
				  if (node_duplicates < 1) node_duplicates = 0;
				  WriteCache("duplicates",NodeAddress(pfrom),RoundToString(node_duplicates,0),GetAdjustedTime());
			}
			msLastCommand = sCurrentCommand;
		}


        // Checksum
        CDataStream& vRecv = msg.vRecv;
        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);
        unsigned int nChecksum = 0;
        memcpy(&nChecksum, &hash, sizeof(nChecksum));
        if (nChecksum != hdr.nChecksum)
        {
            printf("ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\n",
               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);
            continue;
        }

        // Process message
        bool fRet = false;
        try
        {
            {
                LOCK(cs_main);
                fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime);
            }
            if (fShutdown)
                break;
        }
        catch (std::ios_base::failure& e)
        {
            if (strstr(e.what(), "end of data"))
            {
                // Allow exceptions from under-length message on vRecv
                printf("ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\n", strCommand.c_str(), nMessageSize, e.what());
            }
            else if (strstr(e.what(), "size too large"))
            {
                // Allow exceptions from over-long size
                printf("ProcessMessages(%s, %u bytes) : Exception '%s' caught\n", strCommand.c_str(), nMessageSize, e.what());
            }
            else
            {
                PrintExceptionContinue(&e, "ProcessMessages()");
            }
        }
        catch (std::exception& e) {
            PrintExceptionContinue(&e, "ProcessMessages()");
        } catch (...) {
            PrintExceptionContinue(NULL, "ProcessMessages()");
        }

        if (!fRet)
		{
           if (fDebug10)   printf("ProcessMessage(%s, %u bytes) FAILED\n", strCommand.c_str(), nMessageSize);
		}
    }

    // In case the connection got shut down, its receive buffer was wiped
    if (!pfrom->fDisconnect)
        pfrom->vRecvMsg.erase(pfrom->vRecvMsg.begin(), it);

    return fOk;
}



double checksum(std::string s)
{
	char ch;
	double chk = 0;
	std::string sOut = "";
	for (unsigned int i=0;i < s.length(); i++)
	{
		ch = s.at(i);
		int ascii = ch;
		chk=chk+ascii;
	}
	return chk;
}




 uint256 GetScryptHashString(std::string s)
 {
        uint256 thash = 0;
		thash = Hash(BEGIN(s),END(s));
        return thash;
 }



uint256 GridcoinMultipleAlgoHash(std::string t1)
{
        uint256 thash = 0;
    	std::string& t2 = t1;
		thash = Hash(t2.begin(),t2.begin()+t2.length());
		return thash;
}


std::string aes_complex_hash(uint256 scrypt_hash)
{
	  if (scrypt_hash==0) return "0";

			std::string	sScryptHash = scrypt_hash.GetHex();
			std::string	sENCAES512 = AdvancedCrypt(sScryptHash);
			double chk = checksum(sENCAES512);
			uint256     hashSkein = GridcoinMultipleAlgoHash(sScryptHash);
			hashSkein = hashSkein + chk;
			std::string sSkeinAES512 = hashSkein.GetHex();
			return sSkeinAES512;
}


double LederstrumpfMagnitude_Retired(double Magnitude, int64_t locktime)
{
	// Note: This function returns an exponentially smaller result as the magnitude approaches the cap
	// The function is fine; keeping it in the coin for reference.  We moved to the new function when we thought the calculation was malfunctioning.  Later tests proved it works fine.
	// Establish constants
    double e = 2.718;
	double v = 4;
	double r = 0.915;
	double x = 0;
	double new_magnitude = 0;
	double user_magnitude_cap = 3000; //This is where the full 500 magnitude is achieved
	//Function returns a new magnitude between Magnitudes > 80% of Cap and <= Cap;
	double MagnitudeCap_LowSide = GetMaximumBoincSubsidy(locktime)*.80;
	if (Magnitude < MagnitudeCap_LowSide) return Magnitude;
	x = Magnitude / (user_magnitude_cap);
	new_magnitude = ((MagnitudeCap_LowSide/2) / (1 + pow((double)e, (double)(-v * (x - r))))) + MagnitudeCap_LowSide;
	//Debug.Print "With RAC of " + Trim(Rac) + ", NetRac of " + Trim(NetworkRac) + ", Subsidy = " + Trim(Subsidy)
	if (new_magnitude < MagnitudeCap_LowSide) new_magnitude=MagnitudeCap_LowSide;
	if (new_magnitude > GetMaximumBoincSubsidy(locktime)) new_magnitude=GetMaximumBoincSubsidy(locktime);
	return new_magnitude;
}


double LederstrumpfMagnitude2(double Magnitude, int64_t locktime)
{
	//2-1-2015 - Halford - The MagCap is 2000
	double MagCap = 2000;
	double out_mag = Magnitude;
	if (Magnitude >= MagCap*.90 && Magnitude <= MagCap*1.0) out_mag = MagCap*.90;
	if (Magnitude >= MagCap*1.0 && Magnitude <= MagCap*1.1) out_mag = MagCap*.91;
	if (Magnitude >= MagCap*1.1 && Magnitude <= MagCap*1.2) out_mag = MagCap*.92;
	if (Magnitude >= MagCap*1.2 && Magnitude <= MagCap*1.3) out_mag = MagCap*.93;
	if (Magnitude >= MagCap*1.3 && Magnitude <= MagCap*1.4) out_mag = MagCap*.94;
	if (Magnitude >= MagCap*1.4 && Magnitude <= MagCap*1.5) out_mag = MagCap*.95;
	if (Magnitude >= MagCap*1.5 && Magnitude <= MagCap*1.6) out_mag = MagCap*.96;
	if (Magnitude >= MagCap*1.6 && Magnitude <= MagCap*1.7) out_mag = MagCap*.97;
	if (Magnitude >= MagCap*1.7 && Magnitude <= MagCap*1.8) out_mag = MagCap*.98;
	if (Magnitude >= MagCap*1.8 && Magnitude <= MagCap*1.9) out_mag = MagCap*.99;
	if (Magnitude >= MagCap*1.9)						    out_mag = MagCap*1.0;
	return out_mag;
}



bool Contains(std::string data, std::string instring)
{
	std::size_t found = 0;
	found = data.find(instring);
	if (found != std::string::npos) return true;
	return false;
}


std::string NN(std::string value)
{
	return value.empty() ? "" : value;
}

double PendingSuperblockHeight()
{
	double height = cdbl(ReadCache("neuralsecurity","pending"),0);
	if (height < (double)(pindexBest->nHeight-200)) height = 0;
	return height;
}

std::string GetNeuralNetworkSuperBlock()
{
	//Only try to stake a superblock if the contract expired And the superblock is the highest popularity block And we do not have a pending superblock
	int64_t superblock_age = GetAdjustedTime() - mvApplicationCacheTimestamp["superblock;magnitudes"];
	if (NeuralNodeParticipates() && NeedASuperblock() && PendingSuperblockHeight()==0)
	{
		std::string myNeuralHash = "";
		#if defined(WIN32) && defined(QT_GUI)
	           myNeuralHash = qtGetNeuralHash("");
		#endif
 	    double popularity = 0;
		std::string consensus_hash = GetNeuralNetworkSupermajorityHash(popularity);
		if (fDebug2 && LessVerbose(5)) printf("SB Age %f, MyHash %s, ConsensusHash %s",(double)superblock_age,myNeuralHash.c_str(),consensus_hash.c_str());
		if (consensus_hash==myNeuralHash)
		{
			//Stake the contract
			std::string contract = "";
			#if defined(WIN32) && defined(QT_GUI)
				contract = qtGetNeuralContract("");
				if (fDebug2 && LessVerbose(5)) printf("Appending SuperBlock %f\r\n",(double)contract.length());
				if (bNewbieFeatureEnabled)
				{
					// 12-21-2015 : Stake a binary superblock
					contract = PackBinarySuperblock(contract);
				}
			#endif
			return contract;
		}

	}
	return "";

}

std::string GetLastPORBlockHash(std::string cpid)
{
	StructCPID stCPID = GetInitializedStructCPID2(cpid,mvResearchAge);
	return stCPID.BlockHash;
}

std::string SerializeBoincBlock(MiningCPID mcpid)
{
	std::string delim = "<|>";
	std::string version = FormatFullVersion();
	mcpid.GRCAddress = DefaultWalletAddress();
	if (!IsResearchAgeEnabled(pindexBest->nHeight))
	{
		mcpid.Organization = DefaultOrg();
		mcpid.OrganizationKey = DefaultBlockKey(8); //Only reveal 8 characters
	}
	else
	{
		mcpid.projectname = "";
		mcpid.rac = 0;
		mcpid.NetworkRAC = 0;
	}
	//int64_t superblock_age = GetAdjustedTime() - mvApplicationCacheTimestamp["superblock;magnitudes"];

	std::string sNeuralHash = "";
	// To save network bandwidth, start posting the neural hashes in the CurrentNeuralHash field, so that out of sync neural network nodes can request neural data from those that are already synced and agree with the supermajority over the last 24 hrs
	if (!OutOfSyncByAge())
	{
		#if defined(WIN32) && defined(QT_GUI)
			sNeuralHash = qtGetNeuralHash("");
			mcpid.CurrentNeuralHash = sNeuralHash;
		#endif
	}

	//7-25-2015 - Add the neural hash only if necessary
	if (!OutOfSyncByAge() && NeuralNodeParticipates() && NeedASuperblock())
	{
		#if defined(WIN32) && defined(QT_GUI)
			mcpid.NeuralHash = sNeuralHash;
			mcpid.superblock = GetNeuralNetworkSuperBlock();
		#endif
	}

	mcpid.LastPORBlockHash = GetLastPORBlockHash(mcpid.cpid);

	if (mcpid.lastblockhash.empty()) mcpid.lastblockhash = "0";
	if (mcpid.LastPORBlockHash.empty()) mcpid.LastPORBlockHash="0";

	// If this is a POR, sign the block proving ownership of the CPID
	if (!mcpid.cpid.empty() && mcpid.cpid != "INVESTOR" && mcpid.lastblockhash != "0")
	{
		mcpid.BoincPublicKey = GetBeaconPublicKey(mcpid.cpid);
		if (!mcpid.BoincPublicKey.empty())
		{
			mcpid.BoincSignature = SignBlockWithCPID(mcpid.cpid,mcpid.lastblockhash);
		}
	}

	std::string bb = mcpid.cpid + delim + mcpid.projectname + delim + mcpid.aesskein + delim + RoundToString(mcpid.rac,0)
					+ delim + RoundToString(mcpid.pobdifficulty,5) + delim + RoundToString((double)mcpid.diffbytes,0)
					+ delim + NN(mcpid.enccpid)
					+ delim + NN(mcpid.encaes) + delim + RoundToString(mcpid.nonce,0) + delim + RoundToString(mcpid.NetworkRAC,0)
					+ delim + NN(version)
					+ delim + RoundToString(mcpid.ResearchSubsidy,2)
					+ delim + RoundToString(mcpid.LastPaymentTime,0)
					+ delim + RoundToString(mcpid.RSAWeight,0)
					+ delim + NN(mcpid.cpidv2)
					+ delim + RoundToString(mcpid.Magnitude,0)
					+ delim + NN(mcpid.GRCAddress) + delim + NN(mcpid.lastblockhash)
					+ delim + RoundToString(mcpid.InterestSubsidy,2) + delim + NN(mcpid.Organization)
					+ delim + NN(mcpid.OrganizationKey) + delim + mcpid.NeuralHash + delim + mcpid.superblock
					+ delim + RoundToString(mcpid.ResearchSubsidy2,2) + delim + RoundToString(mcpid.ResearchAge,6)
					+ delim + RoundToString(mcpid.ResearchMagnitudeUnit,6) + delim + RoundToString(mcpid.ResearchAverageMagnitude,2)
					+ delim + NN(mcpid.LastPORBlockHash) + delim + mcpid.CurrentNeuralHash + delim + mcpid.BoincPublicKey + delim + mcpid.BoincSignature;
	return bb;
}



MiningCPID DeserializeBoincBlock(std::string block)
{
	MiningCPID surrogate = GetMiningCPID();
	try
	{

	std::vector<std::string> s = split(block,"<|>");
	if (s.size() > 7)
	{
		surrogate.cpid = s[0];
		surrogate.projectname = s[1];
		boost::to_lower(surrogate.projectname);
      	surrogate.aesskein = s[2];
		surrogate.rac = cdbl(s[3],0);
		surrogate.pobdifficulty = cdbl(s[4],6);
		surrogate.diffbytes = (unsigned int)cdbl(s[5],0);
		surrogate.enccpid = s[6];
		surrogate.encboincpublickey = s[6];
		surrogate.encaes = s[7];
		surrogate.nonce = cdbl(s[8],0);
		if (s.size() > 9)
		{
			surrogate.NetworkRAC = cdbl(s[9],0);
		}
		if (s.size() > 10)
		{
			surrogate.clientversion = s[10];
		}
		if (s.size() > 11)
		{
			surrogate.ResearchSubsidy = cdbl(s[11],2);
		}
		if (s.size() > 12)
		{
			surrogate.LastPaymentTime = cdbl(s[12],0);
		}
		if (s.size() > 13)
		{
			surrogate.RSAWeight = cdbl(s[13],0);
		}
		if (s.size() > 14)
		{
			surrogate.cpidv2 = s[14];
		}
		if (s.size() > 15)
		{
			surrogate.Magnitude = cdbl(s[15],0);
		}
		if (s.size() > 16)
		{
			surrogate.GRCAddress = s[16];
		}
		if (s.size() > 17)
		{
			surrogate.lastblockhash = s[17];
		}
		if (s.size() > 18)
		{
			surrogate.InterestSubsidy = cdbl(s[18],2);
		}
		if (s.size() > 19)
		{
			surrogate.Organization = s[19];
		}
		if (s.size() > 20)
		{
			surrogate.OrganizationKey = s[20];
		}
		if (s.size() > 21)
		{
			surrogate.NeuralHash = s[21];
		}
		if (s.size() > 22)
		{
			surrogate.superblock = s[22];
		}
		if (s.size() > 23)
		{
			surrogate.ResearchSubsidy2 = cdbl(s[23],2);
		}
		if (s.size() > 24)
		{
			surrogate.ResearchAge = cdbl(s[24],6);
		}
		if (s.size() > 25)
		{
			surrogate.ResearchMagnitudeUnit = cdbl(s[25],6);
		}
		if (s.size() > 26)
		{
			surrogate.ResearchAverageMagnitude = cdbl(s[26],2);
		}
		if (s.size() > 27)
		{
			surrogate.LastPORBlockHash = s[27];
		}
		if (s.size() > 28)
		{
			surrogate.CurrentNeuralHash = s[28];
		}
		if (s.size() > 29)
		{
			surrogate.BoincPublicKey = s[29];
		}
		if (s.size() > 30)
		{
			surrogate.BoincSignature = s[30];
		}

	}
	}
	catch (...)
	{
		    printf("Deserialize ended with an error (06182014) \r\n");
	}
	return surrogate;
}



void printbool(std::string comment, bool boo)
{
	std::string b = boo ? "TRUE" : "FALSE";
	printf("%s : %s",comment.c_str(),b.c_str());
}



std::string ComputeCPIDv2(std::string email, std::string bpk, uint256 blockhash)
{
		//if (GetBoolArg("-disablecpidv2")) return "";
		CPID c = CPID();
		std::string cpid_non = bpk+email;
		std::string digest = c.CPID_V2(email,bpk,blockhash);
		return digest;
}



std::string boinc_hash(const std::string str)
{
	// Return the boinc hash of a string:
    CPID c = CPID(str);
    return c.hexdigest();
}




void InitializeProjectStruct(StructCPID& project)
{
	std::string email = GetArgument("email", "NA");
	boost::to_lower(email);

	project.email = email;
	std::string cpid_non = project.cpidhash+email;
	project.boincruntimepublickey = project.cpidhash;
	project.cpid = boinc_hash(cpid_non);
	std::string ENCbpk = AdvancedCrypt(cpid_non);
	project.boincpublickey = ENCbpk;
	project.cpidv2 = ComputeCPIDv2(email, project.cpidhash, 0);
	// (Old netsoft link) project.link = "http://boinc.netsoft-online.com/get_user.php?cpid=" + project.cpid;
	project.link = "http://boinc.netsoft-online.com/e107_plugins/boinc/get_user.php?cpid=" + project.cpid;
	//Local CPID with struct
	//Must contain cpidv2, cpid, boincpublickey
	project.Iscpidvalid = IsLocalCPIDValid(project);
 	if (fDebug10) printf("Memorizing local project %s, CPID Valid: %s;    ",project.projectname.c_str(),YesNo(project.Iscpidvalid).c_str());

}





std::string GetNetsoftProjects(std::string cpid)
{
			std::string cc = GetHttpPage(cpid,true,true);
			if (cc.length() < 10)
			{
				if (fDebug10) printf("Note: HTTP Page returned blank from netsoft for %s\r\n",cpid.c_str());
				return "";
			}

			int iRow = 0;
			std::vector<std::string> vCC = split(cc.c_str(),"<project>");

			if (vCC.size() > 1)
			{
				for (unsigned int i = 0; i < vCC.size(); i++)
				{
					std::string sProj  = ExtractXML(vCC[i],"<name>","</name>");
					std::string utc    = ExtractXML(vCC[i],"<total_credit>","</total_credit>");
					std::string rac    = ExtractXML(vCC[i],"<expavg_credit>","</expavg_credit>");
					std::string team   = ExtractXML(vCC[i],"<team_name>","</team_name>");
					std::string rectime= ExtractXML(vCC[i],"<expavg_time>","</expavg_time>");
					boost::to_lower(sProj);
					sProj = ToOfficialName(sProj);
					if (sProj == "mindmodeling@home") sProj = "mindmodeling@beta";
					if (sProj == "Quake Catcher Network") sProj = "Quake-Catcher Network";

					if (sProj.length() > 3)
					{
						std::string sKey = cpid + "+" + sProj;
						StructCPID strDPOR = GetInitializedStructCPID2(sKey,mvDPOR);
						iRow++;
						strDPOR.cpid = cpid;
						strDPOR.NetsoftRAC = cdbl(rac,0);
						mvDPOR[sKey] = strDPOR;
					}
				}
			}

			return cc;

}




void CreditCheck(std::string cpid, bool clearcache)
{
	try {

			std::string cc = GetHttpPage(cpid,true,clearcache);
			if (cc.length() < 50)
			{
				if (fDebug10) printf("Note: HTTP Page returned blank from netsoft for %s\r\n",cpid.c_str());
				return;
			}

			int iRow = 0;
			std::vector<std::string> vCC = split(cc.c_str(),"<project>");
			if (vCC.size() > 0)
			{
				for (unsigned int i = 0; i < vCC.size(); i++)
				{
					std::string sProj  = ExtractXML(vCC[i],"<name>","</name>");
					std::string utc    = ExtractXML(vCC[i],"<total_credit>","</total_credit>");
					std::string rac    = ExtractXML(vCC[i],"<expavg_credit>","</expavg_credit>");
					std::string team   = ExtractXML(vCC[i],"<team_name>","</team_name>");
					std::string rectime= ExtractXML(vCC[i],"<expavg_time>","</expavg_time>");
					std::string proj_id= ExtractXML(vCC[i],"<project_id>","</project_id>");

					boost::to_lower(sProj);
					sProj = ToOfficialName(sProj);

					if (sProj.length() > 3 && !proj_id.empty())
					{
						//7-16-2015
						StructCPID structcc = GetInitializedStructCPID2(sProj,mvCPIDs);
						iRow++;
						structcc.cpid = cpid;
						structcc.projectname = sProj;
						boost::to_lower(team);
						structcc.verifiedteam = team;
						if (structcc.verifiedteam != "gridcoin") structcc.rac = -1;
						structcc.verifiedrectime = cdbl(rectime,0);
						structcc.verifiedrac = cdbl(rac,0);
						structcc.rac = cdbl(rac,0);
						double currenttime =  GetAdjustedTime();
						double nActualTimespan = currenttime - structcc.verifiedrectime;
						structcc.verifiedage = nActualTimespan;
						mvCPIDs[sProj] = structcc;
						//////////////////////////// Store this information by CPID+Project also:
						std::string sKey = cpid + ":" + sProj;

					}
				}
			}

	}
	catch (std::exception &e)
	{
			 printf("error while accessing credit check online.\r\n");
	}
    catch(...)
	{
			printf("Error While accessing credit check online (2).\r\n");
	}


}





bool ProjectIsValid(std::string project)
{
	boost::to_lower(project);

	StructCPID structcpid = GetInitializedStructCPID2(project,mvBoincProjects);

	return structcpid.initialized;

}

std::string ToOfficialName(std::string proj)
{

			return ToOfficialNameNew(proj);

			/*
			boost::to_lower(proj);
			//Convert local XML project name [On the Left] to official [Netsoft] projectname:
			if (proj=="boincsimap")             proj = "simap";
			if (proj=="pogs")                   proj = "theskynet pogs";
			if (proj=="convector.fsv.cvut.cz")  proj = "convector";
			if (proj=="distributeddatamining")  proj = "distributed data mining";
			if (proj=="distrrtgen")             proj = "distributed rainbow table generator";
			if (proj=="eon2")                   proj = "eon";
			if (proj=="test4theory@home")       proj = "test4theory";
			if (proj=="lhc@home")               proj = "lhc@home 1.0";
			if (proj=="mindmodeling@beta")      proj = "mindmodeling@beta";
			if (proj=="volpex@uh")              proj = "volpex";
			if (proj=="oproject")               proj = "oproject@home";
			if (proj=="universe@home test")     proj = "universe@home";
			if (proj=="find@home")              proj = "fightmalaria";
			if (proj=="virtuallhc@home")        proj = "vLHCathome";
			return proj;
			*/
}

std::string strReplace(std::string& str, const std::string& oldStr, const std::string& newStr)
{
  size_t pos = 0;
  while((pos = str.find(oldStr, pos)) != std::string::npos){
     str.replace(pos, oldStr.length(), newStr);
     pos += newStr.length();
  }
  return str;
}

std::string LowerUnderscore(std::string data)
{
	boost::to_lower(data);
	data = strReplace(data,"_"," ");
	return data;
}

std::string ToOfficialNameNew(std::string proj)
{
	    proj = LowerUnderscore(proj);
		//Convert local XML project name [On the Left] to official [Netsoft] projectname:
		std::string sType = "projectmapping";
	    for(map<string,string>::iterator ii=mvApplicationCache.begin(); ii!=mvApplicationCache.end(); ++ii)
	    {
				std::string key_name  = (*ii).first;
			   	if (key_name.length() > sType.length())
				{
					if (key_name.substr(0,sType.length())==sType)
					{
							std::string key_value = mvApplicationCache[(*ii).first];
							std::vector<std::string> vKey = split(key_name,";");
							if (vKey.size() > 0)
							{
								std::string project_boinc   = vKey[1];
								std::string project_netsoft = key_value;
								proj=LowerUnderscore(proj);
								project_boinc=LowerUnderscore(project_boinc);
								project_netsoft=LowerUnderscore(project_netsoft);
								if (proj==project_boinc) proj=project_netsoft;
							}
					 }
				}
	    }
		return proj;
}




std::string GetBoincDataDir2()
{
	std::string path = "";
	/*       Default setting: boincdatadir=c:\\programdata\\boinc\\   */


    if (mapArgs.count("-boincdatadir"))
	{
        path = mapArgs["-boincdatadir"];
		if (path.length() > 0) return path;
    }

    #ifndef WIN32
    #ifdef __linux__
        path = "/var/lib/boinc-client/"; // Linux
    #else
        path = "/Library/Application Support/BOINC Data/"; // Mac OSX
    #endif
    #elif WINVER < 0x0600
        path = "c:\\documents and settings\\all users\\application data\\boinc\\"; // Windows XP
    #else
        path = "c:\\programdata\\boinc\\"; // Windows Vista and up
    #endif

    return path;
}


std::string GetArgument(std::string arg, std::string defaultvalue)
{
	std::string result = defaultvalue;
	if (mapArgs.count("-" + arg))
	{
		result = GetArg("-" + arg, defaultvalue);
	}
	return result;

}



void HarvestCPIDs(bool cleardata)
{

	if (fDebug10) printf("loading BOINC cpids ...\r\n");

	//Remote Boinc Feature - R Halford
	std::string sBoincKey = GetArgument("boinckey","");

	if (!sBoincKey.empty())
	{
		//Deserialize key into Global CPU Mining CPID 2-6-2015
		printf("Using key %s \r\n",sBoincKey.c_str());

		std::string sDec=DecodeBase64(sBoincKey);
		printf("Using key %s \r\n",sDec.c_str());

	    if (sDec.empty()) printf("Error while deserializing boinc key!  Please use execute genboinckey to generate a boinc key from the host with boinc installed.\r\n");
		GlobalCPUMiningCPID = DeserializeBoincBlock(sDec);

		GlobalCPUMiningCPID.initialized = true;

		if (GlobalCPUMiningCPID.cpid.empty())
		{
				 printf("Error while deserializing boinc key!  Please use execute genboinckey to generate a boinc key from the host with boinc installed.\r\n");
		}
		else
		{
			printf("CPUMiningCPID Initialized.\r\n");
		}

			GlobalCPUMiningCPID.email = GlobalCPUMiningCPID.aesskein;
			//GlobalCPUMiningCPID.boincruntimepublickey = GlobalCPUMiningCPID.lastblockhash;
			printf("Using Serialized Boinc CPID %s with orig email of %s and bpk of %s with cpidhash of %s \r\n",GlobalCPUMiningCPID.cpid.c_str(), GlobalCPUMiningCPID.email.c_str(), GlobalCPUMiningCPID.boincruntimepublickey.c_str(),GlobalCPUMiningCPID.cpidhash.c_str());
			GlobalCPUMiningCPID.cpidhash = GlobalCPUMiningCPID.boincruntimepublickey;
			printf("Using Serialized Boinc CPID %s with orig email of %s and bpk of %s with cpidhash of %s \r\n",GlobalCPUMiningCPID.cpid.c_str(), GlobalCPUMiningCPID.email.c_str(), GlobalCPUMiningCPID.boincruntimepublickey.c_str(),GlobalCPUMiningCPID.cpidhash.c_str());
			StructCPID structcpid = GetStructCPID();
			structcpid.initialized = true;
			structcpid.cpidhash = GlobalCPUMiningCPID.cpidhash;
			structcpid.projectname = GlobalCPUMiningCPID.projectname;
			structcpid.team = "gridcoin"; //Will be verified later during Netsoft Call
			structcpid.verifiedteam = "gridcoin";
			structcpid.rac = GlobalCPUMiningCPID.rac;
			structcpid.cpid = GlobalCPUMiningCPID.cpid;
			structcpid.boincpublickey = GlobalCPUMiningCPID.encboincpublickey;
			structcpid.boincruntimepublickey = structcpid.cpidhash;
			structcpid.NetworkRAC = GlobalCPUMiningCPID.NetworkRAC;
			structcpid.email = GlobalCPUMiningCPID.email;
			// 2-6-2015 R Halford - Ensure CPIDv2 Is populated After deserializing GenBoincKey
			std::string cpid_non = structcpid.cpidhash+structcpid.email;
			printf("GenBoincKey using email %s and cpidhash %s key %s \r\n",structcpid.email.c_str(),structcpid.cpidhash.c_str(),sDec.c_str());
			structcpid.cpidv2 = ComputeCPIDv2(structcpid.email, structcpid.cpidhash, 0);
			// Old link: structcpid.link = "http://boinc.netsoft-online.com/get_user.php?cpid=" + structcpid.cpid;
			structcpid.link = "http://boinc.netsoft-online.com/e107_plugins/boinc/get_user.php?cpid=" + structcpid.cpid;
			structcpid.Iscpidvalid = true;
			mvCPIDs.insert(map<string,StructCPID>::value_type(structcpid.projectname,structcpid));
			//11-12-2015
			CreditCheck(structcpid.cpid,false);
			GetNextProject(false);
			if (fDebug10) printf("GCMCPI %s",GlobalCPUMiningCPID.cpid.c_str());
			if (fDebug10) 			printf("Finished getting first remote boinc project\r\n");
		return;
  }

 try
 {

	std::string sourcefile = GetBoincDataDir2() + "client_state.xml";
    std::string sout = "";
    sout = getfilecontents(sourcefile);
	if (sout == "-1")
	{
		printf("Unable to obtain Boinc CPIDs \r\n");

		if (mapArgs.count("-boincdatadir") && mapArgs["-boincdatadir"].length() > 0)
		{
			printf("Boinc data directory set in gridcoinresearch.conf has been incorrectly specified \r\n");
		}

		else printf("Boinc data directory is not in the operating system's default location \r\nPlease move it there or specify its current location in gridcoinresearch.conf \r\n");

		return;
	}

	if (cleardata)
	{
		mvCPIDs.clear();
		mvCPIDCache.clear();
	}
	std::string email = GetArgument("email","");
    boost::to_lower(email);

	int iRow = 0;
	std::vector<std::string> vCPID = split(sout.c_str(),"<project>");
	std::string investor = GetArgument("investor","false");

	if (investor=="true")
	{
			msPrimaryCPID="INVESTOR";
	}
	else
	{


			if (vCPID.size() > 0)
			{

				for (unsigned int i = 0; i < vCPID.size(); i++)
				{
					std::string email_hash = ExtractXML(vCPID[i],"<email_hash>","</email_hash>");
					std::string cpidhash = ExtractXML(vCPID[i],"<cross_project_id>","</cross_project_id>");
					std::string externalcpid = ExtractXML(vCPID[i],"<external_cpid>","</external_cpid>");

					std::string utc=ExtractXML(vCPID[i],"<user_total_credit>","</user_total_credit>");
					std::string rac=ExtractXML(vCPID[i],"<user_expavg_credit>","</user_expavg_credit>");
					std::string proj=ExtractXML(vCPID[i],"<project_name>","</project_name>");
					std::string team=ExtractXML(vCPID[i],"<team_name>","</team_name>");
					std::string rectime = ExtractXML(vCPID[i],"<rec_time>","</rec_time>");

					if (Contains(vCPID[i],"<external_cpid>") && externalcpid.empty())
					{
						//externalcpid="?";
					}

					boost::to_lower(proj);
					proj = ToOfficialName(proj);
					ProjectIsValid(proj);
					int64_t nStart = GetTimeMillis();
					if (cpidhash.length() > 5 && proj.length() > 3)
					{
						std::string cpid_non = cpidhash+email;
						to_lower(cpid_non);
						StructCPID structcpid = GetInitializedStructCPID2(proj,mvCPIDs);
						iRow++;
						structcpid.cpidhash = cpidhash;
						structcpid.projectname = proj;
						boost::to_lower(team);
						structcpid.team = team;
						InitializeProjectStruct(structcpid);
						int64_t elapsed = GetTimeMillis()-nStart;
						if (fDebug3) printf("Enumerating boinc local project %s cpid %s valid %s, elapsed %f ",structcpid.projectname.c_str(),structcpid.cpid.c_str(),YesNo(structcpid.Iscpidvalid).c_str(),(double)elapsed);
						structcpid.rac = cdbl(rac,0);
						structcpid.verifiedrac = cdbl(rac,0);

						if (!structcpid.Iscpidvalid)
						{
							structcpid.errors = "CPID calculation invalid.  Check e-mail + reset project.";
						}

						structcpid.utc = cdbl(utc,0);
						structcpid.rectime = cdbl(rectime,0);
						double currenttime =  GetAdjustedTime();
						double nActualTimespan = currenttime - structcpid.rectime;
						structcpid.age = nActualTimespan;
						//Have credits been verified yet?
						//If not, Call out to credit check node:
						std::string sKey = structcpid.cpid + ":" + proj;
						mvCPIDs[proj] = structcpid;
	         			//structcpid = mvCPIDs[proj];

						if (!structcpid.Iscpidvalid)
						{
							structcpid.errors = "CPID invalid.  Check E-mail address.";
						}

						if (structcpid.rac < 10)
						{
							structcpid.Iscpidvalid = false;
							structcpid.errors = "RAC too low";
						}

						if (structcpid.verifiedrac < 10)
						{
							structcpid.Iscpidvalid = false;
							structcpid.errors="Verified RAC too low";
						}

						if (structcpid.team != "gridcoin")
						{
							structcpid.Iscpidvalid = false;
							structcpid.errors = "Team invalid";
						}
						bool bAcid = true;

						if (!externalcpid.empty())
						{
							bAcid = CPIDAcidTest2(cpidhash,externalcpid);
							if (!bAcid)
							{
								structcpid.Iscpidvalid = false;
								structcpid.errors = "CPID corrupted (ext cpid) ";
								printf("Primary cpid corrupted %s \r\n",externalcpid.c_str());
							}
							mvCPIDs[proj] = structcpid;
					   }


						//12-21-2015
						if (structcpid.Iscpidvalid && bAcid)
						{
								// Verify the CPID has magnitude > 0, otherwise set the user as an investor:
								int iCPIDType = DetermineCPIDType(structcpid.cpid);
								// -1 = Invalid CPID
								//  1 = Valid CPID with RAC
								//  2 = Investor or Pool Miner
								if (iCPIDType==1)
								{
									GlobalCPUMiningCPID.cpidhash = cpidhash;
									GlobalCPUMiningCPID.email = email;
									GlobalCPUMiningCPID.boincruntimepublickey = cpidhash;
								
									if (structcpid.rac > 10 && structcpid.team=="gridcoin")
									{
										msPrimaryCPID = structcpid.cpid;
										#if defined(WIN32) && defined(QT_GUI)
											//Let the Neural Network know what your CPID is so it can be charted:
											std::string sXML = "<KEY>PrimaryCPID</KEY><VALUE>" + msPrimaryCPID + "</VALUE>";
											std::string sData = qtExecuteDotNetStringFunction("WriteKey",sXML);
										#endif
										//Try to get a neural RAC report 7-25-2015
										AsyncNeuralRequest("explainmag",msPrimaryCPID,5);
									}
								}
						}

						mvCPIDs[proj] = structcpid;
						if (fDebug10) printf("Adding Local Project %s \r\n",structcpid.cpid.c_str());

					}

				}

			}
			// If no valid boinc projects were found:
			if (msPrimaryCPID.empty()) msPrimaryCPID="INVESTOR";

		}
	}
	catch (std::exception &e)
	{
			 printf("Error while harvesting CPIDs.\r\n");
	}
    catch(...)
	{
		     printf("Error while harvesting CPIDs 2.\r\n");
	}



}



void ThreadCPIDs()
{
	RenameThread("grc-cpids");
    bCPIDsLoaded = false;
	HarvestCPIDs(true);
	bCPIDsLoaded = true;
	//Reloads maglevel:
	printf("Performing 1st credit check (%s)",GlobalCPUMiningCPID.cpid.c_str());
	CreditCheck(GlobalCPUMiningCPID.cpid,false);
	printf("Getting first project");
	GetNextProject(false);
	printf("Finished getting first project");
	bProjectsInitialized = true;
}


void LoadCPIDsInBackground()
{
	  if (IsLockTimeWithinMinutes(nCPIDsLoaded,10)) return;
	  nCPIDsLoaded = GetAdjustedTime();
	  cpidThreads = new boost::thread_group();
	  cpidThreads->create_thread(boost::bind(&ThreadCPIDs));
}

StructCPID GetStructCPID()
{
	StructCPID c;
	c.cpid = "";
	c.emailhash="";
	c.cpidhash="";
	c.projectname="";
	c.initialized=false;
	c.isvoucher=false;
	c.rac = 0;
	c.utc=0;
	c.rectime=0;
	c.age = 0;
	c.team="";
	c.activeproject=false;
	c.verifiedutc=0;
	c.verifiedteam="";
	c.verifiedrectime=0;
	c.verifiedage=0;
	c.entries=0;
	c.AverageRAC=0;
	c.NetworkProjects=0;
	c.boincpublickey="";
	c.Iscpidvalid=false;
	c.link="";
	c.errors="";
	c.email="";
	c.boincruntimepublickey="";
	c.cpidv2="";
	c.NetworkRAC=0;
	c.TotalRAC=0;
	c.TotalNetworkRAC=0;
	c.Magnitude=0;
	c.LastMagnitude=0;
	c.PaymentMagnitude=0;
	c.owed=0;
	c.payments=0;
	c.outstanding=0;
	c.verifiedTotalRAC=0;
	c.verifiedTotalNetworkRAC=0;
	c.verifiedMagnitude=0;
	c.TotalMagnitude=0;
	c.MagnitudeCount=0;
	c.LowLockTime=0;
	c.HighLockTime=0;
	c.Accuracy=0;
	c.totalowed=0;
	c.longtermtotalowed=0;
	c.longtermowed=0;
	c.LastPaymentTime=0;
	c.EarliestPaymentTime=0;
	c.RSAWeight=0;
	c.PaymentTimespan=0;
	c.ResearchSubsidy = 0;
	c.InterestSubsidy = 0;
	c.BTCQuote = 0;
	c.GRCQuote = 0;
	c.ResearchSubsidy2 = 0;
	c.ResearchAge = 0;
	c.ResearchMagnitudeUnit = 0;
	c.ResearchAverageMagnitude = 0;
	c.LastPORBlockHash = "";
	c.CurrentNeuralHash = "";
	c.Canary = 0;
	c.NetsoftRAC = 0;
	c.interestPayments = 0;
	c.payments = 0;
	c.PaymentTimestamps = "";
	c.PaymentAmountsResearch = "";
	c.PaymentAmountsInterest = "";
	c.PaymentAmountsBlocks   = "";
	c.GRCAddress="";
	c.LastBlock = 0;
	c.NetworkMagnitude=0;
	c.NetworkAvgMagnitude=0;

	return c;

}

MiningCPID GetMiningCPID()
{
	MiningCPID mc;
	mc.projectname = "";
	mc.rac = 0;
	mc.encboincpublickey = "";
	mc.cpid = "";
	mc.cpidhash = "";
	mc.pobdifficulty = 0;
	mc.diffbytes = 0;
	mc.initialized = false;
	mc.enccpid = "";
	mc.aesskein = "";
	mc.encaes = "";
	mc.nonce = 0;
	mc.NetworkRAC=0;
	mc.prevBlockType = 0;
	mc.clientversion = "";
	mc.VouchedCPID = "";
	mc.cpidv2 = "";
	mc.email = "";
	mc.boincruntimepublickey = "";
	mc.GRCAddress = "";
	mc.lastblockhash = "0";
	mc.VouchedRAC = 0;
	mc.VouchedNetworkRAC  = 0;
	mc.Magnitude = 0;
	mc.Accuracy = 0;
	mc.RSAWeight = 0;
	mc.LastPaymentTime=0;
	mc.ResearchSubsidy = 0;
	mc.InterestSubsidy = 0;
	mc.GRCQuote = 0;
	mc.BTCQuote = 0;
	mc.ResearchSubsidy2 = 0;
	mc.ResearchAge = 0;
	mc.ResearchMagnitudeUnit = 0;
	mc.ResearchAverageMagnitude = 0;
	mc.LastPORBlockHash = "";
	mc.CurrentNeuralHash = "";
	mc.Canary = 0; //Used to test for a memory overflow
	mc.Organization = "";
	mc.OrganizationKey = "";
	mc.NeuralHash = "";
	mc.superblock = "";
	return mc;
}


void TrackRequests(CNode* pfrom,std::string sRequestType)
{
	    std::string sKey = "request_type" + sRequestType;
	    double dReqCt = cdbl(ReadCache(sKey,NodeAddress(pfrom)),0) + 1;
	    WriteCache(sKey,NodeAddress(pfrom),RoundToString(dReqCt,0),GetAdjustedTime());
        if ( (dReqCt > 20 && !fTestNet && !OutOfSyncByAge()) )
		{
					printf(" Node requests for %s exceeded threshhold (misbehaving) %s ",sRequestType.c_str(),NodeAddress(pfrom).c_str());
			        //pfrom->Misbehaving(1);
          			pfrom->fDisconnect = true;
					WriteCache(sKey,NodeAddress(pfrom),"0",GetAdjustedTime());
		}
}


bool SendMessages(CNode* pto, bool fSendTrickle)
{
    TRY_LOCK(cs_main, lockMain);
    if (lockMain) {
        // Don't send anything until we get their version message
        if (pto->nVersion == 0)
            return true;

        //
        // Message: ping
        //
        bool pingSend = false;
        if (pto->fPingQueued)
		{
            // RPC ping request by user
            pingSend = true;
        }
        if (pto->nPingNonceSent == 0 && pto->nPingUsecStart + PING_INTERVAL * 1000000 < GetTimeMicros())
		{
            // Ping automatically sent as a latency probe & keepalive.
            pingSend = true;
        }
        if (pingSend)
		{
		    uint64_t nonce = 0;
            while (nonce == 0) {
                RAND_bytes((unsigned char*)&nonce, sizeof(nonce));
            }
            pto->fPingQueued = false;
            pto->nPingUsecStart = GetTimeMicros();
            if (pto->nVersion > BIP0031_VERSION)
			{
                pto->nPingNonceSent = nonce;
				std::string acid = GetCommandNonce("ping");
                pto->PushMessage("ping", nonce, acid);
            } else
			{
                // Peer is too old to support ping command with nonce, pong will never arrive.
                pto->nPingNonceSent = 0;
                pto->PushMessage("ping");
            }
        }

        // Resend wallet transactions that haven't gotten in a block yet
	    ResendWalletTransactions();

        // Address refresh broadcast
        static int64_t nLastRebroadcast;
        if (!IsInitialBlockDownload() && ( GetAdjustedTime() - nLastRebroadcast > 24 * 60 * 60))
        {
            {
                LOCK(cs_vNodes);
                BOOST_FOREACH(CNode* pnode, vNodes)
                {
                    // Periodically clear setAddrKnown to allow refresh broadcasts
                    if (nLastRebroadcast)
                        pnode->setAddrKnown.clear();

                    // Rebroadcast our address
                    if (!fNoListen)
                    {
                        CAddress addr = GetLocalAddress(&pnode->addr);
                        if (addr.IsRoutable())
                            pnode->PushAddress(addr);
                    }
                }
            }
            nLastRebroadcast =  GetAdjustedTime();
        }

        //
        // Message: addr
        //
        if (fSendTrickle)
        {
            vector<CAddress> vAddr;
            vAddr.reserve(pto->vAddrToSend.size());
            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)
            {
                // returns true if wasn't already contained in the set
                if (pto->setAddrKnown.insert(addr).second)
                {
                    vAddr.push_back(addr);
                    // receiver rejects addr messages larger than 1000
                    if (vAddr.size() >= 1000)
                    {
                        pto->PushMessage("gridaddr", vAddr);
                        vAddr.clear();
                    }
                }
            }
            pto->vAddrToSend.clear();
            if (!vAddr.empty())
                pto->PushMessage("gridaddr", vAddr);
        }


        //
        // Message: inventory
        //
        vector<CInv> vInv;
        vector<CInv> vInvWait;
        {
            LOCK(pto->cs_inventory);
            vInv.reserve(pto->vInventoryToSend.size());
            vInvWait.reserve(pto->vInventoryToSend.size());
            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)
            {
                if (pto->setInventoryKnown.count(inv))
                    continue;

                // trickle out tx inv to protect privacy
                if (inv.type == MSG_TX && !fSendTrickle)
                {
                    // 1/4 of tx invs blast to all immediately
                    static uint256 hashSalt;
                    if (hashSalt == 0)
                        hashSalt = GetRandHash();
                    uint256 hashRand = inv.hash ^ hashSalt;
                    hashRand = Hash(BEGIN(hashRand), END(hashRand));
                    bool fTrickleWait = ((hashRand & 3) != 0);

                    // always trickle our own transactions
                    if (!fTrickleWait)
                    {
                        CWalletTx wtx;
                        if (GetTransaction(inv.hash, wtx))
                            if (wtx.fFromMe)
                                fTrickleWait = true;
                    }

                    if (fTrickleWait)
                    {
				        vInvWait.push_back(inv);
                        continue;
                    }
                }

			    // returns true if wasn't already contained in the set
                if (pto->setInventoryKnown.insert(inv).second)
                {
				     vInv.push_back(inv);
                     if (vInv.size() >= 1000)
                     {
							AddPeek("PushInv-Large " + RoundToString((double)vInv.size(),0));
							// If node has not been misbehaving (1-30-2016) then push it: (pto->nMisbehavior) && pto->NodeAddress().->addr.IsRoutable()
							pto->PushMessage("inv", vInv);
							AddPeek("Pushed Inv-Large " + RoundToString((double)vInv.size(),0));
							if (fDebug10) printf(" *PIL* ");
						    vInv.clear();
							if (TimerMain("PushInventoryLarge",50)) CleanInboundConnections(true);
							// Eventually ban the node if they keep asking for inventory
							TrackRequests(pto,"Inv-Large");
							AddPeek("Done with Inv-Large " + RoundToString((double)vInv.size(),0));
			        }
                }
            }
            pto->vInventoryToSend = vInvWait;
        }
        if (!vInv.empty())
            pto->PushMessage("inv", vInv);


        //
        // Message: getdata
        //
        vector<CInv> vGetData;
        int64_t nNow =  GetAdjustedTime() * 1000000;
        CTxDB txdb("r");
        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)
        {
            const CInv& inv = (*pto->mapAskFor.begin()).second;
            if (!AlreadyHave(txdb, inv))
            {
                if (fDebugNet)        printf("sending getdata: %s\n", inv.ToString().c_str());
				AddPeek("Getdata " + inv.ToString());
                vGetData.push_back(inv);
                if (vGetData.size() >= 1000)
                {
                    pto->PushMessage("getdata", vGetData);
                    vGetData.clear();
                }
                mapAlreadyAskedFor[inv] = nNow;
            }
            pto->mapAskFor.erase(pto->mapAskFor.begin());
        }
        if (!vGetData.empty())
		{
            pto->PushMessage("getdata", vGetData);
			AddPeek("GetData");
		}

    }
    return true;
}



std::string ReadCache(std::string section, std::string key)
{
	if (section.empty() || key.empty()) return "";

	try
	{
			std::string value = mvApplicationCache[section + ";" + key];
			if (value.empty())
			{
				mvApplicationCache.insert(map<std::string,std::string>::value_type(section + ";" + key,""));
				mvApplicationCache[section + ";" + key]="";
				return "";
			}
			return value;
	}
	catch(...)
	{
		printf("readcache error %s",section.c_str());
		return "";
	}
}


void WriteCache(std::string section, std::string key, std::string value, int64_t locktime)
{
	if (section.empty() || key.empty()) return;
	std::string temp_value = mvApplicationCache[section + ";" + key];
	if (temp_value.empty())
	{
		mvApplicationCache.insert(map<std::string,std::string>::value_type(section + ";" + key,value));
	    mvApplicationCache[section + ";" + key]=value;
	}
	mvApplicationCache[section + ";" + key]=value;
	// Record Cache Entry timestamp
	int64_t temp_locktime = mvApplicationCacheTimestamp[section + ";" + key];
	if (temp_locktime == 0)
	{
		mvApplicationCacheTimestamp.insert(map<std::string,int64_t>::value_type(section+";"+key,1));
		mvApplicationCacheTimestamp[section+";"+key]=locktime;
	}
	mvApplicationCacheTimestamp[section+";"+key] = locktime;

}



void PurgeCacheAsOfExpiration(std::string section, int64_t expiration)
{
	   for(map<string,string>::iterator ii=mvApplicationCache.begin(); ii!=mvApplicationCache.end(); ++ii)
	   {
				std::string key_section = mvApplicationCache[(*ii).first];
				if (key_section.length() > section.length())
				{
					if (key_section.substr(0,section.length())==section)
					{
						if (mvApplicationCacheTimestamp[key_section] < expiration)
						{
							printf("purging %s",key_section.c_str());
							mvApplicationCache[key_section]="";
							mvApplicationCacheTimestamp[key_section]=1;
						}
					}
				}
	   }

}


void ClearCache(std::string section)
{
	   for(map<string,string>::iterator ii=mvApplicationCache.begin(); ii!=mvApplicationCache.end(); ++ii)
	   {
				std::string key_section = mvApplicationCache[(*ii).first];
				if (key_section.length() > section.length())
				{
					if (key_section.substr(0,section.length())==section)
					{
						printf("\r\nClearing the cache....of value %s \r\n",mvApplicationCache[key_section].c_str());
						mvApplicationCache[key_section]="";
						mvApplicationCacheTimestamp[key_section]=1;
					}
				}
	   }

}


void DeleteCache(std::string section, std::string keyname)
{
	   std::string pk = section + ";" +keyname;
       mvApplicationCache.erase(pk);
	   mvApplicationCacheTimestamp.erase(pk);
}



void IncrementCurrentNeuralNetworkSupermajority(std::string NeuralHash, std::string GRCAddress, double distance)
{
	if (NeuralHash.length() < 5) return;
	double temp_hashcount = 0;
	if (mvCurrentNeuralNetworkHash.size() > 0)
	{
			temp_hashcount = mvCurrentNeuralNetworkHash[NeuralHash];
	}
	// 6-13-2015 ONLY Count Each Neural Hash Once per GRC address / CPID (1 VOTE PER RESEARCHER)
	std::string Security = ReadCache("currentneuralsecurity",GRCAddress);
	if (Security == NeuralHash)
	{
		//This node has already voted, throw away the vote
		return;
	}
	WriteCache("currentneuralsecurity",GRCAddress,NeuralHash,GetAdjustedTime());
	if (temp_hashcount == 0)
	{
		mvCurrentNeuralNetworkHash.insert(map<std::string,double>::value_type(NeuralHash,0));
	}
	double multiplier = 200;
	if (distance < 40) multiplier = 400;
	double votes = (1/distance)*multiplier;
	temp_hashcount += votes;
	mvCurrentNeuralNetworkHash[NeuralHash] = temp_hashcount;
}



void IncrementNeuralNetworkSupermajority(std::string NeuralHash, std::string GRCAddress, double distance)
{
	if (NeuralHash.length() < 5) return;
	double temp_hashcount = 0;
	if (mvNeuralNetworkHash.size() > 0)
	{
			temp_hashcount = mvNeuralNetworkHash[NeuralHash];
	}
	// 6-13-2015 ONLY Count Each Neural Hash Once per GRC address / CPID (1 VOTE PER RESEARCHER)
	std::string Security = ReadCache("neuralsecurity",GRCAddress);
	if (Security == NeuralHash)
	{
		//This node has already voted, throw away the vote
		return;
	}
	WriteCache("neuralsecurity",GRCAddress,NeuralHash,GetAdjustedTime());
	if (temp_hashcount == 0)
	{
		mvNeuralNetworkHash.insert(map<std::string,double>::value_type(NeuralHash,0));
	}
	double multiplier = 200;
	if (distance < 40) multiplier = 400;
	double votes = (1/distance)*multiplier;
	temp_hashcount += votes;
	mvNeuralNetworkHash[NeuralHash] = temp_hashcount;
}


void IncrementVersionCount(std::string Version)
{
	if (Version.empty()) return;
	double temp_vercount = 0;
	if (mvNeuralVersion.size() > 0)
	{
			temp_vercount = mvNeuralVersion[Version];
	}
	if (temp_vercount == 0)
	{
		mvNeuralVersion.insert(map<std::string,double>::value_type(Version,0));
	}
	temp_vercount += 1;
	mvNeuralVersion[Version] = temp_vercount;
}



std::string GetNeuralNetworkSupermajorityHash(double& out_popularity)
{
	double highest_popularity = -1;
	std::string neural_hash = "";
	for(map<std::string,double>::iterator ii=mvNeuralNetworkHash.begin(); ii!=mvNeuralNetworkHash.end(); ++ii)
	{
				double popularity = mvNeuralNetworkHash[(*ii).first];
				// d41d8 is the hash of an empty magnitude contract - don't count it
				if ( ((*ii).first != "d41d8cd98f00b204e9800998ecf8427e") && popularity > 0 && popularity > highest_popularity && (*ii).first != "TOTAL_VOTES")
				{
					highest_popularity = popularity;
					neural_hash = (*ii).first;
				}
	}
	out_popularity = highest_popularity;
	return neural_hash;
}


std::string GetCurrentNeuralNetworkSupermajorityHash(double& out_popularity)
{
	double highest_popularity = -1;
	std::string neural_hash = "";
	for(map<std::string,double>::iterator ii=mvCurrentNeuralNetworkHash.begin(); ii!=mvCurrentNeuralNetworkHash.end(); ++ii)
	{
				double popularity = mvCurrentNeuralNetworkHash[(*ii).first];
				// d41d8 is the hash of an empty magnitude contract - don't count it
				if ( ((*ii).first != "d41d8cd98f00b204e9800998ecf8427e") && popularity > 0 && popularity > highest_popularity && (*ii).first != "TOTAL_VOTES")
				{
					highest_popularity = popularity;
					neural_hash = (*ii).first;
				}
	}
	out_popularity = highest_popularity;
	return neural_hash;
}






std::string GetNeuralNetworkReport()
{
	//Returns a report of the networks neural hashes in order of popularity
	std::string neural_hash = "";
	std::string report = "Neural_hash, Popularity\r\n";
	std::string row = "";
	for(map<std::string,double>::iterator ii=mvNeuralNetworkHash.begin(); ii!=mvNeuralNetworkHash.end(); ++ii)
	{
				double popularity = mvNeuralNetworkHash[(*ii).first];
				neural_hash = (*ii).first;
				row = neural_hash+ "," + RoundToString(popularity,0);
				report += row + "\r\n";
	}

	return report;
}

std::string GetOrgSymbolFromFeedKey(std::string feedkey)
{
	std::string Symbol = ExtractValue(feedkey,"-",0);
	return Symbol;

}



bool MemorizeMessage(std::string msg, int64_t nTime, double dAmount, std::string sRecipient)
{
	      if (msg.empty()) return false;
		  bool fMessageLoaded = false;

		  if (Contains(msg,"<MT>"))
	 	  {
			  std::string sMessageType      = ExtractXML(msg,"<MT>","</MT>");
  			  std::string sMessageKey       = ExtractXML(msg,"<MK>","</MK>");
			  std::string sMessageValue     = ExtractXML(msg,"<MV>","</MV>");
			  std::string sMessageAction    = ExtractXML(msg,"<MA>","</MA>");
			  std::string sSignature        = ExtractXML(msg,"<MS>","</MS>");
			  std::string sMessagePublicKey = ExtractXML(msg,"<MPK>","</MPK>");
			  if (sMessageType=="beacon" && Contains(sMessageValue,"INVESTOR"))
			  {
					sMessageValue="";
			  }

			  if (sMessageType=="beacon" && sMessageAction=="A")
			  {
				    // If the Beacon Public Key is Not Empty - do not overwrite with a new beacon value
				    std::string sBPK = GetBeaconPublicKey(sMessageKey);
					if (!sBPK.empty()) 
					{
						// Do not overwrite this beacon
						sMessageValue="";
						if (fDebug10) printf("\r\n**Beacon Public Key Not Empty %s : %s\r\n",sMessageKey.c_str(),sBPK.c_str());
					}

			  }

			  if (!sMessageType.empty() && !sMessageKey.empty() && !sMessageValue.empty() && !sMessageAction.empty() && !sSignature.empty())
			  {

				  // If this is a DAO, ensure the contents are protected:
				  if ((sMessageType=="dao" || sMessageType=="daoclient") && !sMessagePublicKey.empty())
				  {
					        if (fDebug10) printf("DAO Message %s",msg.c_str());

							if (sMessageAction=="A")
							{
								std::string daoPubKey = ReadCache(sMessageType + "pubkey",sMessageKey);
								if (daoPubKey.empty())
								{
									//We only accept the first message
									WriteCache(sMessageType + "pubkey",sMessageKey,sMessagePublicKey,nTime);
									std::string OrgSymbol = ExtractXML(sMessageValue,"<SYMBOL>","</SYMBOL>");
									std::string OrgName = ExtractXML(sMessageValue,"<NAME>","</NAME>");
									std::string OrgREST = ExtractXML(sMessageValue,"<REST>","</REST>");
									WriteCache(sMessageType + "rest",  OrgSymbol,  OrgREST,    nTime);
									WriteCache(sMessageType + "symbol",sMessageKey,OrgSymbol,  nTime);
									WriteCache(sMessageType + "name",  OrgSymbol,  sMessageKey,nTime);
									WriteCache(sMessageType + "orgname", OrgSymbol,OrgName,    nTime);
								}
							}
				  }

				  if (sMessageType=="dao" || sMessageType=="daoclient")
				  {
						sMessagePublicKey = ReadCache(sMessageType+"pubkey",sMessageKey);
				  }
				  if (sMessageType == "daofeed")
				  {
			  			sMessagePublicKey = ReadCache("daopubkey",GetOrgSymbolFromFeedKey(sMessageKey));
				  }

				  //Verify sig first
				  bool Verified = CheckMessageSignature(sMessageAction,sMessageType,sMessageType+sMessageKey+sMessageValue,
					  sSignature,sMessagePublicKey);

				  if ( (sMessageType=="dao" || sMessageType == "daofeed") && !Verified && fDebug3)
				  {
						printf("Message type %s: %s was not verified successfully. PubKey %s \r\n",sMessageType.c_str(),msg.c_str(),sMessagePublicKey.c_str());
				  }

				  if (Verified)
				  {

						if (sMessageAction=="A")
						{
								if ( (sMessageType=="dao" || sMessageType == "daofeed")	&& fDebug3 )
									printf("Adding MessageKey type %s Key %s Value %s\r\n",
									sMessageType.c_str(),sMessageKey.c_str(),sMessageValue.c_str());
								// Ensure we have the TXID of the contract in memory
								if (!(sMessageType=="project" || sMessageType=="projectmapping" || sMessageType=="beacon" ))
								{
									WriteCache(sMessageType,sMessageKey+";Recipient",sRecipient,nTime);
									WriteCache(sMessageType,sMessageKey+";BurnAmount",RoundToString(dAmount,2),nTime);
								}
								WriteCache(sMessageType,sMessageKey,sMessageValue,nTime);
								fMessageLoaded = true;
								if (sMessageType=="poll")
								{
									    if (Contains(sMessageKey,"[Foundation"))
										{
												msMiningErrors2 = "Foundation Poll: " + sMessageKey;

										}
										else
										{
						    					msMiningErrors2 = "Poll: " + sMessageKey;
										}
								}

						}
						else if(sMessageAction=="D")
						{
								if (fDebug10) printf("Deleting key type %s Key %s Value %s\r\n",sMessageType.c_str(),sMessageKey.c_str(),sMessageValue.c_str());
								DeleteCache(sMessageType,sMessageKey);
								fMessageLoaded = true;
						}
						// If this is a boinc project, load the projects into the coin:
						if (sMessageType=="project" || sMessageType=="projectmapping")
						{
							//Reserved
							fMessageLoaded = true;
						}

				  }

				}

	}
   return fMessageLoaded;
}







bool UnusualActivityReport()
{

    map<uint256, CTxIndex> mapQueuedChanges;
    CTxDB txdb("r");
	int nMaxDepth = nBestHeight;
    CBlock block;
	int nMinDepth = fTestNet ? 1 : 1;
	if (nMaxDepth < nMinDepth || nMaxDepth < 10) return false;
	nMinDepth = 50000;
	nMaxDepth = nBestHeight;
	int ii = 0;
			for (ii = nMinDepth; ii <= nMaxDepth; ii++)
			{
     			CBlockIndex* pblockindex = FindBlockByHeight(ii);
				if (block.ReadFromDisk(pblockindex))
				{
					int64_t nFees = 0;
					int64_t nValueIn = 0;
					int64_t nValueOut = 0;
					int64_t nStakeReward = 0;
					//unsigned int nSigOps = 0;
					double DPOR_Paid = 0;
					bool bIsDPOR = false;
					std::string MainRecipient = "";
					double max_subsidy = GetMaximumBoincSubsidy(block.nTime)+50; //allow for
					BOOST_FOREACH(CTransaction& tx, block.vtx)
					{

						    MapPrevTx mapInputs;
					        if (tx.IsCoinBase())
									nValueOut += tx.GetValueOut();
							else
							{
									 bool fInvalid;
									 bool TxOK = tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid);
									 if (!TxOK) continue;
									 int64_t nTxValueIn = tx.GetValueIn(mapInputs);
									 int64_t nTxValueOut = tx.GetValueOut();
									 nValueIn += nTxValueIn;
									 nValueOut += nTxValueOut;
									 if (!tx.IsCoinStake())             nFees += nTxValueIn - nTxValueOut;
									 if (tx.IsCoinStake())
				  				 	 {
											nStakeReward = nTxValueOut - nTxValueIn;
											if (tx.vout.size() > 2) bIsDPOR = true;
											//DPOR Verification of each recipient (Recipients start at output position 2 (0=Coinstake flag, 1=coinstake)
											if (tx.vout.size() > 2)
											{
												MainRecipient = PubKeyToAddress(tx.vout[2].scriptPubKey);
											}
											int iStart = 3;
											if (ii > 267500) iStart=2;
											if (bIsDPOR)
											{
													for (unsigned int i = iStart; i < tx.vout.size(); i++)
													{
														std::string Recipient = PubKeyToAddress(tx.vout[i].scriptPubKey);
														double      Amount    = CoinToDouble(tx.vout[i].nValue);
														if (Amount > GetMaximumBoincSubsidy(GetAdjustedTime()))
														{
														}

														if (Amount > max_subsidy)
														{
															printf("Block #%f:%f, Recipient %s, Paid %f\r\n",(double)ii,(double)i,Recipient.c_str(),Amount);
														}
			   	 	  	 							    DPOR_Paid += Amount;

													}

										   }
								     }

								//if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))                return false;
							}

					}

					int64_t TotalMint = nValueOut - nValueIn + nFees;
					double subsidy = CoinToDouble(TotalMint);
					if (subsidy > max_subsidy)
					{
						std::string hb = block.vtx[0].hashBoinc;
						MiningCPID bb = DeserializeBoincBlock(hb);
						if (bb.cpid != "INVESTOR")
						{
								printf("Block #%f:%f, Recipient %s, CPID %s, Paid %f, StakeReward %f \r\n",(double)ii,(double)0,
									bb.GRCAddress.c_str(), bb.cpid.c_str(), subsidy,(double)nStakeReward);
						}
				}

			}
		}


    return true;
}


void TestScan()
{
	BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)
    {
        CBlockIndex* pindex = item.second;
		if (LessVerbose(1) || pindex->nHeight > nNewIndex)
		{
			printf("map block index h %f ,  cpid %s   , Mag  %f , RS %f, INT %f \r\n",(double)pindex->nHeight,pindex->sCPID.c_str(), (double)pindex->nMagnitude,
				pindex->nResearchSubsidy,pindex->nInterestSubsidy);
		}
    }
}


void TestScan2()
{
	CBlockIndex* pindex = pindexBest;
    while (pindex->nHeight > 1)
	{
        pindex = pindex->pprev;
		if (LessVerbose(1) || pindex->nHeight > nNewIndex)
		{
			printf("map block index h %f ,  cpid %s   , Mag  %f , RS %f, INT %f \r\n",(double)pindex->nHeight,pindex->sCPID.c_str(), (double)pindex->nMagnitude,
				pindex->nResearchSubsidy,pindex->nInterestSubsidy);
		}

	}
}

double GRCMagnitudeUnit(int64_t locktime)
{
	//7-12-2015 - Calculate GRCMagnitudeUnit (Amount paid per magnitude per day)
	StructCPID network = GetInitializedStructCPID2("NETWORK",mvNetwork);
	double TotalNetworkMagnitude = network.NetworkMagnitude;
	if (TotalNetworkMagnitude < 1000) TotalNetworkMagnitude=1000;
	double MaximumEmission = BLOCKS_PER_DAY*GetMaximumBoincSubsidy(locktime);
	double Kitty = MaximumEmission - (network.payments/14);
	if (Kitty < 1) Kitty = 1;
	double MagnitudeUnit = 0;
	if (bNewbieFeatureEnabled)
	{
		MagnitudeUnit = (Kitty/TotalNetworkMagnitude)*1.25;
	}
	else
	{
		MagnitudeUnit = Kitty/TotalNetworkMagnitude;
	}
	if (MagnitudeUnit > 5) MagnitudeUnit = 5; //Just in case we lose a superblock or something strange happens.
	MagnitudeUnit = SnapToGrid(MagnitudeUnit); //Snaps the value into .025 increments
	return MagnitudeUnit;
}


int64_t ComputeResearchAccrual(int64_t nTime, std::string cpid, std::string operation, CBlockIndex* pindexLast, bool bVerifyingBlock, int iVerificationPhase, double& dAccrualAge, double& dMagnitudeUnit, double& AvgMagnitude)
{
	double dCurrentMagnitude = CalculatedMagnitude2(cpid, nTime, false);
	CBlockIndex* pHistorical = GetHistoricalMagnitude(cpid);
	if (pHistorical->nHeight <= nNewIndex || pHistorical->nMagnitude==0 || pHistorical->nTime == 0)
	{
		//No prior block exists... Newbies get .01 age to bootstrap the CPID (otherwise they will not have any prior block to refer to, thus cannot get started):
		if (!bNewbieFeatureEnabled)
		{
				return dCurrentMagnitude > 0 ? ((dCurrentMagnitude/100)*COIN) : 0;
		}
		else
		{
			// New rules - 12-4-2015 - Pay newbie from the moment beacon was sent as long as it is within 6 months old and NN mag > 0 and newbie is in the superblock and their lifetime paid is zero
			// Note: If Magnitude is zero, or researcher is not in superblock, or lifetimepaid > 0, this function returns zero
			int64_t iBeaconTimestamp = BeaconTimeStamp(cpid, true);
			if (IsLockTimeWithinMinutes(iBeaconTimestamp, 60*24*30*6))
			{
				double dNewbieAccrualAge = ((double)nTime - (double)iBeaconTimestamp) / 86400;
				int64_t iAccrual = (int64_t)(dNewbieAccrualAge*dCurrentMagnitude*dMagnitudeUnit*COIN);
				if (fDebug3) printf("\r\n Newbie Special Stake! %s  Age %f, Accrual %f \r\n",cpid.c_str(),dNewbieAccrualAge,(double)iAccrual);
				return iAccrual;
			}
		}
	}
	// To prevent reorgs and checkblock errors, ensure the research age is > 10 blocks wide:
	int iRABlockSpan = pindexLast->nHeight - pHistorical->nHeight;
	StructCPID stCPID = GetInitializedStructCPID2(cpid,mvResearchAge);
	double dAvgMag = stCPID.ResearchAverageMagnitude;
	// ResearchAge: If the accrual age is > 20 days, add in the midpoint lifetime average magnitude to ensure the overall avg magnitude accurate:
	if (iRABlockSpan > (int)(BLOCKS_PER_DAY*20))
	{
			AvgMagnitude = (pHistorical->nMagnitude + dAvgMag + dCurrentMagnitude) / 3;
	}
	else
	{
			AvgMagnitude = (pHistorical->nMagnitude + dCurrentMagnitude) / 2;
	}
	if (AvgMagnitude > 20000) AvgMagnitude = 20000;

	dAccrualAge = ((double)nTime - (double)pHistorical->nTime) / 86400;
	if (dAccrualAge < 0) dAccrualAge=0;
	dMagnitudeUnit = GRCMagnitudeUnit(nTime);

	int64_t Accrual = (int64_t)(dAccrualAge*AvgMagnitude*dMagnitudeUnit*COIN);
	// Double check researcher lifetime paid
	double days = (((double)nTime) - stCPID.LowLockTime)/86400;
	double PPD = stCPID.ResearchSubsidy/(days+.01);
	double ReferencePPD = dMagnitudeUnit*dAvgMag;
	if ((PPD > ReferencePPD*5))
	{
			printf("Researcher PPD %f > Reference PPD %f for CPID %s with Lifetime Avg Mag of %f, Days %f \r\n",PPD,ReferencePPD,cpid.c_str(),dAvgMag,days);
			Accrual = 0; //Since this condition can occur when a user ramps up computing power, lets return 0 so as to not shortchange the researcher, but instead, owed will continue to accrue and will be paid later when PPD falls below 5
	}
	// Note that if the RA Block Span < 10, we want to return 0 for the Accrual Amount so the CPID can still receive an accurate accrual in the future
	if (iRABlockSpan < 10 && iVerificationPhase != 2) Accrual = 0;

	double verbosity = (operation == "createnewblock" || operation == "createcoinstake") ? 10 : 1000;
	if ((fDebug3 && LessVerbose(verbosity)) || (fDebug3 && iVerificationPhase==2)) printf(" Operation %s, ComputedAccrual %f, StakeHeight %f, RABlockSpan %f, HistoryHeight%f, AccrualAge %f, AvgMag %f, MagUnit %f, PPD %f, Reference PPD %f  \r\n",
		operation.c_str(),CoinToDouble(Accrual),(double)pindexLast->nHeight,(double)iRABlockSpan,
		(double)pHistorical->nHeight,	dAccrualAge,AvgMagnitude,dMagnitudeUnit, PPD, ReferencePPD);
	return Accrual;
}



CBlockIndex* GetHistoricalMagnitude(std::string cpid)
{
	if (cpid=="INVESTOR") return pindexGenesisBlock;
	// Starting at the block prior to StartHeight, find the last instance of the CPID in the chain:
	// Limit lookback to 6 months
	int nMinIndex = pindexBest->nHeight-(6*30*BLOCKS_PER_DAY);
	if (nMinIndex < 2) nMinIndex=2;
	// Last block Hash paid to researcher
	StructCPID stCPID = GetInitializedStructCPID2(cpid,mvResearchAge);
	if (!stCPID.BlockHash.empty())
	{
		uint256 hash(stCPID.BlockHash);
		if (mapBlockIndex.count(hash) == 0) return pindexGenesisBlock;
		CBlockIndex* pblockindex = mapBlockIndex[hash];
		if ((double)pblockindex->nHeight < nMinIndex)
		{
			// In this case, the last staked block was Found, but it is over 6 months old....
			printf("Last staked block found at height %f, but cannot verify magnitude older than 6 months! \r\n",(double)pblockindex->nHeight);
			return pindexGenesisBlock;
		}

		return pblockindex;
	}
	else
	{
		return pindexGenesisBlock;
	}
}

void ZeroOutResearcherTotals(std::string cpid)
{
	if (!cpid.empty())
	{

				StructCPID stCPID = GetInitializedStructCPID2(cpid,mvResearchAge);
				stCPID.LastBlock = 0;
				stCPID.BlockHash = "";
				stCPID.InterestSubsidy = 0;
				stCPID.ResearchSubsidy = 0;
				stCPID.Accuracy = 0;
				stCPID.LowLockTime = 99999999999;
				stCPID.HighLockTime = 0;
				stCPID.TotalMagnitude = 0;
				stCPID.ResearchAverageMagnitude = 0;

				mvResearchAge[cpid]=stCPID;
	}

}




CBlockIndex* GetHistoricalMagnitude_ScanChain(std::string cpid)
{
	CBlockIndex* pindex = pindexBest;
	if (cpid=="INVESTOR") return pindexGenesisBlock;

	// Starting at the block prior to StartHeight, find the last instance of the CPID in the chain:
	// Limit lookback to 6 months
	int nMinIndex = pindexBest->nHeight-(6*30*BLOCKS_PER_DAY);
	if (nMinIndex < 2) nMinIndex=2;
    while (pindex->nHeight > nNewIndex && pindex->nHeight > nMinIndex)
	{
  	    //8-5-2015; R HALFORD; Find the last block the CPID staked with a research subsidy (IE dont count interest blocks)
		if (!pindex || !pindex->pprev) return pindexGenesisBlock;
		if (!pindex->IsInMainChain()) continue;
		if (pindex == pindexGenesisBlock) return pindexGenesisBlock;
		if (pindex->sCPID == cpid && (pindex->nResearchSubsidy > 0)) return pindex;
	    pindex = pindex->pprev;
	}
    return pindexGenesisBlock;
}


bool LoadAdminMessages(bool bFullTableScan, std::string& out_errors)
{
	int nMaxDepth = nBestHeight;
    int nMinDepth = fTestNet ? 1 : 164618;
	nMinDepth = pindexBest->nHeight - (BLOCKS_PER_DAY*30*6);
	if (nMinDepth < 2) nMinDepth=2;
	if (!bFullTableScan) nMinDepth = nMaxDepth-6;
	if (nMaxDepth < nMinDepth) return false;
	CBlockIndex* pindex = pindexBest;
	pindex = FindBlockByHeight(nMinDepth);
	// These are memorized consecutively in order from oldest to newest

    while (pindex->nHeight < nMaxDepth)
	{
		if (!pindex || !pindex->pnext) return false;
	    pindex = pindex->pnext;
		if (pindex==NULL) continue;
		if (!pindex || !pindex->IsInMainChain()) continue;
		if (IsContract(pindex))
		{
			CBlock block;
			if (!block.ReadFromDisk(pindex)) continue;
			int iPos = 0;
			BOOST_FOREACH(const CTransaction &tx, block.vtx)
			{
				  if (iPos > 0)
				  {
					  // Retrieve the Burn Amount for Contracts
					  double dAmount = 0;
					  std::string sRecipient = "";
   					  for (unsigned int i = 1; i < tx.vout.size(); i++)
					  {
							sRecipient = PubKeyToAddress(tx.vout[i].scriptPubKey);
							dAmount += CoinToDouble(tx.vout[i].nValue);
					  }
					  MemorizeMessage(tx.hashBoinc,tx.nTime,dAmount,sRecipient);
				  }
				  iPos++;
			}
		}
	}
	
	return true;
}




MiningCPID GetBoincBlockByIndex(CBlockIndex* pblockindex)
{
	CBlock block;
	MiningCPID bb;
	bb.initialized=false;
	if (!pblockindex || !pblockindex->IsInMainChain()) return bb;
	if (block.ReadFromDisk(pblockindex))
	{
		std::string hashboinc = "";
		if (block.vtx.size() > 0) hashboinc = block.vtx[0].hashBoinc;
		bb = DeserializeBoincBlock(hashboinc);
		bb.initialized=true;
		return bb;
	}
	return bb;
}

std::string CPIDHash(double dMagIn, std::string sCPID)
{
    std::string sMag = RoundToString(dMagIn,0);
	double dMagLength = (double)sMag.length();
	double dExponent = pow(dMagLength,5);
	std::string sMagComponent1 = RoundToString(dMagIn/(dExponent+.01),0);
	std::string sSuffix = RoundToString(dMagLength * dExponent, 0);
    std::string sHash = sCPID + sMagComponent1 + sSuffix;
	//	printf("%s, %s, %f, %f, %s\r\n",sCPID.c_str(), sMagComponent1.c_str(),dMagLength,dExponent,sSuffix.c_str());
    return sHash;
}

std::string GetQuorumHash(std::string data)
{
		//Data includes the Magnitudes, and the Projects:
        std::string sMags = ExtractXML(data,"<MAGNITUDES>","</MAGNITUDES>");
		std::vector<std::string> vMags = split(sMags.c_str(),";");
	    std::string sHashIn = "";
        for (unsigned int x = 0; x < vMags.size(); x++)
		{
			if (vMags[x].length() > 10)
			{
				std::vector<std::string> vRow = split(vMags[x].c_str(),",");
				if (vRow.size() > 0)
				{
                  if (vRow[0].length() > 5)
				  {
						std::string sCPID = vRow[0];
						double dMag = cdbl(vRow[1],0);
                        sHashIn += CPIDHash(dMag, sCPID) + "<COL>";
				   }
				}
			}
		}
		std::string sHash = RetrieveMd5(sHashIn);
		return sHash;
}


std::string getHardwareID()
{
	std::string ele1 = "?";
	#ifdef QT_GUI
	    ele1 = getMacAddress();
	#endif
	ele1 += ":" + getCpuHash();
	ele1 += ":" + getHardDriveSerial();

	std::string hwid = RetrieveMd5(ele1);
	return hwid;
}

static void getCpuid( unsigned int* p, unsigned int ax )
 {
    __asm __volatile
    (   "movl %%ebx, %%esi\n\t"
        "cpuid\n\t"
        "xchgl %%ebx, %%esi"
        : "=a" (p[0]), "=S" (p[1]),
          "=c" (p[2]), "=d" (p[3])
        : "0" (ax)
    );
 }

 std::string getCpuHash()
 {
    std::string n = boost::asio::ip::host_name();
	#ifdef WIN32
		unsigned int cpuinfo[4] = { 0, 0, 0, 0 };
		getCpuid( cpuinfo, 0 );
		unsigned short hash = 0;
		unsigned int* ptr = (&cpuinfo[0]);
		for ( unsigned int i = 0; i < 4; i++ )
			hash += (ptr[i] & 0xFFFF) + ( ptr[i] >> 16 );
		double dHash = (double)hash;
		return n + ";" + RoundToString(dHash,0);
	#else
		return n;
	#endif
 }



std::string SystemCommand(const char* cmd)
{
    FILE* pipe = popen(cmd, "r");
    if (!pipe) return "ERROR";
    char buffer[128];
    std::string result = "";
    while(!feof(pipe))
	{
    	if(fgets(buffer, 128, pipe) != NULL)
    		result += buffer;
    }
    pclose(pipe);
    return result;
}


std::string getHardDriveSerial()
{
	if (!msHDDSerial.empty()) return msHDDSerial;
	std::string cmd1 = "";
	#ifdef WIN32
		cmd1 = "wmic path win32_physicalmedia get SerialNumber";
	#else
		cmd1 = "ls /dev/disk/by-uuid";
	#endif
	std::string result = SystemCommand(cmd1.c_str());
	//if (fDebug3) printf("result %s",result.c_str());
	msHDDSerial = result;
	return result;
}

std::string GetBlockIndexData(std::string sKey)
{
  	CTxDB txdb;
	std::string sValue = "";
	if (!txdb.ReadGenericData(sKey,sValue)) return "";
	return sValue;
}

bool SetBlockIndexData(std::string sKey, std::string sValue)
{
		CTxDB txdb;
		txdb.TxnBegin();
		if (!txdb.WriteGenericData(sKey,sValue)) return false;
		if (!txdb.TxnCommit()) return false;
		return true;
}

bool IsContract(CBlockIndex* pIndex)
{
	if (!fTestNet)
	{
		if (pIndex->nHeight > 650000)
		{
			return pIndex->nIsContract==1 ? true : false;
		}
		else if (pIndex->nHeight >= 0 && pIndex->nHeight <= 500000)		{	 		return (Contains(msProdSeedContracts400000,RoundToString((double)pIndex->nHeight,0))) ? true : false;
		}		else if (pIndex->nHeight >= 500000 && pIndex->nHeight <= 550000)		{	 		return (Contains(msProdSeedContracts500000,RoundToString((double)pIndex->nHeight,0))) ? true : false;
		}		else if (pIndex->nHeight >= 550000 && pIndex->nHeight <= 575000)		{	 		return (Contains(msProdSeedContracts550000,RoundToString((double)pIndex->nHeight,0))) ? true : false;
		}		else if (pIndex->nHeight >= 575001 && pIndex->nHeight <= 600000)		{	 		return (Contains(msProdSeedContracts575000,RoundToString((double)pIndex->nHeight,0))) ? true : false;
		}		else if (pIndex->nHeight >= 600000 && pIndex->nHeight <= 650000)		{	 		return (Contains(msProdSeedContracts600000,RoundToString((double)pIndex->nHeight,0))) ? true : false;
		}		}
	return pIndex->nIsContract==1 ? true : false;
}

bool IsSuperBlock(CBlockIndex* pIndex)
{
	if (pIndex->nHeight < nNewIndex2)
	{
		return (Contains(msSuperBlockHashes,pIndex->GetBlockHash().GetHex())) ? true : false;
	}
	else
	{
		return pIndex->nIsSuperBlock==1 ? true : false;
	}
}

void SetUpExtendedBlockIndexFieldsOnce()
{
	//9-13-2015: The goal is to write nContract and nIsSuperBlock to the database for blocks with height < nNewIndex2 to save Initial Chain Load Time
	printf("SETUPExtendedBIfieldsOnce Testnet: %s \r\n",YesNo(fTestNet).c_str());
	if (fTestNet)
	{
			msSuperBlockHashes = msTestNetSeedSuperblocks;			//msContracts = msTestNetSeedContracts;			if (pindexBest->nHeight < 20000) return;			//return;
	}
	else
	{
		    // Reserved for Future Use
			msSuperBlockHashes = msProdSeedSuperblocks;
			//msContracts = "";
			////Seed contracts from block 1-342799
			if (pindexBest->nHeight < 361873) return;
	}

	//9-28-2015
	std::string sSuperblocks = "";
	std::string sContracts   = "";
    CBlockIndex* pindex = pindexGenesisBlock;
	int iStartHeight = fTestNet ? 20000 : 361873;

	pindex = FindBlockByHeight(iStartHeight);
    if (!pindex) return;

	if (pindex && pindex->pnext)
	{
		while (pindex->nHeight < (nNewIndex2 + 1))
		{
				if (!pindex || !pindex->pnext) break;
				pindex = pindex->pnext;
				if (pindex==NULL || !pindex->IsInMainChain()) continue;
				CBlock block;
				if (!block.ReadFromDisk(pindex)) continue;
	     		MiningCPID bb = DeserializeBoincBlock(block.vtx[0].hashBoinc);
				if (bb.superblock.length() > 20)
				{
						sSuperblocks += pindex->GetBlockHash().GetHex() + ",";
				}

				BOOST_FOREACH(const CTransaction &tx, block.vtx)
				{
						if (tx.hashBoinc.length() > 20)
						{
							bool fMemorized = MemorizeMessage(tx.hashBoinc,tx.nTime,0,"");
							if (fMemorized)
							{
								sContracts += pindex->GetBlockHash().GetHex() + ",";
								break;
							}
						}
				}
		}
	}
	msSuperBlockHashes += sSuperblocks;
	//msContracts += sContracts;
}


double SnapToGrid(double d)
{
	double dDither = .04;
	double dOut = cdbl(RoundToString(d*dDither,3),3) / dDither;
	return dOut;
}



bool NeuralNodeParticipates()
{
	//Calculate the nodes GRC_Address_Day
	std::string address_day = DefaultWalletAddress() + "_" + RoundToString(GetDayOfYear(),0);
	std::string address_day_hash = RetrieveMd5(address_day);
	// For now, let's call for a 25% participation rate (approx. 125 nodes):
	// When RA is enabled, 25% of the neural network nodes will work on a quorum at any given time to alleviate stress on the project sites:
	uint256 uRef;
	if (IsResearchAgeEnabled(pindexBest->nHeight))
	{
		uRef = fTestNet ? uint256("0x00000000000000000000000000000000ed182f81388f317df738fd9994e7020b") : uint256("0x000000000000000000000000000000004d182f81388f317df738fd9994e7020b"); //This hash is approx 25% of the md5 range (90% for testnet)
	}
	else
	{
		uRef = fTestNet ? uint256("0x00000000000000000000000000000000ed182f81388f317df738fd9994e7020b") : uint256("0x00000000000000000000000000000000fd182f81388f317df738fd9994e7020b"); //This hash is approx 25% of the md5 range (90% for testnet)
	}
	uint256 uADH = uint256("0x" + address_day_hash);
	//printf("%s < %s : %s",uADH.GetHex().c_str() ,uRef.GetHex().c_str(), YesNo(uADH  < uRef).c_str());
	//printf("%s < %s : %s",uTest.GetHex().c_str(),uRef.GetHex().c_str(), YesNo(uTest < uRef).c_str());
	return (uADH < uRef);
}


bool StrLessThanReferenceHash(std::string rh)
{
	std::string address_day = rh + "_" + RoundToString(GetDayOfYear(),0);
	std::string address_day_hash = RetrieveMd5(address_day);
	uint256 uRef = fTestNet ? uint256("0x000000000000000000000000000000004d182f81388f317df738fd9994e7020b") : uint256("0x000000000000000000000000000000004d182f81388f317df738fd9994e7020b"); //This hash is approx 25% of the md5 range (90% for testnet)
	uint256 uADH = uint256("0x" + address_day_hash);
	return (uADH < uRef);
}


// The cumulative normal distribution function 
double CND(double X)
{
	double L, K, w ;
	double const a1 = 0.31938153, a2 = -0.356563782, a3 = 1.781477937;
	double const a4 = -1.821255978, a5 = 1.330274429;
	L = fabs(X);
	K = 1.0 / (1.0 + 0.2316419 * L);
	w = 1.0 - 1.0 / sqrt(2 * mPI) * exp(-L *L / 2) * (a1 * K + a2 * K *K + a3 * pow(K,3) + a4 * pow(K,4) + a5 * pow(K,5));
	if (X < 0 )
	{
			w= 1.0 - w;
	}
	return w;
}


// The Black and Scholes (1973) Stock option formula
double BlackScholes(std::string CallPutFlag, double UL, double X, double T, double r, double v)
{
	double d1, d2;
	// Input protection
	if (T == 0 ) T  = 0.00001;
	if (UL == 0) UL = 0.00001;
	if (X == 0 ) X  = 0.00001;
	d1 = (log(UL / X) + (r + v*v/2) * T) / (v * sqrt(T));
	d2 = d1 - v * sqrt(T);
	double Price = 0;
	if (CallPutFlag == "c")
	{
		Price = UL * CND(d1)-X * exp(-r*T) * CND(d2);
	}
	if (CallPutFlag == "p")
	{
		Price = X * exp(-r * T) * CND(-d2) - UL * CND(-d1);
	}
	Price = cdbl(RoundToString(Price,6),6);
	return Price;
}


double GetDelta(std::string sType, double UL, double Strike, double dTime, double RiskFreeRate, double Volatility)
{
	double delta = 0;
	double dPrice1 = 0;
	double dPrice2 = 0;
	double change = UL / 200;
	if (UL==0) return 0;
	//	printf(" type %s, UL %f, Strike %f, time %f, Vol %f ",sType.c_str(),UL,Strike,dTime,Volatility);
	dPrice1 = BlackScholes(sType, UL, Strike, dTime, RiskFreeRate, Volatility);
	dPrice2 = BlackScholes(sType, UL + change, Strike, dTime, RiskFreeRate, Volatility);
	delta = (dPrice2 - dPrice1) / change;
	delta = cdbl(RoundToString(delta,6),6);
	return delta;
}



double GetVolatility(std::string sPriceHistory)
{
	std::vector<std::string> vData = split(sPriceHistory.c_str(),";");
	double dDeviation = GetStandardDeviation(sPriceHistory);
	// Compute Historical Volatility
	double dTradingDays = vData.size();
	double dHistoricalVolatility = sqrt(dTradingDays) * dDeviation;
	printf(" Get Vol  Trading Days %f, Hist Vol %f, Dev %f ",dTradingDays,dHistoricalVolatility,dDeviation);
	return dHistoricalVolatility;
}

int64_t CoinFromValue(double dAmount)
{
    if (dAmount <= 0.0 || dAmount > MAX_MONEY)        throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount");
	int64_t nAmount = roundint64(dAmount * COIN);
    if (!MoneyRange(nAmount))                         throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount");
    return nAmount;
}


double GetStandardDeviation(std::string sPriceHistory)
{

	std::vector<std::string> vPH   = split(sPriceHistory.c_str(),";");
	std::vector<std::string> vData = split(sPriceHistory.c_str(),";");
	double n = vData.size();
	if (n < 2) return 0;
	vData[0] = "";
	
	for (int xx = 1; xx < n; xx++)
	{
		double change = 0;
		double a2 = 0;
		double a1 = 0;
		a1 = cdbl(vPH[xx-1],2);
		a2 = cdbl(vPH[xx],2);
		change = (a2 / (a1+.0001)) - 1;
        vData[xx] = RoundToString(change,4);
	}

	// Calculate the deviation of the Change of underlying percentages, not of the prices
	double dMean = 0;
	
	for (int X = 0; X < n; X++)
	{
		double data1 = cdbl(vData[X],4);
        dMean += data1;
	}
    
	double dSumDeviation = 0;
    dMean = dMean / n;
	for (int i = 0; i < n; i++)
	{
	   double data1 = cdbl(vData[i],4);
	   dSumDeviation += ((data1 - dMean) * (data1 - dMean));
    }
	double dStdDev = sqrt(dSumDeviation / n);
	return dStdDev;
}



